# Comparing `tmp/huaweicloudsdkaos-3.1.47-py2.py3-none-any.whl.zip` & `tmp/huaweicloudsdkaos-3.1.48-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,123 +1,123 @@
-Zip file size: 224384 bytes, number of entries: 121
--rw-r--r--  2.0 unx        0 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/__init__.py
--rw-r--r--  2.0 unx    10498 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/__init__.py
--rw-r--r--  2.0 unx    83506 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/aos_async_client.py
--rw-r--r--  2.0 unx    83263 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/aos_client.py
--rw-r--r--  2.0 unx    10361 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/__init__.py
--rw-r--r--  2.0 unx     4189 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/agencies_primitive_type_holder.py
--rw-r--r--  2.0 unx     4416 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/agency.py
--rw-r--r--  2.0 unx     7325 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/apply_execution_plan_request.py
--rw-r--r--  2.0 unx     8119 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/apply_execution_plan_request_body.py
--rw-r--r--  2.0 unx     3645 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/apply_execution_plan_response.py
--rw-r--r--  2.0 unx     7177 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/base_template.py
--rw-r--r--  2.0 unx     6305 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/base_template_version.py
--rw-r--r--  2.0 unx     5754 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/continue_deploy_stack_request.py
--rw-r--r--  2.0 unx     5068 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/continue_deploy_stack_request_body.py
--rw-r--r--  2.0 unx     3353 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/continue_deploy_stack_response.py
--rw-r--r--  2.0 unx     5794 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/continue_rollback_stack_request.py
--rw-r--r--  2.0 unx     5082 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/continue_rollback_stack_request_body.py
--rw-r--r--  2.0 unx     3648 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/continue_rollback_stack_response.py
--rw-r--r--  2.0 unx     5754 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/create_execution_plan_request.py
--rw-r--r--  2.0 unx    25127 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/create_execution_plan_request_body.py
--rw-r--r--  2.0 unx     5509 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/create_execution_plan_response.py
--rw-r--r--  2.0 unx     4265 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/create_stack_request.py
--rw-r--r--  2.0 unx    27687 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/create_stack_request_body.py
--rw-r--r--  2.0 unx     5965 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/create_stack_response.py
--rw-r--r--  2.0 unx    12224 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/delete_execution_plan_request.py
--rw-r--r--  2.0 unx     2459 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/delete_execution_plan_response.py
--rw-r--r--  2.0 unx     7463 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/delete_stack_request.py
--rw-r--r--  2.0 unx     2427 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/delete_stack_response.py
--rw-r--r--  2.0 unx     5558 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/delete_template_request.py
--rw-r--r--  2.0 unx     2439 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/delete_template_response.py
--rw-r--r--  2.0 unx     6741 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/delete_template_version_request.py
--rw-r--r--  2.0 unx     2467 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/delete_template_version_response.py
--rw-r--r--  2.0 unx     5594 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/deploy_stack_request.py
--rw-r--r--  2.0 unx    22257 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/deploy_stack_request_body.py
--rw-r--r--  2.0 unx     3289 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/deploy_stack_response.py
--rw-r--r--  2.0 unx     3561 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/deployment_id_primitive_type_holder.py
--rw-r--r--  2.0 unx     4407 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/enable_auto_rollback_primitive_type_holder.py
--rw-r--r--  2.0 unx     4443 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/enable_deletion_protection_primitive_type_holder.py
--rw-r--r--  2.0 unx     2997 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/encryption_structure.py
--rw-r--r--  2.0 unx    12385 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/estimate_execution_plan_price_request.py
--rw-r--r--  2.0 unx     4608 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/estimate_execution_plan_price_response.py
--rw-r--r--  2.0 unx    17284 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/execution_plan.py
--rw-r--r--  2.0 unx     3482 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/execution_plan_description_primitive_type_holder.py
--rw-r--r--  2.0 unx     8615 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/execution_plan_diff_attribute.py
--rw-r--r--  2.0 unx     5438 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/execution_plan_id_primitive_type_holder.py
--rw-r--r--  2.0 unx    24968 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/execution_plan_item.py
--rw-r--r--  2.0 unx     4001 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/execution_plan_name_primitive_type_holder.py
--rw-r--r--  2.0 unx     3764 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/execution_plan_status_message_primitive_type_holder.py
--rw-r--r--  2.0 unx     4462 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/execution_plan_status_primitive_type_holder.py
--rw-r--r--  2.0 unx     5048 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/execution_plan_summary.py
--rw-r--r--  2.0 unx    12339 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/get_execution_plan_metadata_request.py
--rw-r--r--  2.0 unx    26418 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/get_execution_plan_metadata_response.py
--rw-r--r--  2.0 unx    12155 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/get_execution_plan_request.py
--rw-r--r--  2.0 unx     3717 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/get_execution_plan_response.py
--rw-r--r--  2.0 unx     7538 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/get_stack_metadata_request.py
--rw-r--r--  2.0 unx    27497 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/get_stack_metadata_response.py
--rw-r--r--  2.0 unx     7538 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/get_stack_template_request.py
--rw-r--r--  2.0 unx     3170 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/get_stack_template_response.py
--rw-r--r--  2.0 unx     8504 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/index_primitive_type_holder.py
--rw-r--r--  2.0 unx    16325 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/items_response.py
--rw-r--r--  2.0 unx     3952 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/kms_structure.py
--rw-r--r--  2.0 unx     7568 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_execution_plans_request.py
--rw-r--r--  2.0 unx     3755 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_execution_plans_response.py
--rw-r--r--  2.0 unx    11955 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_stack_events_request.py
--rw-r--r--  2.0 unx     3479 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_stack_events_response.py
--rw-r--r--  2.0 unx     7538 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_stack_outputs_request.py
--rw-r--r--  2.0 unx     3376 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_stack_outputs_response.py
--rw-r--r--  2.0 unx     7568 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_stack_resources_request.py
--rw-r--r--  2.0 unx     3647 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_stack_resources_response.py
--rw-r--r--  2.0 unx     3455 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_stacks_request.py
--rw-r--r--  2.0 unx     3443 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_stacks_response.py
--rw-r--r--  2.0 unx     5648 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_template_versions_request.py
--rw-r--r--  2.0 unx     3438 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_template_versions_response.py
--rw-r--r--  2.0 unx     3476 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_templates_request.py
--rw-r--r--  2.0 unx     3359 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/list_templates_response.py
--rw-r--r--  2.0 unx     4441 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/parse_template_variables_request.py
--rw-r--r--  2.0 unx     9787 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/parse_template_variables_request_body.py
--rw-r--r--  2.0 unx     3526 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/parse_template_variables_response.py
--rw-r--r--  2.0 unx     3663 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/resource_attribute.py
--rw-r--r--  2.0 unx     4639 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/resource_name_primitive_type_holder.py
--rw-r--r--  2.0 unx    11190 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/resource_price_response.py
--rw-r--r--  2.0 unx     4522 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/resource_type_primitive_type_holder.py
--rw-r--r--  2.0 unx     5648 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/show_template_metadata_request.py
--rw-r--r--  2.0 unx     7666 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/show_template_metadata_response.py
--rw-r--r--  2.0 unx     6836 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/show_template_version_content_request.py
--rw-r--r--  2.0 unx     3250 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/show_template_version_content_response.py
--rw-r--r--  2.0 unx     6855 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/show_template_version_metadata_request.py
--rw-r--r--  2.0 unx     6737 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/show_template_version_metadata_response.py
--rw-r--r--  2.0 unx    13440 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/stack.py
--rw-r--r--  2.0 unx     3408 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/stack_description_primitive_type_holder.py
--rw-r--r--  2.0 unx    21626 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/stack_event.py
--rw-r--r--  2.0 unx     5040 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/stack_id_primitive_type_holder.py
--rw-r--r--  2.0 unx     3711 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/stack_name_primitive_type_holder.py
--rw-r--r--  2.0 unx     7751 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/stack_output.py
--rw-r--r--  2.0 unx    22545 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/stack_resource.py
--rw-r--r--  2.0 unx     3690 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/stack_status_message_primitive_type_holder.py
--rw-r--r--  2.0 unx     5463 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/stack_status_primitive_type_holder.py
--rw-r--r--  2.0 unx     9197 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/template.py
--rw-r--r--  2.0 unx     4863 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/template_body_primitive_type_holder.py
--rw-r--r--  2.0 unx     7246 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/template_uri_primitive_type_holder.py
--rw-r--r--  2.0 unx     7003 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/template_version.py
--rw-r--r--  2.0 unx     5594 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/update_stack_request.py
--rw-r--r--  2.0 unx    11785 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/update_stack_request_body.py
--rw-r--r--  2.0 unx     2427 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/update_stack_response.py
--rw-r--r--  2.0 unx     5376 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/update_template_metadata_request.py
--rw-r--r--  2.0 unx     4563 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/update_template_metadata_request_body.py
--rw-r--r--  2.0 unx     2471 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/update_template_metadata_response.py
--rw-r--r--  2.0 unx    30140 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/variable_response.py
--rw-r--r--  2.0 unx     4111 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/variable_validation_response.py
--rw-r--r--  2.0 unx     5217 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/vars_body_primitive_type_holder.py
--rw-r--r--  2.0 unx     5198 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/vars_structure.py
--rw-r--r--  2.0 unx     5956 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/vars_structure_primitive_type_holder.py
--rw-r--r--  2.0 unx     3407 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/vars_uri_content_primitive_type_holder.py
--rw-r--r--  2.0 unx     5835 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/model/vars_uri_primitive_type_holder.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/region/__init__.py
--rw-r--r--  2.0 unx     1337 b- defN 23-Jul-06 10:03 huaweicloudsdkaos/v1/region/aos_region.py
--rwxr-xr-x  2.0 unx      604 b- defN 23-Jul-06 10:03 huaweicloudsdkaos-3.1.47.dist-info/LICENSE
--rw-r--r--  2.0 unx     1136 b- defN 23-Jul-06 10:03 huaweicloudsdkaos-3.1.47.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 23-Jul-06 10:03 huaweicloudsdkaos-3.1.47.dist-info/WHEEL
--rw-r--r--  2.0 unx       18 b- defN 23-Jul-06 10:03 huaweicloudsdkaos-3.1.47.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    13653 b- defN 23-Jul-06 10:03 huaweicloudsdkaos-3.1.47.dist-info/RECORD
-121 files, 1017730 bytes uncompressed, 201572 bytes compressed:  80.2%
+Zip file size: 225387 bytes, number of entries: 121
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/__init__.py
+-rw-r--r--  2.0 unx    10447 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/__init__.py
+-rw-r--r--  2.0 unx    87676 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/aos_async_client.py
+-rw-r--r--  2.0 unx    87433 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/aos_client.py
+-rw-r--r--  2.0 unx    10361 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/__init__.py
+-rw-r--r--  2.0 unx     4186 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/agencies_primitive_type_holder.py
+-rw-r--r--  2.0 unx     4416 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/agency.py
+-rw-r--r--  2.0 unx     7325 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/apply_execution_plan_request.py
+-rw-r--r--  2.0 unx     8113 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/apply_execution_plan_request_body.py
+-rw-r--r--  2.0 unx     3642 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/apply_execution_plan_response.py
+-rw-r--r--  2.0 unx     7177 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/base_template.py
+-rw-r--r--  2.0 unx     6305 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/base_template_version.py
+-rw-r--r--  2.0 unx     5754 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/continue_deploy_stack_request.py
+-rw-r--r--  2.0 unx     5065 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/continue_deploy_stack_request_body.py
+-rw-r--r--  2.0 unx     3353 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/continue_deploy_stack_response.py
+-rw-r--r--  2.0 unx     5794 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/continue_rollback_stack_request.py
+-rw-r--r--  2.0 unx     5079 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/continue_rollback_stack_request_body.py
+-rw-r--r--  2.0 unx     3648 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/continue_rollback_stack_response.py
+-rw-r--r--  2.0 unx     5754 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/create_execution_plan_request.py
+-rw-r--r--  2.0 unx    25109 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/create_execution_plan_request_body.py
+-rw-r--r--  2.0 unx     5506 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/create_execution_plan_response.py
+-rw-r--r--  2.0 unx     4265 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/create_stack_request.py
+-rw-r--r--  2.0 unx    27663 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/create_stack_request_body.py
+-rw-r--r--  2.0 unx     5962 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/create_stack_response.py
+-rw-r--r--  2.0 unx    12218 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/delete_execution_plan_request.py
+-rw-r--r--  2.0 unx     2459 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/delete_execution_plan_response.py
+-rw-r--r--  2.0 unx     7460 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/delete_stack_request.py
+-rw-r--r--  2.0 unx     2427 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/delete_stack_response.py
+-rw-r--r--  2.0 unx     5558 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/delete_template_request.py
+-rw-r--r--  2.0 unx     2439 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/delete_template_response.py
+-rw-r--r--  2.0 unx     6741 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/delete_template_version_request.py
+-rw-r--r--  2.0 unx     2467 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/delete_template_version_response.py
+-rw-r--r--  2.0 unx     5594 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/deploy_stack_request.py
+-rw-r--r--  2.0 unx    22239 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/deploy_stack_request_body.py
+-rw-r--r--  2.0 unx     3289 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/deploy_stack_response.py
+-rw-r--r--  2.0 unx     3558 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/deployment_id_primitive_type_holder.py
+-rw-r--r--  2.0 unx     4404 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/enable_auto_rollback_primitive_type_holder.py
+-rw-r--r--  2.0 unx     4440 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/enable_deletion_protection_primitive_type_holder.py
+-rw-r--r--  2.0 unx     2997 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/encryption_structure.py
+-rw-r--r--  2.0 unx    12379 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/estimate_execution_plan_price_request.py
+-rw-r--r--  2.0 unx     4605 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/estimate_execution_plan_price_response.py
+-rw-r--r--  2.0 unx    17263 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/execution_plan.py
+-rw-r--r--  2.0 unx     3482 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/execution_plan_description_primitive_type_holder.py
+-rw-r--r--  2.0 unx     8609 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/execution_plan_diff_attribute.py
+-rw-r--r--  2.0 unx     5435 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/execution_plan_id_primitive_type_holder.py
+-rw-r--r--  2.0 unx    24950 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/execution_plan_item.py
+-rw-r--r--  2.0 unx     4001 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/execution_plan_name_primitive_type_holder.py
+-rw-r--r--  2.0 unx     3764 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/execution_plan_status_message_primitive_type_holder.py
+-rw-r--r--  2.0 unx     4447 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/execution_plan_status_primitive_type_holder.py
+-rw-r--r--  2.0 unx     5048 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/execution_plan_summary.py
+-rw-r--r--  2.0 unx    12333 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/get_execution_plan_metadata_request.py
+-rw-r--r--  2.0 unx    26385 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/get_execution_plan_metadata_response.py
+-rw-r--r--  2.0 unx    12149 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/get_execution_plan_request.py
+-rw-r--r--  2.0 unx     3717 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/get_execution_plan_response.py
+-rw-r--r--  2.0 unx     7535 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/get_stack_metadata_request.py
+-rw-r--r--  2.0 unx    27446 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/get_stack_metadata_response.py
+-rw-r--r--  2.0 unx     7535 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/get_stack_template_request.py
+-rw-r--r--  2.0 unx     3170 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/get_stack_template_response.py
+-rw-r--r--  2.0 unx     8501 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/index_primitive_type_holder.py
+-rw-r--r--  2.0 unx    16313 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/items_response.py
+-rw-r--r--  2.0 unx     3952 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/kms_structure.py
+-rw-r--r--  2.0 unx     7565 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_execution_plans_request.py
+-rw-r--r--  2.0 unx     3755 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_execution_plans_response.py
+-rw-r--r--  2.0 unx    11946 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_stack_events_request.py
+-rw-r--r--  2.0 unx     3479 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_stack_events_response.py
+-rw-r--r--  2.0 unx     7535 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_stack_outputs_request.py
+-rw-r--r--  2.0 unx     3376 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_stack_outputs_response.py
+-rw-r--r--  2.0 unx     7565 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_stack_resources_request.py
+-rw-r--r--  2.0 unx     3647 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_stack_resources_response.py
+-rw-r--r--  2.0 unx     3455 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_stacks_request.py
+-rw-r--r--  2.0 unx     3443 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_stacks_response.py
+-rw-r--r--  2.0 unx     5648 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_template_versions_request.py
+-rw-r--r--  2.0 unx     3438 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_template_versions_response.py
+-rw-r--r--  2.0 unx     3476 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_templates_request.py
+-rw-r--r--  2.0 unx     3359 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/list_templates_response.py
+-rw-r--r--  2.0 unx     4441 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/parse_template_variables_request.py
+-rw-r--r--  2.0 unx     9781 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/parse_template_variables_request_body.py
+-rw-r--r--  2.0 unx     3526 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/parse_template_variables_response.py
+-rw-r--r--  2.0 unx     3663 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/resource_attribute.py
+-rw-r--r--  2.0 unx     4636 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/resource_name_primitive_type_holder.py
+-rw-r--r--  2.0 unx    11181 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/resource_price_response.py
+-rw-r--r--  2.0 unx     4519 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/resource_type_primitive_type_holder.py
+-rw-r--r--  2.0 unx     5648 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/show_template_metadata_request.py
+-rw-r--r--  2.0 unx     7666 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/show_template_metadata_response.py
+-rw-r--r--  2.0 unx     6836 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/show_template_version_content_request.py
+-rw-r--r--  2.0 unx     3250 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/show_template_version_content_response.py
+-rw-r--r--  2.0 unx     6855 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/show_template_version_metadata_request.py
+-rw-r--r--  2.0 unx     6737 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/show_template_version_metadata_response.py
+-rw-r--r--  2.0 unx    13410 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/stack.py
+-rw-r--r--  2.0 unx     3408 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/stack_description_primitive_type_holder.py
+-rw-r--r--  2.0 unx    21608 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/stack_event.py
+-rw-r--r--  2.0 unx     5037 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/stack_id_primitive_type_holder.py
+-rw-r--r--  2.0 unx     3711 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/stack_name_primitive_type_holder.py
+-rw-r--r--  2.0 unx     7745 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/stack_output.py
+-rw-r--r--  2.0 unx    22527 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/stack_resource.py
+-rw-r--r--  2.0 unx     3690 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/stack_status_message_primitive_type_holder.py
+-rw-r--r--  2.0 unx     5436 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/stack_status_primitive_type_holder.py
+-rw-r--r--  2.0 unx     9185 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/template.py
+-rw-r--r--  2.0 unx     4860 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/template_body_primitive_type_holder.py
+-rw-r--r--  2.0 unx     7243 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/template_uri_primitive_type_holder.py
+-rw-r--r--  2.0 unx     7003 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/template_version.py
+-rw-r--r--  2.0 unx     5594 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/update_stack_request.py
+-rw-r--r--  2.0 unx    11773 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/update_stack_request_body.py
+-rw-r--r--  2.0 unx     2427 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/update_stack_response.py
+-rw-r--r--  2.0 unx     5376 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/update_template_metadata_request.py
+-rw-r--r--  2.0 unx     4563 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/update_template_metadata_request_body.py
+-rw-r--r--  2.0 unx     2471 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/update_template_metadata_response.py
+-rw-r--r--  2.0 unx    30122 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/variable_response.py
+-rw-r--r--  2.0 unx     4111 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/variable_validation_response.py
+-rw-r--r--  2.0 unx     5214 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/vars_body_primitive_type_holder.py
+-rw-r--r--  2.0 unx     5195 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/vars_structure.py
+-rw-r--r--  2.0 unx     5953 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/vars_structure_primitive_type_holder.py
+-rw-r--r--  2.0 unx     3407 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/vars_uri_content_primitive_type_holder.py
+-rw-r--r--  2.0 unx     5832 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/model/vars_uri_primitive_type_holder.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/region/__init__.py
+-rw-r--r--  2.0 unx     1337 b- defN 23-Jul-13 09:54 huaweicloudsdkaos/v1/region/aos_region.py
+-rw-r--r--  2.0 unx      604 b- defN 23-Jul-13 09:55 huaweicloudsdkaos-3.1.48.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1136 b- defN 23-Jul-13 09:55 huaweicloudsdkaos-3.1.48.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 23-Jul-13 09:55 huaweicloudsdkaos-3.1.48.dist-info/WHEEL
+-rw-r--r--  2.0 unx       18 b- defN 23-Jul-13 09:55 huaweicloudsdkaos-3.1.48.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    13653 b- defN 23-Jul-13 09:55 huaweicloudsdkaos-3.1.48.dist-info/RECORD
+121 files, 1025527 bytes uncompressed, 202575 bytes compressed:  80.2%
```

## zipnote {}

```diff
@@ -342,23 +342,23 @@
 
 Filename: huaweicloudsdkaos/v1/region/__init__.py
 Comment: 
 
 Filename: huaweicloudsdkaos/v1/region/aos_region.py
 Comment: 
 
-Filename: huaweicloudsdkaos-3.1.47.dist-info/LICENSE
+Filename: huaweicloudsdkaos-3.1.48.dist-info/LICENSE
 Comment: 
 
-Filename: huaweicloudsdkaos-3.1.47.dist-info/METADATA
+Filename: huaweicloudsdkaos-3.1.48.dist-info/METADATA
 Comment: 
 
-Filename: huaweicloudsdkaos-3.1.47.dist-info/WHEEL
+Filename: huaweicloudsdkaos-3.1.48.dist-info/WHEEL
 Comment: 
 
-Filename: huaweicloudsdkaos-3.1.47.dist-info/top_level.txt
+Filename: huaweicloudsdkaos-3.1.48.dist-info/top_level.txt
 Comment: 
 
-Filename: huaweicloudsdkaos-3.1.47.dist-info/RECORD
+Filename: huaweicloudsdkaos-3.1.48.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## huaweicloudsdkaos/v1/__init__.py

```diff
@@ -1,15 +1,14 @@
 # coding: utf-8
 
 from __future__ import absolute_import
 
-# import AosClient
 from huaweicloudsdkaos.v1.aos_client import AosClient
 from huaweicloudsdkaos.v1.aos_async_client import AosAsyncClient
-# import models into sdk package
+
 from huaweicloudsdkaos.v1.model.agencies_primitive_type_holder import AgenciesPrimitiveTypeHolder
 from huaweicloudsdkaos.v1.model.agency import Agency
 from huaweicloudsdkaos.v1.model.apply_execution_plan_request import ApplyExecutionPlanRequest
 from huaweicloudsdkaos.v1.model.apply_execution_plan_request_body import ApplyExecutionPlanRequestBody
 from huaweicloudsdkaos.v1.model.apply_execution_plan_response import ApplyExecutionPlanResponse
 from huaweicloudsdkaos.v1.model.base_template import BaseTemplate
 from huaweicloudsdkaos.v1.model.base_template_version import BaseTemplateVersion
```

## huaweicloudsdkaos/v1/aos_async_client.py

```diff
@@ -1000,21 +1000,36 @@
             request_type=request.__class__.__name__)
 
     def get_stack_template_async(self, request):
         """获取资源栈模板
 
         获取资源栈模板（GetStackTemplate）
         
-        此API用于获取资源栈最近的一次部署使用的模板。
+        此API用于获取资源栈最近一次部署终态使用的模板。
+        
+        注：
+        当资源栈状态处于非终态（即以&#x60;IN_PROGRESS&#x60;结尾，详细见下方）状态时，资源栈处于转变阶段，此API获取资源栈上一次部署使用的模板。
+        只有当资源栈状态处于终态（即以&#x60;COMPLETE&#x60;或&#x60;FAILED&#x60;结尾，详细见下方）时，此API获取当前最新一次部署使用的模板。CREATION_COMPLETE除外，此时资源栈没有模板，返回404，并提示模板不存在
+        
+        非终态状态包括但不限于以下状态：
+          * 正在部署（DEPLOYMENT_IN_PROGRESS）
+          * 正在回滚（ROLLBACK_IN_PROGRESS）
+          * 正在删除（DELETION_IN_PROGRESS）
+        
+        终态状态包括但不限于以下状态：
+          * 生成空资源栈完成（CREATION_COMPLETE）
+          * 部署失败（DEPLOYMENT_FAILED）
+          * 部署完成（DEPLOYMENT_COMPLETE）
+          * 回滚失败（ROLLBACK_FAILED）
+          * 回滚完成（ROLLBACK_COMPLETE）
+          * 删除失败（DELETION_FAILED）
         
         如果获取成功，则以临时重定向形式返回模板下载链接（OBS Pre Signed地址，有效期为5分钟），大多数的客户端会进行自动重定向并下载模板；
         若未进行自动重定向，请参考HTTP的重定向规则获取模板下载链接，手动下载模板。
         
-        若资源栈当前没有模板，则返回404，并提示模板不存在
-        
         Please refer to HUAWEI cloud API Explorer for details.
 
 
         :param request: Request instance for GetStackTemplate
         :type request: :class:`huaweicloudsdkaos.v1.GetStackTemplateRequest`
         :rtype: :class:`huaweicloudsdkaos.v1.GetStackTemplateResponse`
         """
@@ -1485,15 +1500,15 @@
         """删除模板
 
         删除模板（DeleteTemplate）
         
         此API用于删除某个模板以及模板下的全部模板版本
         **请谨慎操作，删除模板将会删除模板下的所有模板版本。**
         
-          * 若template_name和template_id同时存在，则模板服务会检查是否两个匹配
+          * tempate_id是模板的唯一Id。此Id由资源编排服务在生成模板的时候生成，为UUID。由于模板名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的模板，删除，再重新创建一个同名模板。对于团队并行开发，用户可能希望确保，当前我操作的模板就是我认为的那个，而不是其他队友删除后创建的同名模板。因此，使用ID就可以做到强匹配。资源编排服务保证每次创建的模板所对应的ID都不相同，更新不会影响ID。如果给与的template_id和当前模板管理的ID不一致，则返回400
         
         Please refer to HUAWEI cloud API Explorer for details.
 
 
         :param request: Request instance for DeleteTemplate
         :type request: :class:`huaweicloudsdkaos.v1.DeleteTemplateRequest`
         :rtype: :class:`huaweicloudsdkaos.v1.DeleteTemplateResponse`
@@ -1550,15 +1565,15 @@
     def delete_template_version_async(self, request):
         """删除模板版本
 
         删除模板版本（DeleteTemplateVersion）
         
         此API用于删除某个模板版本
         
-          * 若template_name和template_id同时存在，则模板服务会检查是否两个匹配，否则返回400
+          * tempate_id是模板的唯一Id。此Id由资源编排服务在生成模板的时候生成，为UUID。由于模板名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的模板，删除，再重新创建一个同名模板。对于团队并行开发，用户可能希望确保，当前我操作的模板就是我认为的那个，而不是其他队友删除后创建的同名模板。因此，使用ID就可以做到强匹配。资源编排服务保证每次创建的模板所对应的ID都不相同，更新不会影响ID。如果给与的template_id和当前模板管理的ID不一致，则返回400
           * 若模板下只存在唯一模板版本，此模板版本将无法被删除，如果需要删除此模板版本，请调用DeleteTemplate。模板服务不允许存在没有模板版本的模板
         
         **请谨慎操作**
         
         Please refer to HUAWEI cloud API Explorer for details.
 
 
@@ -1623,15 +1638,15 @@
         列举模板版本信息（ListTemplateVersions）
         
         此API用于列举模板下所有的模板版本信息
         
           * 默认按照生成时间排序，最早生成的模板排列在最前面
           * 注意：目前返回全量模板版本信息，即不支持分页
           * 如果没有任何模板版本，则返回空list
-          * 若template_name和template_id同时存在，则模板服务会检查是否两个匹配
+          * tempate_id是模板的唯一Id。此Id由资源编排服务在生成模板的时候生成，为UUID。由于模板名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的模板，删除，再重新创建一个同名模板。对于团队并行开发，用户可能希望确保，当前我操作的模板就是我认为的那个，而不是其他队友删除后创建的同名模板。因此，使用ID就可以做到强匹配。资源编排服务保证每次创建的模板所对应的ID都不相同，更新不会影响ID。如果给与的template_id和当前模板管理的ID不一致，则返回400
           * 若模板不存在则返回404
         
         ListTemplateVersions返回的信息只包含模板版本摘要信息（具体摘要信息见ListTemplateVersionsResponseBody），若用户需要了解模板版本内容，请调用ShowTemplateVersionContent
         
         Please refer to HUAWEI cloud API Explorer for details.
 
 
@@ -1759,15 +1774,15 @@
 
         获取模板元数据（ShowTemplateMetadata）
         
         此API用于获取当前模板的元数据信息
         
         具体信息见ShowTemplateMetadataResponseBody，若想查看模板下全部模板版本，请调用ListTemplateVersions。
         
-          * 若template_name和template_id同时存在，则模板服务会检查是否两个匹配
+          * tempate_id是模板的唯一Id。此Id由资源编排服务在生成模板的时候生成，为UUID。由于模板名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的模板，删除，再重新创建一个同名模板。对于团队并行开发，用户可能希望确保，当前我操作的模板就是我认为的那个，而不是其他队友删除后创建的同名模板。因此，使用ID就可以做到强匹配。资源编排服务保证每次创建的模板所对应的ID都不相同，更新不会影响ID。如果给与的template_id和当前模板管理的ID不一致，则返回400
         
         Please refer to HUAWEI cloud API Explorer for details.
 
 
         :param request: Request instance for ShowTemplateMetadata
         :type request: :class:`huaweicloudsdkaos.v1.ShowTemplateMetadataRequest`
         :rtype: :class:`huaweicloudsdkaos.v1.ShowTemplateMetadataResponse`
@@ -1824,15 +1839,15 @@
     def show_template_version_content_async(self, request):
         """获取模板版本内容
 
         获取模板版本内容（ShowTemplateVersionContent）
         
         此API用于获取用户的模板版本内容
         
-          * 若template_name和template_id同时存在，则模板服务会检查是否两个匹配，否则返回400
+          * tempate_id是模板的唯一Id。此Id由资源编排服务在生成模板的时候生成，为UUID。由于模板名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的模板，删除，再重新创建一个同名模板。对于团队并行开发，用户可能希望确保，当前我操作的模板就是我认为的那个，而不是其他队友删除后创建的同名模板。因此，使用ID就可以做到强匹配。资源编排服务保证每次创建的模板所对应的ID都不相同，更新不会影响ID。如果给与的template_id和当前模板管理的ID不一致，则返回400
           * 此api会以临时重定向形式返回模板内容的下载链接，用户通过下载获取模板版本内容（OBS Pre Signed地址，有效期为5分钟）
         
         ShowTemplateVersionContent返回的信息只包含模板版本内容，若想知道模板版本的元数据，请调用ShowTemplateVersionMetadata
         
         Please refer to HUAWEI cloud API Explorer for details.
 
 
@@ -1894,15 +1909,15 @@
     def show_template_version_metadata_async(self, request):
         """获取模板版本元数据
 
         获取模板版本元数据（ShowTemplateVersionMetadata）
         
         此API用于展示某一版本模板的元数据
         
-          * 若template_name和template_id同时存在，则模板服务会检查是否两个匹配，否则返回400
+          * tempate_id是模板的唯一Id。此Id由资源编排服务在生成模板的时候生成，为UUID。由于模板名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的模板，删除，再重新创建一个同名模板。对于团队并行开发，用户可能希望确保，当前我操作的模板就是我认为的那个，而不是其他队友删除后创建的同名模板。因此，使用ID就可以做到强匹配。资源编排服务保证每次创建的模板所对应的ID都不相同，更新不会影响ID。如果给与的template_id和当前模板管理的ID不一致，则返回400
         
         ShowTemplateVersionMetadata返回的信息只包含模板版本元数据信息（具体摘要信息见ShowTemplateVersionMetadataResponseBody），若用户需要了解模板版本内容，请调用ShowTemplateVersionContent
         
         Please refer to HUAWEI cloud API Explorer for details.
 
 
         :param request: Request instance for ShowTemplateVersionMetadata
```

## huaweicloudsdkaos/v1/aos_client.py

```diff
@@ -987,21 +987,36 @@
             request_type=request.__class__.__name__)
 
     def get_stack_template(self, request):
         """获取资源栈模板
 
         获取资源栈模板（GetStackTemplate）
         
-        此API用于获取资源栈最近的一次部署使用的模板。
+        此API用于获取资源栈最近一次部署终态使用的模板。
+        
+        注：
+        当资源栈状态处于非终态（即以&#x60;IN_PROGRESS&#x60;结尾，详细见下方）状态时，资源栈处于转变阶段，此API获取资源栈上一次部署使用的模板。
+        只有当资源栈状态处于终态（即以&#x60;COMPLETE&#x60;或&#x60;FAILED&#x60;结尾，详细见下方）时，此API获取当前最新一次部署使用的模板。CREATION_COMPLETE除外，此时资源栈没有模板，返回404，并提示模板不存在
+        
+        非终态状态包括但不限于以下状态：
+          * 正在部署（DEPLOYMENT_IN_PROGRESS）
+          * 正在回滚（ROLLBACK_IN_PROGRESS）
+          * 正在删除（DELETION_IN_PROGRESS）
+        
+        终态状态包括但不限于以下状态：
+          * 生成空资源栈完成（CREATION_COMPLETE）
+          * 部署失败（DEPLOYMENT_FAILED）
+          * 部署完成（DEPLOYMENT_COMPLETE）
+          * 回滚失败（ROLLBACK_FAILED）
+          * 回滚完成（ROLLBACK_COMPLETE）
+          * 删除失败（DELETION_FAILED）
         
         如果获取成功，则以临时重定向形式返回模板下载链接（OBS Pre Signed地址，有效期为5分钟），大多数的客户端会进行自动重定向并下载模板；
         若未进行自动重定向，请参考HTTP的重定向规则获取模板下载链接，手动下载模板。
         
-        若资源栈当前没有模板，则返回404，并提示模板不存在
-        
         Please refer to HUAWEI cloud API Explorer for details.
 
         :param request: Request instance for GetStackTemplate
         :type request: :class:`huaweicloudsdkaos.v1.GetStackTemplateRequest`
         :rtype: :class:`huaweicloudsdkaos.v1.GetStackTemplateResponse`
         """
         return self._get_stack_template_with_http_info(request)
@@ -1465,15 +1480,15 @@
         """删除模板
 
         删除模板（DeleteTemplate）
         
         此API用于删除某个模板以及模板下的全部模板版本
         **请谨慎操作，删除模板将会删除模板下的所有模板版本。**
         
-          * 若template_name和template_id同时存在，则模板服务会检查是否两个匹配
+          * tempate_id是模板的唯一Id。此Id由资源编排服务在生成模板的时候生成，为UUID。由于模板名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的模板，删除，再重新创建一个同名模板。对于团队并行开发，用户可能希望确保，当前我操作的模板就是我认为的那个，而不是其他队友删除后创建的同名模板。因此，使用ID就可以做到强匹配。资源编排服务保证每次创建的模板所对应的ID都不相同，更新不会影响ID。如果给与的template_id和当前模板管理的ID不一致，则返回400
         
         Please refer to HUAWEI cloud API Explorer for details.
 
         :param request: Request instance for DeleteTemplate
         :type request: :class:`huaweicloudsdkaos.v1.DeleteTemplateRequest`
         :rtype: :class:`huaweicloudsdkaos.v1.DeleteTemplateResponse`
         """
@@ -1529,15 +1544,15 @@
     def delete_template_version(self, request):
         """删除模板版本
 
         删除模板版本（DeleteTemplateVersion）
         
         此API用于删除某个模板版本
         
-          * 若template_name和template_id同时存在，则模板服务会检查是否两个匹配，否则返回400
+          * tempate_id是模板的唯一Id。此Id由资源编排服务在生成模板的时候生成，为UUID。由于模板名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的模板，删除，再重新创建一个同名模板。对于团队并行开发，用户可能希望确保，当前我操作的模板就是我认为的那个，而不是其他队友删除后创建的同名模板。因此，使用ID就可以做到强匹配。资源编排服务保证每次创建的模板所对应的ID都不相同，更新不会影响ID。如果给与的template_id和当前模板管理的ID不一致，则返回400
           * 若模板下只存在唯一模板版本，此模板版本将无法被删除，如果需要删除此模板版本，请调用DeleteTemplate。模板服务不允许存在没有模板版本的模板
         
         **请谨慎操作**
         
         Please refer to HUAWEI cloud API Explorer for details.
 
         :param request: Request instance for DeleteTemplateVersion
@@ -1601,15 +1616,15 @@
         列举模板版本信息（ListTemplateVersions）
         
         此API用于列举模板下所有的模板版本信息
         
           * 默认按照生成时间排序，最早生成的模板排列在最前面
           * 注意：目前返回全量模板版本信息，即不支持分页
           * 如果没有任何模板版本，则返回空list
-          * 若template_name和template_id同时存在，则模板服务会检查是否两个匹配
+          * tempate_id是模板的唯一Id。此Id由资源编排服务在生成模板的时候生成，为UUID。由于模板名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的模板，删除，再重新创建一个同名模板。对于团队并行开发，用户可能希望确保，当前我操作的模板就是我认为的那个，而不是其他队友删除后创建的同名模板。因此，使用ID就可以做到强匹配。资源编排服务保证每次创建的模板所对应的ID都不相同，更新不会影响ID。如果给与的template_id和当前模板管理的ID不一致，则返回400
           * 若模板不存在则返回404
         
         ListTemplateVersions返回的信息只包含模板版本摘要信息（具体摘要信息见ListTemplateVersionsResponseBody），若用户需要了解模板版本内容，请调用ShowTemplateVersionContent
         
         Please refer to HUAWEI cloud API Explorer for details.
 
         :param request: Request instance for ListTemplateVersions
@@ -1735,15 +1750,15 @@
 
         获取模板元数据（ShowTemplateMetadata）
         
         此API用于获取当前模板的元数据信息
         
         具体信息见ShowTemplateMetadataResponseBody，若想查看模板下全部模板版本，请调用ListTemplateVersions。
         
-          * 若template_name和template_id同时存在，则模板服务会检查是否两个匹配
+          * tempate_id是模板的唯一Id。此Id由资源编排服务在生成模板的时候生成，为UUID。由于模板名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的模板，删除，再重新创建一个同名模板。对于团队并行开发，用户可能希望确保，当前我操作的模板就是我认为的那个，而不是其他队友删除后创建的同名模板。因此，使用ID就可以做到强匹配。资源编排服务保证每次创建的模板所对应的ID都不相同，更新不会影响ID。如果给与的template_id和当前模板管理的ID不一致，则返回400
         
         Please refer to HUAWEI cloud API Explorer for details.
 
         :param request: Request instance for ShowTemplateMetadata
         :type request: :class:`huaweicloudsdkaos.v1.ShowTemplateMetadataRequest`
         :rtype: :class:`huaweicloudsdkaos.v1.ShowTemplateMetadataResponse`
         """
@@ -1799,15 +1814,15 @@
     def show_template_version_content(self, request):
         """获取模板版本内容
 
         获取模板版本内容（ShowTemplateVersionContent）
         
         此API用于获取用户的模板版本内容
         
-          * 若template_name和template_id同时存在，则模板服务会检查是否两个匹配，否则返回400
+          * tempate_id是模板的唯一Id。此Id由资源编排服务在生成模板的时候生成，为UUID。由于模板名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的模板，删除，再重新创建一个同名模板。对于团队并行开发，用户可能希望确保，当前我操作的模板就是我认为的那个，而不是其他队友删除后创建的同名模板。因此，使用ID就可以做到强匹配。资源编排服务保证每次创建的模板所对应的ID都不相同，更新不会影响ID。如果给与的template_id和当前模板管理的ID不一致，则返回400
           * 此api会以临时重定向形式返回模板内容的下载链接，用户通过下载获取模板版本内容（OBS Pre Signed地址，有效期为5分钟）
         
         ShowTemplateVersionContent返回的信息只包含模板版本内容，若想知道模板版本的元数据，请调用ShowTemplateVersionMetadata
         
         Please refer to HUAWEI cloud API Explorer for details.
 
         :param request: Request instance for ShowTemplateVersionContent
@@ -1868,15 +1883,15 @@
     def show_template_version_metadata(self, request):
         """获取模板版本元数据
 
         获取模板版本元数据（ShowTemplateVersionMetadata）
         
         此API用于展示某一版本模板的元数据
         
-          * 若template_name和template_id同时存在，则模板服务会检查是否两个匹配，否则返回400
+          * tempate_id是模板的唯一Id。此Id由资源编排服务在生成模板的时候生成，为UUID。由于模板名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的模板，删除，再重新创建一个同名模板。对于团队并行开发，用户可能希望确保，当前我操作的模板就是我认为的那个，而不是其他队友删除后创建的同名模板。因此，使用ID就可以做到强匹配。资源编排服务保证每次创建的模板所对应的ID都不相同，更新不会影响ID。如果给与的template_id和当前模板管理的ID不一致，则返回400
         
         ShowTemplateVersionMetadata返回的信息只包含模板版本元数据信息（具体摘要信息见ShowTemplateVersionMetadataResponseBody），若用户需要了解模板版本内容，请调用ShowTemplateVersionContent
         
         Please refer to HUAWEI cloud API Explorer for details.
 
         :param request: Request instance for ShowTemplateVersionMetadata
         :type request: :class:`huaweicloudsdkaos.v1.ShowTemplateVersionMetadataRequest`
```

## huaweicloudsdkaos/v1/model/agencies_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, agencies=None):
         """AgenciesPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param agencies: 委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。 
+        :param agencies: 委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。
         :type agencies: list[:class:`huaweicloudsdkaos.v1.Agency`]
         """
         
         
 
         self._agencies = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if agencies is not None:
             self.agencies = agencies
 
     @property
     def agencies(self):
         """Gets the agencies of this AgenciesPrimitiveTypeHolder.
 
-        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。 
+        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。
 
         :return: The agencies of this AgenciesPrimitiveTypeHolder.
         :rtype: list[:class:`huaweicloudsdkaos.v1.Agency`]
         """
         return self._agencies
 
     @agencies.setter
     def agencies(self, agencies):
         """Sets the agencies of this AgenciesPrimitiveTypeHolder.
 
-        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。 
+        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。
 
         :param agencies: The agencies of this AgenciesPrimitiveTypeHolder.
         :type agencies: list[:class:`huaweicloudsdkaos.v1.Agency`]
         """
         self._agencies = agencies
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/apply_execution_plan_request_body.py

```diff
@@ -27,17 +27,17 @@
     }
 
     def __init__(self, execution_plan_id=None, stack_id=None):
         """ApplyExecutionPlanRequestBody
 
         The model defined in huaweicloud sdk
 
-        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
         :type execution_plan_id: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         """
         
         
 
         self._execution_plan_id = None
         self._stack_id = None
@@ -48,48 +48,48 @@
         if stack_id is not None:
             self.stack_id = stack_id
 
     @property
     def execution_plan_id(self):
         """Gets the execution_plan_id of this ApplyExecutionPlanRequestBody.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :return: The execution_plan_id of this ApplyExecutionPlanRequestBody.
         :rtype: str
         """
         return self._execution_plan_id
 
     @execution_plan_id.setter
     def execution_plan_id(self, execution_plan_id):
         """Sets the execution_plan_id of this ApplyExecutionPlanRequestBody.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :param execution_plan_id: The execution_plan_id of this ApplyExecutionPlanRequestBody.
         :type execution_plan_id: str
         """
         self._execution_plan_id = execution_plan_id
 
     @property
     def stack_id(self):
         """Gets the stack_id of this ApplyExecutionPlanRequestBody.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this ApplyExecutionPlanRequestBody.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this ApplyExecutionPlanRequestBody.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this ApplyExecutionPlanRequestBody.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/apply_execution_plan_response.py

```diff
@@ -26,15 +26,15 @@
     }
 
     def __init__(self, deployment_id=None):
         """ApplyExecutionPlanResponse
 
         The model defined in huaweicloud sdk
 
-        :param deployment_id: 标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。 
+        :param deployment_id: 标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。
         :type deployment_id: str
         """
         
         super(ApplyExecutionPlanResponse, self).__init__()
 
         self._deployment_id = None
         self.discriminator = None
@@ -42,26 +42,26 @@
         if deployment_id is not None:
             self.deployment_id = deployment_id
 
     @property
     def deployment_id(self):
         """Gets the deployment_id of this ApplyExecutionPlanResponse.
 
-        标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。 
+        标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。
 
         :return: The deployment_id of this ApplyExecutionPlanResponse.
         :rtype: str
         """
         return self._deployment_id
 
     @deployment_id.setter
     def deployment_id(self, deployment_id):
         """Sets the deployment_id of this ApplyExecutionPlanResponse.
 
-        标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。 
+        标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。
 
         :param deployment_id: The deployment_id of this ApplyExecutionPlanResponse.
         :type deployment_id: str
         """
         self._deployment_id = deployment_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/continue_deploy_stack_request_body.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, stack_id=None):
         """ContinueDeployStackRequestBody
 
         The model defined in huaweicloud sdk
 
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         """
         
         
 
         self._stack_id = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if stack_id is not None:
             self.stack_id = stack_id
 
     @property
     def stack_id(self):
         """Gets the stack_id of this ContinueDeployStackRequestBody.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this ContinueDeployStackRequestBody.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this ContinueDeployStackRequestBody.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this ContinueDeployStackRequestBody.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/continue_rollback_stack_request_body.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, stack_id=None):
         """ContinueRollbackStackRequestBody
 
         The model defined in huaweicloud sdk
 
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         """
         
         
 
         self._stack_id = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if stack_id is not None:
             self.stack_id = stack_id
 
     @property
     def stack_id(self):
         """Gets the stack_id of this ContinueRollbackStackRequestBody.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this ContinueRollbackStackRequestBody.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this ContinueRollbackStackRequestBody.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this ContinueRollbackStackRequestBody.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/create_execution_plan_request_body.py

```diff
@@ -39,29 +39,29 @@
     }
 
     def __init__(self, stack_id=None, template_body=None, template_uri=None, execution_plan_name=None, description=None, vars_structure=None, vars_body=None, vars_uri=None):
         """CreateExecutionPlanRequestBody
 
         The model defined in huaweicloud sdk
 
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
-        :param template_body: HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        :param template_body: HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
         :type template_body: str
-        :param template_uri: HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以&#x60;.tf&#x60;或者&#x60;.tf.json&#x60;结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以&#x60;.zip&#x60;结尾。解压后的文件不得包含\&quot;.tfvars\&quot;文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        :param template_uri: HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以&#x60;.tf&#x60;或者&#x60;.tf.json&#x60;结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以&#x60;.zip&#x60;结尾。解压后的文件不得包含\&quot;.tfvars\&quot;文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
         :type template_uri: str
         :param execution_plan_name: 执行计划的名称。此名字在domain_id+区域+project_id+stack_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type execution_plan_name: str
         :param description: 执行计划的描述。可用于客户识别自己的执行计划。
         :type description: str
-        :param vars_structure: HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        :param vars_structure: HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
         :type vars_structure: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
-        :param vars_body: HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        :param vars_body: HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
         :type vars_body: str
-        :param vars_uri: HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        :param vars_uri: HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
         :type vars_uri: str
         """
         
         
 
         self._stack_id = None
         self._template_body = None
@@ -89,70 +89,70 @@
         if vars_uri is not None:
             self.vars_uri = vars_uri
 
     @property
     def stack_id(self):
         """Gets the stack_id of this CreateExecutionPlanRequestBody.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this CreateExecutionPlanRequestBody.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this CreateExecutionPlanRequestBody.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this CreateExecutionPlanRequestBody.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     @property
     def template_body(self):
         """Gets the template_body of this CreateExecutionPlanRequestBody.
 
-        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
 
         :return: The template_body of this CreateExecutionPlanRequestBody.
         :rtype: str
         """
         return self._template_body
 
     @template_body.setter
     def template_body(self, template_body):
         """Sets the template_body of this CreateExecutionPlanRequestBody.
 
-        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
 
         :param template_body: The template_body of this CreateExecutionPlanRequestBody.
         :type template_body: str
         """
         self._template_body = template_body
 
     @property
     def template_uri(self):
         """Gets the template_uri of this CreateExecutionPlanRequestBody.
 
-        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
 
         :return: The template_uri of this CreateExecutionPlanRequestBody.
         :rtype: str
         """
         return self._template_uri
 
     @template_uri.setter
     def template_uri(self, template_uri):
         """Sets the template_uri of this CreateExecutionPlanRequestBody.
 
-        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
 
         :param template_uri: The template_uri of this CreateExecutionPlanRequestBody.
         :type template_uri: str
         """
         self._template_uri = template_uri
 
     @property
@@ -199,70 +199,70 @@
         """
         self._description = description
 
     @property
     def vars_structure(self):
         """Gets the vars_structure of this CreateExecutionPlanRequestBody.
 
-        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
 
         :return: The vars_structure of this CreateExecutionPlanRequestBody.
         :rtype: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         return self._vars_structure
 
     @vars_structure.setter
     def vars_structure(self, vars_structure):
         """Sets the vars_structure of this CreateExecutionPlanRequestBody.
 
-        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
 
         :param vars_structure: The vars_structure of this CreateExecutionPlanRequestBody.
         :type vars_structure: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         self._vars_structure = vars_structure
 
     @property
     def vars_body(self):
         """Gets the vars_body of this CreateExecutionPlanRequestBody.
 
-        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :return: The vars_body of this CreateExecutionPlanRequestBody.
         :rtype: str
         """
         return self._vars_body
 
     @vars_body.setter
     def vars_body(self, vars_body):
         """Sets the vars_body of this CreateExecutionPlanRequestBody.
 
-        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :param vars_body: The vars_body of this CreateExecutionPlanRequestBody.
         :type vars_body: str
         """
         self._vars_body = vars_body
 
     @property
     def vars_uri(self):
         """Gets the vars_uri of this CreateExecutionPlanRequestBody.
 
-        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :return: The vars_uri of this CreateExecutionPlanRequestBody.
         :rtype: str
         """
         return self._vars_uri
 
     @vars_uri.setter
     def vars_uri(self, vars_uri):
         """Sets the vars_uri of this CreateExecutionPlanRequestBody.
 
-        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :param vars_uri: The vars_uri of this CreateExecutionPlanRequestBody.
         :type vars_uri: str
         """
         self._vars_uri = vars_uri
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/create_execution_plan_response.py

```diff
@@ -26,15 +26,15 @@
     }
 
     def __init__(self, execution_plan_id=None):
         """CreateExecutionPlanResponse
 
         The model defined in huaweicloud sdk
 
-        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
         :type execution_plan_id: str
         """
         
         super(CreateExecutionPlanResponse, self).__init__()
 
         self._execution_plan_id = None
         self.discriminator = None
@@ -42,26 +42,26 @@
         if execution_plan_id is not None:
             self.execution_plan_id = execution_plan_id
 
     @property
     def execution_plan_id(self):
         """Gets the execution_plan_id of this CreateExecutionPlanResponse.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :return: The execution_plan_id of this CreateExecutionPlanResponse.
         :rtype: str
         """
         return self._execution_plan_id
 
     @execution_plan_id.setter
     def execution_plan_id(self, execution_plan_id):
         """Sets the execution_plan_id of this CreateExecutionPlanResponse.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :param execution_plan_id: The execution_plan_id of this CreateExecutionPlanResponse.
         :type execution_plan_id: str
         """
         self._execution_plan_id = execution_plan_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/create_stack_request_body.py

```diff
@@ -45,31 +45,31 @@
     def __init__(self, stack_name=None, agencies=None, description=None, enable_deletion_protection=None, enable_auto_rollback=None, template_body=None, template_uri=None, vars_body=None, vars_structure=None, vars_uri=None):
         """CreateStackRequestBody
 
         The model defined in huaweicloud sdk
 
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
-        :param agencies: 委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。 
+        :param agencies: 委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。
         :type agencies: list[:class:`huaweicloudsdkaos.v1.Agency`]
         :param description: 资源栈的描述。可用于客户识别自己的资源栈。
         :type description: str
-        :param enable_deletion_protection: 删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新* 
+        :param enable_deletion_protection: 删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新*
         :type enable_deletion_protection: bool
-        :param enable_auto_rollback: 自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新* 
+        :param enable_auto_rollback: 自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新*
         :type enable_auto_rollback: bool
-        :param template_body: HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        :param template_body: HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
         :type template_body: str
-        :param template_uri: HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以&#x60;.tf&#x60;或者&#x60;.tf.json&#x60;结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以&#x60;.zip&#x60;结尾。解压后的文件不得包含\&quot;.tfvars\&quot;文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        :param template_uri: HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以&#x60;.tf&#x60;或者&#x60;.tf.json&#x60;结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以&#x60;.zip&#x60;结尾。解压后的文件不得包含\&quot;.tfvars\&quot;文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
         :type template_uri: str
-        :param vars_body: HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        :param vars_body: HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
         :type vars_body: str
-        :param vars_structure: HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        :param vars_structure: HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
         :type vars_structure: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
-        :param vars_uri: HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        :param vars_uri: HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
         :type vars_uri: str
         """
         
         
 
         self._stack_name = None
         self._agencies = None
@@ -125,26 +125,26 @@
         """
         self._stack_name = stack_name
 
     @property
     def agencies(self):
         """Gets the agencies of this CreateStackRequestBody.
 
-        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。 
+        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。
 
         :return: The agencies of this CreateStackRequestBody.
         :rtype: list[:class:`huaweicloudsdkaos.v1.Agency`]
         """
         return self._agencies
 
     @agencies.setter
     def agencies(self, agencies):
         """Sets the agencies of this CreateStackRequestBody.
 
-        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。 
+        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。
 
         :param agencies: The agencies of this CreateStackRequestBody.
         :type agencies: list[:class:`huaweicloudsdkaos.v1.Agency`]
         """
         self._agencies = agencies
 
     @property
@@ -169,158 +169,158 @@
         """
         self._description = description
 
     @property
     def enable_deletion_protection(self):
         """Gets the enable_deletion_protection of this CreateStackRequestBody.
 
-        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新* 
+        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新*
 
         :return: The enable_deletion_protection of this CreateStackRequestBody.
         :rtype: bool
         """
         return self._enable_deletion_protection
 
     @enable_deletion_protection.setter
     def enable_deletion_protection(self, enable_deletion_protection):
         """Sets the enable_deletion_protection of this CreateStackRequestBody.
 
-        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新* 
+        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新*
 
         :param enable_deletion_protection: The enable_deletion_protection of this CreateStackRequestBody.
         :type enable_deletion_protection: bool
         """
         self._enable_deletion_protection = enable_deletion_protection
 
     @property
     def enable_auto_rollback(self):
         """Gets the enable_auto_rollback of this CreateStackRequestBody.
 
-        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新* 
+        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新*
 
         :return: The enable_auto_rollback of this CreateStackRequestBody.
         :rtype: bool
         """
         return self._enable_auto_rollback
 
     @enable_auto_rollback.setter
     def enable_auto_rollback(self, enable_auto_rollback):
         """Sets the enable_auto_rollback of this CreateStackRequestBody.
 
-        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新* 
+        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新*
 
         :param enable_auto_rollback: The enable_auto_rollback of this CreateStackRequestBody.
         :type enable_auto_rollback: bool
         """
         self._enable_auto_rollback = enable_auto_rollback
 
     @property
     def template_body(self):
         """Gets the template_body of this CreateStackRequestBody.
 
-        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
 
         :return: The template_body of this CreateStackRequestBody.
         :rtype: str
         """
         return self._template_body
 
     @template_body.setter
     def template_body(self, template_body):
         """Sets the template_body of this CreateStackRequestBody.
 
-        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
 
         :param template_body: The template_body of this CreateStackRequestBody.
         :type template_body: str
         """
         self._template_body = template_body
 
     @property
     def template_uri(self):
         """Gets the template_uri of this CreateStackRequestBody.
 
-        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
 
         :return: The template_uri of this CreateStackRequestBody.
         :rtype: str
         """
         return self._template_uri
 
     @template_uri.setter
     def template_uri(self, template_uri):
         """Sets the template_uri of this CreateStackRequestBody.
 
-        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
 
         :param template_uri: The template_uri of this CreateStackRequestBody.
         :type template_uri: str
         """
         self._template_uri = template_uri
 
     @property
     def vars_body(self):
         """Gets the vars_body of this CreateStackRequestBody.
 
-        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :return: The vars_body of this CreateStackRequestBody.
         :rtype: str
         """
         return self._vars_body
 
     @vars_body.setter
     def vars_body(self, vars_body):
         """Sets the vars_body of this CreateStackRequestBody.
 
-        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :param vars_body: The vars_body of this CreateStackRequestBody.
         :type vars_body: str
         """
         self._vars_body = vars_body
 
     @property
     def vars_structure(self):
         """Gets the vars_structure of this CreateStackRequestBody.
 
-        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
 
         :return: The vars_structure of this CreateStackRequestBody.
         :rtype: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         return self._vars_structure
 
     @vars_structure.setter
     def vars_structure(self, vars_structure):
         """Sets the vars_structure of this CreateStackRequestBody.
 
-        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
 
         :param vars_structure: The vars_structure of this CreateStackRequestBody.
         :type vars_structure: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         self._vars_structure = vars_structure
 
     @property
     def vars_uri(self):
         """Gets the vars_uri of this CreateStackRequestBody.
 
-        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :return: The vars_uri of this CreateStackRequestBody.
         :rtype: str
         """
         return self._vars_uri
 
     @vars_uri.setter
     def vars_uri(self, vars_uri):
         """Sets the vars_uri of this CreateStackRequestBody.
 
-        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :param vars_uri: The vars_uri of this CreateStackRequestBody.
         :type vars_uri: str
         """
         self._vars_uri = vars_uri
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/create_stack_response.py

```diff
@@ -28,15 +28,15 @@
     }
 
     def __init__(self, stack_id=None, deployment_id=None):
         """CreateStackResponse
 
         The model defined in huaweicloud sdk
 
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         :param deployment_id: 部署ID
         :type deployment_id: str
         """
         
         super(CreateStackResponse, self).__init__()
 
@@ -49,26 +49,26 @@
         if deployment_id is not None:
             self.deployment_id = deployment_id
 
     @property
     def stack_id(self):
         """Gets the stack_id of this CreateStackResponse.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this CreateStackResponse.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this CreateStackResponse.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this CreateStackResponse.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     @property
```

## huaweicloudsdkaos/v1/model/delete_execution_plan_request.py

```diff
@@ -39,17 +39,17 @@
 
         :param client_request_id: 用户指定的，对于此请求的唯一ID，用于定位某个请求，推荐使用UUID
         :type client_request_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
         :param execution_plan_name: 执行计划的名称。此名字在domain_id+区域+project_id+stack_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type execution_plan_name: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
-        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
         :type execution_plan_id: str
         """
         
         
 
         self._client_request_id = None
         self._stack_name = None
@@ -132,48 +132,48 @@
         """
         self._execution_plan_name = execution_plan_name
 
     @property
     def stack_id(self):
         """Gets the stack_id of this DeleteExecutionPlanRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this DeleteExecutionPlanRequest.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this DeleteExecutionPlanRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this DeleteExecutionPlanRequest.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     @property
     def execution_plan_id(self):
         """Gets the execution_plan_id of this DeleteExecutionPlanRequest.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :return: The execution_plan_id of this DeleteExecutionPlanRequest.
         :rtype: str
         """
         return self._execution_plan_id
 
     @execution_plan_id.setter
     def execution_plan_id(self, execution_plan_id):
         """Sets the execution_plan_id of this DeleteExecutionPlanRequest.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :param execution_plan_id: The execution_plan_id of this DeleteExecutionPlanRequest.
         :type execution_plan_id: str
         """
         self._execution_plan_id = execution_plan_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/delete_stack_request.py

```diff
@@ -33,15 +33,15 @@
 
         The model defined in huaweicloud sdk
 
         :param client_request_id: 用户指定的，对于此请求的唯一ID，用于定位某个请求，推荐使用UUID
         :type client_request_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         """
         
         
 
         self._client_request_id = None
         self._stack_name = None
@@ -97,26 +97,26 @@
         """
         self._stack_name = stack_name
 
     @property
     def stack_id(self):
         """Gets the stack_id of this DeleteStackRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this DeleteStackRequest.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this DeleteStackRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this DeleteStackRequest.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/deploy_stack_request_body.py

```diff
@@ -35,25 +35,25 @@
     }
 
     def __init__(self, template_body=None, template_uri=None, vars_structure=None, vars_body=None, vars_uri=None, stack_id=None):
         """DeployStackRequestBody
 
         The model defined in huaweicloud sdk
 
-        :param template_body: HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        :param template_body: HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
         :type template_body: str
-        :param template_uri: HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以&#x60;.tf&#x60;或者&#x60;.tf.json&#x60;结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以&#x60;.zip&#x60;结尾。解压后的文件不得包含\&quot;.tfvars\&quot;文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        :param template_uri: HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以&#x60;.tf&#x60;或者&#x60;.tf.json&#x60;结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以&#x60;.zip&#x60;结尾。解压后的文件不得包含\&quot;.tfvars\&quot;文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
         :type template_uri: str
-        :param vars_structure: HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        :param vars_structure: HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
         :type vars_structure: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
-        :param vars_body: HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        :param vars_body: HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
         :type vars_body: str
-        :param vars_uri: HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        :param vars_uri: HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
         :type vars_uri: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         """
         
         
 
         self._template_body = None
         self._template_uri = None
@@ -76,136 +76,136 @@
         if stack_id is not None:
             self.stack_id = stack_id
 
     @property
     def template_body(self):
         """Gets the template_body of this DeployStackRequestBody.
 
-        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
 
         :return: The template_body of this DeployStackRequestBody.
         :rtype: str
         """
         return self._template_body
 
     @template_body.setter
     def template_body(self, template_body):
         """Sets the template_body of this DeployStackRequestBody.
 
-        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
 
         :param template_body: The template_body of this DeployStackRequestBody.
         :type template_body: str
         """
         self._template_body = template_body
 
     @property
     def template_uri(self):
         """Gets the template_uri of this DeployStackRequestBody.
 
-        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
 
         :return: The template_uri of this DeployStackRequestBody.
         :rtype: str
         """
         return self._template_uri
 
     @template_uri.setter
     def template_uri(self, template_uri):
         """Sets the template_uri of this DeployStackRequestBody.
 
-        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
 
         :param template_uri: The template_uri of this DeployStackRequestBody.
         :type template_uri: str
         """
         self._template_uri = template_uri
 
     @property
     def vars_structure(self):
         """Gets the vars_structure of this DeployStackRequestBody.
 
-        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
 
         :return: The vars_structure of this DeployStackRequestBody.
         :rtype: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         return self._vars_structure
 
     @vars_structure.setter
     def vars_structure(self, vars_structure):
         """Sets the vars_structure of this DeployStackRequestBody.
 
-        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
 
         :param vars_structure: The vars_structure of this DeployStackRequestBody.
         :type vars_structure: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         self._vars_structure = vars_structure
 
     @property
     def vars_body(self):
         """Gets the vars_body of this DeployStackRequestBody.
 
-        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :return: The vars_body of this DeployStackRequestBody.
         :rtype: str
         """
         return self._vars_body
 
     @vars_body.setter
     def vars_body(self, vars_body):
         """Sets the vars_body of this DeployStackRequestBody.
 
-        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :param vars_body: The vars_body of this DeployStackRequestBody.
         :type vars_body: str
         """
         self._vars_body = vars_body
 
     @property
     def vars_uri(self):
         """Gets the vars_uri of this DeployStackRequestBody.
 
-        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :return: The vars_uri of this DeployStackRequestBody.
         :rtype: str
         """
         return self._vars_uri
 
     @vars_uri.setter
     def vars_uri(self, vars_uri):
         """Sets the vars_uri of this DeployStackRequestBody.
 
-        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :param vars_uri: The vars_uri of this DeployStackRequestBody.
         :type vars_uri: str
         """
         self._vars_uri = vars_uri
 
     @property
     def stack_id(self):
         """Gets the stack_id of this DeployStackRequestBody.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this DeployStackRequestBody.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this DeployStackRequestBody.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this DeployStackRequestBody.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/deployment_id_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, deployment_id=None):
         """DeploymentIdPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param deployment_id: 标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。 
+        :param deployment_id: 标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。
         :type deployment_id: str
         """
         
         
 
         self._deployment_id = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if deployment_id is not None:
             self.deployment_id = deployment_id
 
     @property
     def deployment_id(self):
         """Gets the deployment_id of this DeploymentIdPrimitiveTypeHolder.
 
-        标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。 
+        标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。
 
         :return: The deployment_id of this DeploymentIdPrimitiveTypeHolder.
         :rtype: str
         """
         return self._deployment_id
 
     @deployment_id.setter
     def deployment_id(self, deployment_id):
         """Sets the deployment_id of this DeploymentIdPrimitiveTypeHolder.
 
-        标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。 
+        标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。
 
         :param deployment_id: The deployment_id of this DeploymentIdPrimitiveTypeHolder.
         :type deployment_id: str
         """
         self._deployment_id = deployment_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/enable_auto_rollback_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, enable_auto_rollback=None):
         """EnableAutoRollbackPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param enable_auto_rollback: 自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新* 
+        :param enable_auto_rollback: 自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新*
         :type enable_auto_rollback: bool
         """
         
         
 
         self._enable_auto_rollback = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if enable_auto_rollback is not None:
             self.enable_auto_rollback = enable_auto_rollback
 
     @property
     def enable_auto_rollback(self):
         """Gets the enable_auto_rollback of this EnableAutoRollbackPrimitiveTypeHolder.
 
-        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新* 
+        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新*
 
         :return: The enable_auto_rollback of this EnableAutoRollbackPrimitiveTypeHolder.
         :rtype: bool
         """
         return self._enable_auto_rollback
 
     @enable_auto_rollback.setter
     def enable_auto_rollback(self, enable_auto_rollback):
         """Sets the enable_auto_rollback of this EnableAutoRollbackPrimitiveTypeHolder.
 
-        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新* 
+        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新*
 
         :param enable_auto_rollback: The enable_auto_rollback of this EnableAutoRollbackPrimitiveTypeHolder.
         :type enable_auto_rollback: bool
         """
         self._enable_auto_rollback = enable_auto_rollback
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/enable_deletion_protection_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, enable_deletion_protection=None):
         """EnableDeletionProtectionPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param enable_deletion_protection: 删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新* 
+        :param enable_deletion_protection: 删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新*
         :type enable_deletion_protection: bool
         """
         
         
 
         self._enable_deletion_protection = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if enable_deletion_protection is not None:
             self.enable_deletion_protection = enable_deletion_protection
 
     @property
     def enable_deletion_protection(self):
         """Gets the enable_deletion_protection of this EnableDeletionProtectionPrimitiveTypeHolder.
 
-        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新* 
+        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新*
 
         :return: The enable_deletion_protection of this EnableDeletionProtectionPrimitiveTypeHolder.
         :rtype: bool
         """
         return self._enable_deletion_protection
 
     @enable_deletion_protection.setter
     def enable_deletion_protection(self, enable_deletion_protection):
         """Sets the enable_deletion_protection of this EnableDeletionProtectionPrimitiveTypeHolder.
 
-        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新* 
+        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新*
 
         :param enable_deletion_protection: The enable_deletion_protection of this EnableDeletionProtectionPrimitiveTypeHolder.
         :type enable_deletion_protection: bool
         """
         self._enable_deletion_protection = enable_deletion_protection
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/estimate_execution_plan_price_request.py

```diff
@@ -39,17 +39,17 @@
 
         :param client_request_id: 用户指定的，对于此请求的唯一ID，用于定位某个请求，推荐使用UUID
         :type client_request_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
         :param execution_plan_name: 执行计划的名称。此名字在domain_id+区域+project_id+stack_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type execution_plan_name: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
-        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
         :type execution_plan_id: str
         """
         
         
 
         self._client_request_id = None
         self._stack_name = None
@@ -132,48 +132,48 @@
         """
         self._execution_plan_name = execution_plan_name
 
     @property
     def stack_id(self):
         """Gets the stack_id of this EstimateExecutionPlanPriceRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this EstimateExecutionPlanPriceRequest.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this EstimateExecutionPlanPriceRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this EstimateExecutionPlanPriceRequest.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     @property
     def execution_plan_id(self):
         """Gets the execution_plan_id of this EstimateExecutionPlanPriceRequest.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :return: The execution_plan_id of this EstimateExecutionPlanPriceRequest.
         :rtype: str
         """
         return self._execution_plan_id
 
     @execution_plan_id.setter
     def execution_plan_id(self, execution_plan_id):
         """Sets the execution_plan_id of this EstimateExecutionPlanPriceRequest.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :param execution_plan_id: The execution_plan_id of this EstimateExecutionPlanPriceRequest.
         :type execution_plan_id: str
         """
         self._execution_plan_id = execution_plan_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/estimate_execution_plan_price_response.py

```diff
@@ -28,15 +28,15 @@
     }
 
     def __init__(self, currency=None, items=None):
         """EstimateExecutionPlanPriceResponse
 
         The model defined in huaweicloud sdk
 
-        :param currency: 币种，枚举值   * &#x60;CNY&#x60; - 元，中国站返回的币种   * &#x60;USD&#x60; - 美元，国际站返回的币种 
+        :param currency: 币种，枚举值   * &#x60;CNY&#x60; - 元，中国站返回的币种   * &#x60;USD&#x60; - 美元，国际站返回的币种
         :type currency: str
         :param items: 执行计划中所有资源的询价结果
         :type items: list[:class:`huaweicloudsdkaos.v1.ItemsResponse`]
         """
         
         super(EstimateExecutionPlanPriceResponse, self).__init__()
 
@@ -49,26 +49,26 @@
         if items is not None:
             self.items = items
 
     @property
     def currency(self):
         """Gets the currency of this EstimateExecutionPlanPriceResponse.
 
-        币种，枚举值   * `CNY` - 元，中国站返回的币种   * `USD` - 美元，国际站返回的币种 
+        币种，枚举值   * `CNY` - 元，中国站返回的币种   * `USD` - 美元，国际站返回的币种
 
         :return: The currency of this EstimateExecutionPlanPriceResponse.
         :rtype: str
         """
         return self._currency
 
     @currency.setter
     def currency(self, currency):
         """Sets the currency of this EstimateExecutionPlanPriceResponse.
 
-        币种，枚举值   * `CNY` - 元，中国站返回的币种   * `USD` - 美元，国际站返回的币种 
+        币种，枚举值   * `CNY` - 元，中国站返回的币种   * `USD` - 美元，国际站返回的币种
 
         :param currency: The currency of this EstimateExecutionPlanPriceResponse.
         :type currency: str
         """
         self._currency = currency
 
     @property
```

## huaweicloudsdkaos/v1/model/execution_plan.py

```diff
@@ -43,23 +43,23 @@
     def __init__(self, stack_name=None, stack_id=None, execution_plan_id=None, execution_plan_name=None, description=None, status=None, status_message=None, create_time=None, apply_time=None):
         """ExecutionPlan
 
         The model defined in huaweicloud sdk
 
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
-        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
         :type execution_plan_id: str
         :param execution_plan_name: 执行计划的名称。此名字在domain_id+区域+project_id+stack_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type execution_plan_name: str
         :param description: 执行计划的描述。可用于客户识别自己的执行计划。
         :type description: str
-        :param status: 执行计划的状态     * &#x60;CREATION_IN_PROGRESS&#x60; - 正在创建，请等待     * &#x60;CREATION_FAILED&#x60; - 创建失败，请从status_message获取错误信息汇总     * &#x60;AVAILABLE&#x60; - 创建完成，可以调用ApplyExecutionPlan API进行执行     * &#x60;APPLY_IN_PROGRESS&#x60; - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件     * &#x60;APPLIED&#x60; - 已执行
+        :param status: 执行计划的状态    * &#x60;CREATION_IN_PROGRESS&#x60; - 正在创建，请等待    * &#x60;CREATION_FAILED&#x60; - 创建失败，请从status_message获取错误信息汇总    * &#x60;AVAILABLE&#x60; - 创建完成，可以调用ApplyExecutionPlan API进行执行    * &#x60;APPLY_IN_PROGRESS&#x60; - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件    * &#x60;APPLIED&#x60; - 已执行
         :type status: str
         :param status_message: 当执行计划的状态为创建失败状态（即为 &#x60;CREATION_FAILED&#x60; 时），将会展示简要的错误信息总结以供debug
         :type status_message: str
         :param create_time: 执行计划的生成时间，格式遵循RFC3339，精确到秒，UTC时区，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
         :type create_time: str
         :param apply_time: 执行计划的执行时间，格式遵循RFC3339，精确到秒，UTC时区，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
         :type apply_time: str
@@ -117,48 +117,48 @@
         """
         self._stack_name = stack_name
 
     @property
     def stack_id(self):
         """Gets the stack_id of this ExecutionPlan.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this ExecutionPlan.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this ExecutionPlan.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this ExecutionPlan.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     @property
     def execution_plan_id(self):
         """Gets the execution_plan_id of this ExecutionPlan.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :return: The execution_plan_id of this ExecutionPlan.
         :rtype: str
         """
         return self._execution_plan_id
 
     @execution_plan_id.setter
     def execution_plan_id(self, execution_plan_id):
         """Sets the execution_plan_id of this ExecutionPlan.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :param execution_plan_id: The execution_plan_id of this ExecutionPlan.
         :type execution_plan_id: str
         """
         self._execution_plan_id = execution_plan_id
 
     @property
@@ -205,26 +205,26 @@
         """
         self._description = description
 
     @property
     def status(self):
         """Gets the status of this ExecutionPlan.
 
-        执行计划的状态     * `CREATION_IN_PROGRESS` - 正在创建，请等待     * `CREATION_FAILED` - 创建失败，请从status_message获取错误信息汇总     * `AVAILABLE` - 创建完成，可以调用ApplyExecutionPlan API进行执行     * `APPLY_IN_PROGRESS` - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件     * `APPLIED` - 已执行
+        执行计划的状态    * `CREATION_IN_PROGRESS` - 正在创建，请等待    * `CREATION_FAILED` - 创建失败，请从status_message获取错误信息汇总    * `AVAILABLE` - 创建完成，可以调用ApplyExecutionPlan API进行执行    * `APPLY_IN_PROGRESS` - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件    * `APPLIED` - 已执行
 
         :return: The status of this ExecutionPlan.
         :rtype: str
         """
         return self._status
 
     @status.setter
     def status(self, status):
         """Sets the status of this ExecutionPlan.
 
-        执行计划的状态     * `CREATION_IN_PROGRESS` - 正在创建，请等待     * `CREATION_FAILED` - 创建失败，请从status_message获取错误信息汇总     * `AVAILABLE` - 创建完成，可以调用ApplyExecutionPlan API进行执行     * `APPLY_IN_PROGRESS` - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件     * `APPLIED` - 已执行
+        执行计划的状态    * `CREATION_IN_PROGRESS` - 正在创建，请等待    * `CREATION_FAILED` - 创建失败，请从status_message获取错误信息汇总    * `AVAILABLE` - 创建完成，可以调用ApplyExecutionPlan API进行执行    * `APPLY_IN_PROGRESS` - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件    * `APPLIED` - 已执行
 
         :param status: The status of this ExecutionPlan.
         :type status: str
         """
         self._status = status
 
     @property
```

## huaweicloudsdkaos/v1/model/execution_plan_diff_attribute.py

```diff
@@ -31,17 +31,17 @@
     def __init__(self, name=None, previous_value=None, target_value=None):
         """ExecutionPlanDiffAttribute
 
         The model defined in huaweicloud sdk
 
         :param name: 当前资源将要被修改的参数的名字。
         :type name: str
-        :param previous_value: 当前资源被修改的参数的原始值。  若是资源创建的场景，则previous_value为空  若远端资源产生了偏差，则同一个资源会返回两个ExecutionPlanItem，其中一个的drifted为true，另一个的drifted为false   * drifted为true的previous_value为资源栈中所维持的资源属性和状态   * drifted为false的previous_value为provider请求远端资源后，远端资源所返回的资源属性和状态  若远端资源未产生偏差，则只会返回一个drifted为false的ExecutionPlanItem   * drifted为false的previous_value为资源栈中所维持的资源属性和状态 
+        :param previous_value: 当前资源被修改的参数的原始值。  若是资源创建的场景，则previous_value为空  若远端资源产生了偏差，则同一个资源会返回两个ExecutionPlanItem，其中一个的drifted为true，另一个的drifted为false   * drifted为true的previous_value为资源栈中所维持的资源属性和状态   * drifted为false的previous_value为provider请求远端资源后，远端资源所返回的资源属性和状态  若远端资源未产生偏差，则只会返回一个drifted为false的ExecutionPlanItem   * drifted为false的previous_value为资源栈中所维持的资源属性和状态
         :type previous_value: str
-        :param target_value: 当前资源被修改的参数的目的值。  若是资源删除的场景，则target_value为空  若远端资源产生了偏差，则同一个资源会返回两个ExecutionPlanItem，其中一个的drifted为true，另一个的drifted为false   * drifted为true的target_value为provider请求远端资源后，远端资源所返回的资源属性和状态   * drifted为false的target_value为基于用户模板更新的资源属性和状态  若远端资源未产生偏差，则只会返回一个drifted为false的ExecutionPlanItem   * drifted为false的target_value为基于用户模板更新的资源属性和状态 
+        :param target_value: 当前资源被修改的参数的目的值。  若是资源删除的场景，则target_value为空  若远端资源产生了偏差，则同一个资源会返回两个ExecutionPlanItem，其中一个的drifted为true，另一个的drifted为false   * drifted为true的target_value为provider请求远端资源后，远端资源所返回的资源属性和状态   * drifted为false的target_value为基于用户模板更新的资源属性和状态  若远端资源未产生偏差，则只会返回一个drifted为false的ExecutionPlanItem   * drifted为false的target_value为基于用户模板更新的资源属性和状态
         :type target_value: str
         """
         
         
 
         self._name = None
         self._previous_value = None
@@ -77,48 +77,48 @@
         """
         self._name = name
 
     @property
     def previous_value(self):
         """Gets the previous_value of this ExecutionPlanDiffAttribute.
 
-        当前资源被修改的参数的原始值。  若是资源创建的场景，则previous_value为空  若远端资源产生了偏差，则同一个资源会返回两个ExecutionPlanItem，其中一个的drifted为true，另一个的drifted为false   * drifted为true的previous_value为资源栈中所维持的资源属性和状态   * drifted为false的previous_value为provider请求远端资源后，远端资源所返回的资源属性和状态  若远端资源未产生偏差，则只会返回一个drifted为false的ExecutionPlanItem   * drifted为false的previous_value为资源栈中所维持的资源属性和状态 
+        当前资源被修改的参数的原始值。  若是资源创建的场景，则previous_value为空  若远端资源产生了偏差，则同一个资源会返回两个ExecutionPlanItem，其中一个的drifted为true，另一个的drifted为false   * drifted为true的previous_value为资源栈中所维持的资源属性和状态   * drifted为false的previous_value为provider请求远端资源后，远端资源所返回的资源属性和状态  若远端资源未产生偏差，则只会返回一个drifted为false的ExecutionPlanItem   * drifted为false的previous_value为资源栈中所维持的资源属性和状态
 
         :return: The previous_value of this ExecutionPlanDiffAttribute.
         :rtype: str
         """
         return self._previous_value
 
     @previous_value.setter
     def previous_value(self, previous_value):
         """Sets the previous_value of this ExecutionPlanDiffAttribute.
 
-        当前资源被修改的参数的原始值。  若是资源创建的场景，则previous_value为空  若远端资源产生了偏差，则同一个资源会返回两个ExecutionPlanItem，其中一个的drifted为true，另一个的drifted为false   * drifted为true的previous_value为资源栈中所维持的资源属性和状态   * drifted为false的previous_value为provider请求远端资源后，远端资源所返回的资源属性和状态  若远端资源未产生偏差，则只会返回一个drifted为false的ExecutionPlanItem   * drifted为false的previous_value为资源栈中所维持的资源属性和状态 
+        当前资源被修改的参数的原始值。  若是资源创建的场景，则previous_value为空  若远端资源产生了偏差，则同一个资源会返回两个ExecutionPlanItem，其中一个的drifted为true，另一个的drifted为false   * drifted为true的previous_value为资源栈中所维持的资源属性和状态   * drifted为false的previous_value为provider请求远端资源后，远端资源所返回的资源属性和状态  若远端资源未产生偏差，则只会返回一个drifted为false的ExecutionPlanItem   * drifted为false的previous_value为资源栈中所维持的资源属性和状态
 
         :param previous_value: The previous_value of this ExecutionPlanDiffAttribute.
         :type previous_value: str
         """
         self._previous_value = previous_value
 
     @property
     def target_value(self):
         """Gets the target_value of this ExecutionPlanDiffAttribute.
 
-        当前资源被修改的参数的目的值。  若是资源删除的场景，则target_value为空  若远端资源产生了偏差，则同一个资源会返回两个ExecutionPlanItem，其中一个的drifted为true，另一个的drifted为false   * drifted为true的target_value为provider请求远端资源后，远端资源所返回的资源属性和状态   * drifted为false的target_value为基于用户模板更新的资源属性和状态  若远端资源未产生偏差，则只会返回一个drifted为false的ExecutionPlanItem   * drifted为false的target_value为基于用户模板更新的资源属性和状态 
+        当前资源被修改的参数的目的值。  若是资源删除的场景，则target_value为空  若远端资源产生了偏差，则同一个资源会返回两个ExecutionPlanItem，其中一个的drifted为true，另一个的drifted为false   * drifted为true的target_value为provider请求远端资源后，远端资源所返回的资源属性和状态   * drifted为false的target_value为基于用户模板更新的资源属性和状态  若远端资源未产生偏差，则只会返回一个drifted为false的ExecutionPlanItem   * drifted为false的target_value为基于用户模板更新的资源属性和状态
 
         :return: The target_value of this ExecutionPlanDiffAttribute.
         :rtype: str
         """
         return self._target_value
 
     @target_value.setter
     def target_value(self, target_value):
         """Sets the target_value of this ExecutionPlanDiffAttribute.
 
-        当前资源被修改的参数的目的值。  若是资源删除的场景，则target_value为空  若远端资源产生了偏差，则同一个资源会返回两个ExecutionPlanItem，其中一个的drifted为true，另一个的drifted为false   * drifted为true的target_value为provider请求远端资源后，远端资源所返回的资源属性和状态   * drifted为false的target_value为基于用户模板更新的资源属性和状态  若远端资源未产生偏差，则只会返回一个drifted为false的ExecutionPlanItem   * drifted为false的target_value为基于用户模板更新的资源属性和状态 
+        当前资源被修改的参数的目的值。  若是资源删除的场景，则target_value为空  若远端资源产生了偏差，则同一个资源会返回两个ExecutionPlanItem，其中一个的drifted为true，另一个的drifted为false   * drifted为true的target_value为provider请求远端资源后，远端资源所返回的资源属性和状态   * drifted为false的target_value为基于用户模板更新的资源属性和状态  若远端资源未产生偏差，则只会返回一个drifted为false的ExecutionPlanItem   * drifted为false的target_value为基于用户模板更新的资源属性和状态
 
         :param target_value: The target_value of this ExecutionPlanDiffAttribute.
         :type target_value: str
         """
         self._target_value = target_value
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/execution_plan_id_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, execution_plan_id=None):
         """ExecutionPlanIdPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
         :type execution_plan_id: str
         """
         
         
 
         self._execution_plan_id = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if execution_plan_id is not None:
             self.execution_plan_id = execution_plan_id
 
     @property
     def execution_plan_id(self):
         """Gets the execution_plan_id of this ExecutionPlanIdPrimitiveTypeHolder.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :return: The execution_plan_id of this ExecutionPlanIdPrimitiveTypeHolder.
         :rtype: str
         """
         return self._execution_plan_id
 
     @execution_plan_id.setter
     def execution_plan_id(self, execution_plan_id):
         """Sets the execution_plan_id of this ExecutionPlanIdPrimitiveTypeHolder.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :param execution_plan_id: The execution_plan_id of this ExecutionPlanIdPrimitiveTypeHolder.
         :type execution_plan_id: str
         """
         self._execution_plan_id = execution_plan_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/execution_plan_item.py

```diff
@@ -43,29 +43,29 @@
     }
 
     def __init__(self, resource_type=None, resource_name=None, index=None, action=None, action_reason=None, provider_name=None, mode=None, drifted=None, resource_id=None, attributes=None):
         """ExecutionPlanItem
 
         The model defined in huaweicloud sdk
 
-        :param resource_type: 资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param resource_type: 资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type resource_type: str
-        :param resource_name: 资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param resource_name: 资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type resource_name: str
-        :param index: 资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   count &#x3D; 2   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;,         \&quot;count\&quot;: 2       }     }   } } &#x60;&#x60;&#x60;  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   for_each &#x3D; {     \&quot;vpc1\&quot; &#x3D; \&quot;test_vpc\&quot;     \&quot;vpc2\&quot; &#x3D; \&quot;test_vpc\&quot;   }   name &#x3D; each.value } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;for_each\&quot;: {           \&quot;vpc1\&quot;: \&quot;test_vpc\&quot;,           \&quot;vpc2\&quot;: \&quot;test_vpc\&quot;         }         \&quot;name\&quot;: \&quot;${each.value}\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param index: 资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   count &#x3D; 2   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;,         \&quot;count\&quot;: 2       }     }   } } &#x60;&#x60;&#x60;  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   for_each &#x3D; {     \&quot;vpc1\&quot; &#x3D; \&quot;test_vpc\&quot;     \&quot;vpc2\&quot; &#x3D; \&quot;test_vpc\&quot;   }   name &#x3D; each.value } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;for_each\&quot;: {           \&quot;vpc1\&quot;: \&quot;test_vpc\&quot;,           \&quot;vpc2\&quot;: \&quot;test_vpc\&quot;         }         \&quot;name\&quot;: \&quot;${each.value}\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type index: str
-        :param action: 资源变更的类型   * &#x60;ADD&#x60; - 新增资源   * &#x60;ADD_THEN_DELETE&#x60; - 由不可更新的资源返回，先创建新资源，再删除旧资源   * &#x60;DELETE &#x60; - 删除资源   * &#x60;DELETE_THEN_ADD&#x60; - 由不可更新的资源返回，先删除旧资源，再创建新资源   * &#x60;UPDATE&#x60; - 更新资源    * &#x60;NO_OPERATION&#x60; - 仅变更资源的依赖关系，但是对资源本身并无修改的操作 
+        :param action: 资源变更的类型   * &#x60;ADD&#x60; - 新增资源   * &#x60;ADD_THEN_DELETE&#x60; - 由不可更新的资源返回，先创建新资源，再删除旧资源   * &#x60;DELETE &#x60; - 删除资源   * &#x60;DELETE_THEN_ADD&#x60; - 由不可更新的资源返回，先删除旧资源，再创建新资源   * &#x60;UPDATE&#x60; - 更新资源    * &#x60;NO_OPERATION&#x60; - 仅变更资源的依赖关系，但是对资源本身并无修改的操作
         :type action: str
         :param action_reason: 触发该项目变更的原因，例如用户更新模板；远端删除资源等等
         :type action_reason: str
         :param provider_name: 该项目所属的provider名称。
         :type provider_name: str
-        :param mode: 资源模式   * &#x60;DATA&#x60; - 指可以在模板解析期间运行和获取服务端数据的资源类型，不会操作基础设施组件   * &#x60;RESOURCE&#x60; - 指通过模板管理的由服务定义的基础设施组件抽象，可以是物理资源也可以是逻辑资源 
+        :param mode: 资源模式   * &#x60;DATA&#x60; - 指可以在模板解析期间运行和获取服务端数据的资源类型，不会操作基础设施组件   * &#x60;RESOURCE&#x60; - 指通过模板管理的由服务定义的基础设施组件抽象，可以是物理资源也可以是逻辑资源
         :type mode: str
-        :param drifted: 当前资源的变更是否由偏差导致。  偏差，也叫漂移。指的是资源被资源编排服务创建以后，又经历过非资源编排服务触发的修改，如手动修改、调用SDK修改等，使得资源的配置与本服务所记录的资源的配置不一致。这种不一致便称为偏差。  当资源产生偏差以后： * 如果用户试图创建执行计划，则会提示用户产生偏差 * 如果用户直接部署，则偏差有可能被覆盖，资源编排服务只保证资源和模板最终一致。  资源的偏差有两种类型： * 资源定位属性被修改：如果是定位属性被修改，常见于删除后重建，此时资源已经不属于同一个资源。资源编排服务会认为此资源已经被删除，会尝试创建一个新的资源。 * 资源普通属性被修改：如果是普通属性被修改，则资源编排服务依然可以找到资源，但是下次部署会尝试修复偏差，即将资源保持和模板最终一致。  **注：资源编排服务团队极力推荐，如果资源是通过本服务创建的，请一直使用本服务进行维护和更新以确保资源和模板保持一致。建议非紧急事件以外的情况不要手动调整。** 
+        :param drifted: 当前资源的变更是否由偏差导致。  偏差，也叫漂移。指的是资源被资源编排服务创建以后，又经历过非资源编排服务触发的修改，如手动修改、调用SDK修改等，使得资源的配置与本服务所记录的资源的配置不一致。这种不一致便称为偏差。  当资源产生偏差以后： * 如果用户试图创建执行计划，则会提示用户产生偏差 * 如果用户直接部署，则偏差有可能被覆盖，资源编排服务只保证资源和模板最终一致。  资源的偏差有两种类型： * 资源定位属性被修改：如果是定位属性被修改，常见于删除后重建，此时资源已经不属于同一个资源。资源编排服务会认为此资源已经被删除，会尝试创建一个新的资源。 * 资源普通属性被修改：如果是普通属性被修改，则资源编排服务依然可以找到资源，但是下次部署会尝试修复偏差，即将资源保持和模板最终一致。  **注：资源编排服务团队极力推荐，如果资源是通过本服务创建的，请一直使用本服务进行维护和更新以确保资源和模板保持一致。建议非紧急事件以外的情况不要手动调整。**
         :type drifted: bool
         :param resource_id: 资源的物理id，是唯一id，由为该资源提供服务的provider、云服务或其他服务提供方在资源部署的时候生成
         :type resource_id: str
         :param attributes: 执行计划项目中变更的属性，当无属性变更时为空列表。
         :type attributes: list[:class:`huaweicloudsdkaos.v1.ExecutionPlanDiffAttribute`]
         """
         
@@ -104,92 +104,92 @@
         if attributes is not None:
             self.attributes = attributes
 
     @property
     def resource_type(self):
         """Gets the resource_type of this ExecutionPlanItem.
 
-        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :return: The resource_type of this ExecutionPlanItem.
         :rtype: str
         """
         return self._resource_type
 
     @resource_type.setter
     def resource_type(self, resource_type):
         """Sets the resource_type of this ExecutionPlanItem.
 
-        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :param resource_type: The resource_type of this ExecutionPlanItem.
         :type resource_type: str
         """
         self._resource_type = resource_type
 
     @property
     def resource_name(self):
         """Gets the resource_name of this ExecutionPlanItem.
 
-        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :return: The resource_name of this ExecutionPlanItem.
         :rtype: str
         """
         return self._resource_name
 
     @resource_name.setter
     def resource_name(self, resource_name):
         """Sets the resource_name of this ExecutionPlanItem.
 
-        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :param resource_name: The resource_name of this ExecutionPlanItem.
         :type resource_name: str
         """
         self._resource_name = resource_name
 
     @property
     def index(self):
         """Gets the index of this ExecutionPlanItem.
 
-        资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ``` 
+        资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ```
 
         :return: The index of this ExecutionPlanItem.
         :rtype: str
         """
         return self._index
 
     @index.setter
     def index(self, index):
         """Sets the index of this ExecutionPlanItem.
 
-        资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ``` 
+        资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ```
 
         :param index: The index of this ExecutionPlanItem.
         :type index: str
         """
         self._index = index
 
     @property
     def action(self):
         """Gets the action of this ExecutionPlanItem.
 
-        资源变更的类型   * `ADD` - 新增资源   * `ADD_THEN_DELETE` - 由不可更新的资源返回，先创建新资源，再删除旧资源   * `DELETE ` - 删除资源   * `DELETE_THEN_ADD` - 由不可更新的资源返回，先删除旧资源，再创建新资源   * `UPDATE` - 更新资源    * `NO_OPERATION` - 仅变更资源的依赖关系，但是对资源本身并无修改的操作 
+        资源变更的类型   * `ADD` - 新增资源   * `ADD_THEN_DELETE` - 由不可更新的资源返回，先创建新资源，再删除旧资源   * `DELETE ` - 删除资源   * `DELETE_THEN_ADD` - 由不可更新的资源返回，先删除旧资源，再创建新资源   * `UPDATE` - 更新资源    * `NO_OPERATION` - 仅变更资源的依赖关系，但是对资源本身并无修改的操作
 
         :return: The action of this ExecutionPlanItem.
         :rtype: str
         """
         return self._action
 
     @action.setter
     def action(self, action):
         """Sets the action of this ExecutionPlanItem.
 
-        资源变更的类型   * `ADD` - 新增资源   * `ADD_THEN_DELETE` - 由不可更新的资源返回，先创建新资源，再删除旧资源   * `DELETE ` - 删除资源   * `DELETE_THEN_ADD` - 由不可更新的资源返回，先删除旧资源，再创建新资源   * `UPDATE` - 更新资源    * `NO_OPERATION` - 仅变更资源的依赖关系，但是对资源本身并无修改的操作 
+        资源变更的类型   * `ADD` - 新增资源   * `ADD_THEN_DELETE` - 由不可更新的资源返回，先创建新资源，再删除旧资源   * `DELETE ` - 删除资源   * `DELETE_THEN_ADD` - 由不可更新的资源返回，先删除旧资源，再创建新资源   * `UPDATE` - 更新资源    * `NO_OPERATION` - 仅变更资源的依赖关系，但是对资源本身并无修改的操作
 
         :param action: The action of this ExecutionPlanItem.
         :type action: str
         """
         self._action = action
 
     @property
@@ -236,48 +236,48 @@
         """
         self._provider_name = provider_name
 
     @property
     def mode(self):
         """Gets the mode of this ExecutionPlanItem.
 
-        资源模式   * `DATA` - 指可以在模板解析期间运行和获取服务端数据的资源类型，不会操作基础设施组件   * `RESOURCE` - 指通过模板管理的由服务定义的基础设施组件抽象，可以是物理资源也可以是逻辑资源 
+        资源模式   * `DATA` - 指可以在模板解析期间运行和获取服务端数据的资源类型，不会操作基础设施组件   * `RESOURCE` - 指通过模板管理的由服务定义的基础设施组件抽象，可以是物理资源也可以是逻辑资源
 
         :return: The mode of this ExecutionPlanItem.
         :rtype: str
         """
         return self._mode
 
     @mode.setter
     def mode(self, mode):
         """Sets the mode of this ExecutionPlanItem.
 
-        资源模式   * `DATA` - 指可以在模板解析期间运行和获取服务端数据的资源类型，不会操作基础设施组件   * `RESOURCE` - 指通过模板管理的由服务定义的基础设施组件抽象，可以是物理资源也可以是逻辑资源 
+        资源模式   * `DATA` - 指可以在模板解析期间运行和获取服务端数据的资源类型，不会操作基础设施组件   * `RESOURCE` - 指通过模板管理的由服务定义的基础设施组件抽象，可以是物理资源也可以是逻辑资源
 
         :param mode: The mode of this ExecutionPlanItem.
         :type mode: str
         """
         self._mode = mode
 
     @property
     def drifted(self):
         """Gets the drifted of this ExecutionPlanItem.
 
-        当前资源的变更是否由偏差导致。  偏差，也叫漂移。指的是资源被资源编排服务创建以后，又经历过非资源编排服务触发的修改，如手动修改、调用SDK修改等，使得资源的配置与本服务所记录的资源的配置不一致。这种不一致便称为偏差。  当资源产生偏差以后： * 如果用户试图创建执行计划，则会提示用户产生偏差 * 如果用户直接部署，则偏差有可能被覆盖，资源编排服务只保证资源和模板最终一致。  资源的偏差有两种类型： * 资源定位属性被修改：如果是定位属性被修改，常见于删除后重建，此时资源已经不属于同一个资源。资源编排服务会认为此资源已经被删除，会尝试创建一个新的资源。 * 资源普通属性被修改：如果是普通属性被修改，则资源编排服务依然可以找到资源，但是下次部署会尝试修复偏差，即将资源保持和模板最终一致。  **注：资源编排服务团队极力推荐，如果资源是通过本服务创建的，请一直使用本服务进行维护和更新以确保资源和模板保持一致。建议非紧急事件以外的情况不要手动调整。** 
+        当前资源的变更是否由偏差导致。  偏差，也叫漂移。指的是资源被资源编排服务创建以后，又经历过非资源编排服务触发的修改，如手动修改、调用SDK修改等，使得资源的配置与本服务所记录的资源的配置不一致。这种不一致便称为偏差。  当资源产生偏差以后： * 如果用户试图创建执行计划，则会提示用户产生偏差 * 如果用户直接部署，则偏差有可能被覆盖，资源编排服务只保证资源和模板最终一致。  资源的偏差有两种类型： * 资源定位属性被修改：如果是定位属性被修改，常见于删除后重建，此时资源已经不属于同一个资源。资源编排服务会认为此资源已经被删除，会尝试创建一个新的资源。 * 资源普通属性被修改：如果是普通属性被修改，则资源编排服务依然可以找到资源，但是下次部署会尝试修复偏差，即将资源保持和模板最终一致。  **注：资源编排服务团队极力推荐，如果资源是通过本服务创建的，请一直使用本服务进行维护和更新以确保资源和模板保持一致。建议非紧急事件以外的情况不要手动调整。**
 
         :return: The drifted of this ExecutionPlanItem.
         :rtype: bool
         """
         return self._drifted
 
     @drifted.setter
     def drifted(self, drifted):
         """Sets the drifted of this ExecutionPlanItem.
 
-        当前资源的变更是否由偏差导致。  偏差，也叫漂移。指的是资源被资源编排服务创建以后，又经历过非资源编排服务触发的修改，如手动修改、调用SDK修改等，使得资源的配置与本服务所记录的资源的配置不一致。这种不一致便称为偏差。  当资源产生偏差以后： * 如果用户试图创建执行计划，则会提示用户产生偏差 * 如果用户直接部署，则偏差有可能被覆盖，资源编排服务只保证资源和模板最终一致。  资源的偏差有两种类型： * 资源定位属性被修改：如果是定位属性被修改，常见于删除后重建，此时资源已经不属于同一个资源。资源编排服务会认为此资源已经被删除，会尝试创建一个新的资源。 * 资源普通属性被修改：如果是普通属性被修改，则资源编排服务依然可以找到资源，但是下次部署会尝试修复偏差，即将资源保持和模板最终一致。  **注：资源编排服务团队极力推荐，如果资源是通过本服务创建的，请一直使用本服务进行维护和更新以确保资源和模板保持一致。建议非紧急事件以外的情况不要手动调整。** 
+        当前资源的变更是否由偏差导致。  偏差，也叫漂移。指的是资源被资源编排服务创建以后，又经历过非资源编排服务触发的修改，如手动修改、调用SDK修改等，使得资源的配置与本服务所记录的资源的配置不一致。这种不一致便称为偏差。  当资源产生偏差以后： * 如果用户试图创建执行计划，则会提示用户产生偏差 * 如果用户直接部署，则偏差有可能被覆盖，资源编排服务只保证资源和模板最终一致。  资源的偏差有两种类型： * 资源定位属性被修改：如果是定位属性被修改，常见于删除后重建，此时资源已经不属于同一个资源。资源编排服务会认为此资源已经被删除，会尝试创建一个新的资源。 * 资源普通属性被修改：如果是普通属性被修改，则资源编排服务依然可以找到资源，但是下次部署会尝试修复偏差，即将资源保持和模板最终一致。  **注：资源编排服务团队极力推荐，如果资源是通过本服务创建的，请一直使用本服务进行维护和更新以确保资源和模板保持一致。建议非紧急事件以外的情况不要手动调整。**
 
         :param drifted: The drifted of this ExecutionPlanItem.
         :type drifted: bool
         """
         self._drifted = drifted
 
     @property
```

## huaweicloudsdkaos/v1/model/execution_plan_status_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, status=None):
         """ExecutionPlanStatusPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param status: 执行计划的状态     * &#x60;CREATION_IN_PROGRESS&#x60; - 正在创建，请等待     * &#x60;CREATION_FAILED&#x60; - 创建失败，请从status_message获取错误信息汇总     * &#x60;AVAILABLE&#x60; - 创建完成，可以调用ApplyExecutionPlan API进行执行     * &#x60;APPLY_IN_PROGRESS&#x60; - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件     * &#x60;APPLIED&#x60; - 已执行
+        :param status: 执行计划的状态    * &#x60;CREATION_IN_PROGRESS&#x60; - 正在创建，请等待    * &#x60;CREATION_FAILED&#x60; - 创建失败，请从status_message获取错误信息汇总    * &#x60;AVAILABLE&#x60; - 创建完成，可以调用ApplyExecutionPlan API进行执行    * &#x60;APPLY_IN_PROGRESS&#x60; - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件    * &#x60;APPLIED&#x60; - 已执行
         :type status: str
         """
         
         
 
         self._status = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if status is not None:
             self.status = status
 
     @property
     def status(self):
         """Gets the status of this ExecutionPlanStatusPrimitiveTypeHolder.
 
-        执行计划的状态     * `CREATION_IN_PROGRESS` - 正在创建，请等待     * `CREATION_FAILED` - 创建失败，请从status_message获取错误信息汇总     * `AVAILABLE` - 创建完成，可以调用ApplyExecutionPlan API进行执行     * `APPLY_IN_PROGRESS` - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件     * `APPLIED` - 已执行
+        执行计划的状态    * `CREATION_IN_PROGRESS` - 正在创建，请等待    * `CREATION_FAILED` - 创建失败，请从status_message获取错误信息汇总    * `AVAILABLE` - 创建完成，可以调用ApplyExecutionPlan API进行执行    * `APPLY_IN_PROGRESS` - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件    * `APPLIED` - 已执行
 
         :return: The status of this ExecutionPlanStatusPrimitiveTypeHolder.
         :rtype: str
         """
         return self._status
 
     @status.setter
     def status(self, status):
         """Sets the status of this ExecutionPlanStatusPrimitiveTypeHolder.
 
-        执行计划的状态     * `CREATION_IN_PROGRESS` - 正在创建，请等待     * `CREATION_FAILED` - 创建失败，请从status_message获取错误信息汇总     * `AVAILABLE` - 创建完成，可以调用ApplyExecutionPlan API进行执行     * `APPLY_IN_PROGRESS` - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件     * `APPLIED` - 已执行
+        执行计划的状态    * `CREATION_IN_PROGRESS` - 正在创建，请等待    * `CREATION_FAILED` - 创建失败，请从status_message获取错误信息汇总    * `AVAILABLE` - 创建完成，可以调用ApplyExecutionPlan API进行执行    * `APPLY_IN_PROGRESS` - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件    * `APPLIED` - 已执行
 
         :param status: The status of this ExecutionPlanStatusPrimitiveTypeHolder.
         :type status: str
         """
         self._status = status
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/get_execution_plan_metadata_request.py

```diff
@@ -39,17 +39,17 @@
 
         :param client_request_id: 用户指定的，对于此请求的唯一ID，用于定位某个请求，推荐使用UUID
         :type client_request_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
         :param execution_plan_name: 执行计划的名称。此名字在domain_id+区域+project_id+stack_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type execution_plan_name: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
-        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
         :type execution_plan_id: str
         """
         
         
 
         self._client_request_id = None
         self._stack_name = None
@@ -132,48 +132,48 @@
         """
         self._execution_plan_name = execution_plan_name
 
     @property
     def stack_id(self):
         """Gets the stack_id of this GetExecutionPlanMetadataRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this GetExecutionPlanMetadataRequest.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this GetExecutionPlanMetadataRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this GetExecutionPlanMetadataRequest.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     @property
     def execution_plan_id(self):
         """Gets the execution_plan_id of this GetExecutionPlanMetadataRequest.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :return: The execution_plan_id of this GetExecutionPlanMetadataRequest.
         :rtype: str
         """
         return self._execution_plan_id
 
     @execution_plan_id.setter
     def execution_plan_id(self, execution_plan_id):
         """Sets the execution_plan_id of this GetExecutionPlanMetadataRequest.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :param execution_plan_id: The execution_plan_id of this GetExecutionPlanMetadataRequest.
         :type execution_plan_id: str
         """
         self._execution_plan_id = execution_plan_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/get_execution_plan_metadata_response.py

```diff
@@ -50,37 +50,37 @@
     }
 
     def __init__(self, stack_id=None, stack_name=None, execution_plan_id=None, execution_plan_name=None, description=None, vars_structure=None, vars_uri_content=None, vars_body=None, status=None, status_message=None, create_time=None, apply_time=None, summary=None):
         """GetExecutionPlanMetadataResponse
 
         The model defined in huaweicloud sdk
 
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
-        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
         :type execution_plan_id: str
         :param execution_plan_name: 执行计划的名称。此名字在domain_id+区域+project_id+stack_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type execution_plan_name: str
         :param description: 执行计划的描述。可用于客户识别自己的执行计划。
         :type description: str
-        :param vars_structure: HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        :param vars_structure: HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
         :type vars_structure: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         :param vars_uri_content: vars_uri对应的文件内容
         :type vars_uri_content: str
-        :param vars_body: HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        :param vars_body: HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
         :type vars_body: str
-        :param status: 执行计划的状态     * &#x60;CREATION_IN_PROGRESS&#x60; - 正在创建，请等待     * &#x60;CREATION_FAILED&#x60; - 创建失败，请从status_message获取错误信息汇总     * &#x60;AVAILABLE&#x60; - 创建完成，可以调用ApplyExecutionPlan API进行执行     * &#x60;APPLY_IN_PROGRESS&#x60; - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件     * &#x60;APPLIED&#x60; - 已执行
+        :param status: 执行计划的状态    * &#x60;CREATION_IN_PROGRESS&#x60; - 正在创建，请等待    * &#x60;CREATION_FAILED&#x60; - 创建失败，请从status_message获取错误信息汇总    * &#x60;AVAILABLE&#x60; - 创建完成，可以调用ApplyExecutionPlan API进行执行    * &#x60;APPLY_IN_PROGRESS&#x60; - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件    * &#x60;APPLIED&#x60; - 已执行
         :type status: str
         :param status_message: 当执行计划的状态为创建失败状态（即为 &#x60;CREATION_FAILED&#x60; 时），将会展示简要的错误信息总结以供debug
         :type status_message: str
-        :param create_time: 执行计划的生成时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        :param create_time: 执行计划的生成时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
         :type create_time: str
-        :param apply_time: 执行计划的执行时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        :param apply_time: 执行计划的执行时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
         :type apply_time: str
         :param summary: 
         :type summary: :class:`huaweicloudsdkaos.v1.ExecutionPlanSummary`
         """
         
         super(GetExecutionPlanMetadataResponse, self).__init__()
 
@@ -124,26 +124,26 @@
         if summary is not None:
             self.summary = summary
 
     @property
     def stack_id(self):
         """Gets the stack_id of this GetExecutionPlanMetadataResponse.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this GetExecutionPlanMetadataResponse.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this GetExecutionPlanMetadataResponse.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this GetExecutionPlanMetadataResponse.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     @property
@@ -168,26 +168,26 @@
         """
         self._stack_name = stack_name
 
     @property
     def execution_plan_id(self):
         """Gets the execution_plan_id of this GetExecutionPlanMetadataResponse.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :return: The execution_plan_id of this GetExecutionPlanMetadataResponse.
         :rtype: str
         """
         return self._execution_plan_id
 
     @execution_plan_id.setter
     def execution_plan_id(self, execution_plan_id):
         """Sets the execution_plan_id of this GetExecutionPlanMetadataResponse.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :param execution_plan_id: The execution_plan_id of this GetExecutionPlanMetadataResponse.
         :type execution_plan_id: str
         """
         self._execution_plan_id = execution_plan_id
 
     @property
@@ -234,26 +234,26 @@
         """
         self._description = description
 
     @property
     def vars_structure(self):
         """Gets the vars_structure of this GetExecutionPlanMetadataResponse.
 
-        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
 
         :return: The vars_structure of this GetExecutionPlanMetadataResponse.
         :rtype: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         return self._vars_structure
 
     @vars_structure.setter
     def vars_structure(self, vars_structure):
         """Sets the vars_structure of this GetExecutionPlanMetadataResponse.
 
-        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
 
         :param vars_structure: The vars_structure of this GetExecutionPlanMetadataResponse.
         :type vars_structure: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         self._vars_structure = vars_structure
 
     @property
@@ -278,48 +278,48 @@
         """
         self._vars_uri_content = vars_uri_content
 
     @property
     def vars_body(self):
         """Gets the vars_body of this GetExecutionPlanMetadataResponse.
 
-        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :return: The vars_body of this GetExecutionPlanMetadataResponse.
         :rtype: str
         """
         return self._vars_body
 
     @vars_body.setter
     def vars_body(self, vars_body):
         """Sets the vars_body of this GetExecutionPlanMetadataResponse.
 
-        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :param vars_body: The vars_body of this GetExecutionPlanMetadataResponse.
         :type vars_body: str
         """
         self._vars_body = vars_body
 
     @property
     def status(self):
         """Gets the status of this GetExecutionPlanMetadataResponse.
 
-        执行计划的状态     * `CREATION_IN_PROGRESS` - 正在创建，请等待     * `CREATION_FAILED` - 创建失败，请从status_message获取错误信息汇总     * `AVAILABLE` - 创建完成，可以调用ApplyExecutionPlan API进行执行     * `APPLY_IN_PROGRESS` - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件     * `APPLIED` - 已执行
+        执行计划的状态    * `CREATION_IN_PROGRESS` - 正在创建，请等待    * `CREATION_FAILED` - 创建失败，请从status_message获取错误信息汇总    * `AVAILABLE` - 创建完成，可以调用ApplyExecutionPlan API进行执行    * `APPLY_IN_PROGRESS` - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件    * `APPLIED` - 已执行
 
         :return: The status of this GetExecutionPlanMetadataResponse.
         :rtype: str
         """
         return self._status
 
     @status.setter
     def status(self, status):
         """Sets the status of this GetExecutionPlanMetadataResponse.
 
-        执行计划的状态     * `CREATION_IN_PROGRESS` - 正在创建，请等待     * `CREATION_FAILED` - 创建失败，请从status_message获取错误信息汇总     * `AVAILABLE` - 创建完成，可以调用ApplyExecutionPlan API进行执行     * `APPLY_IN_PROGRESS` - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件     * `APPLIED` - 已执行
+        执行计划的状态    * `CREATION_IN_PROGRESS` - 正在创建，请等待    * `CREATION_FAILED` - 创建失败，请从status_message获取错误信息汇总    * `AVAILABLE` - 创建完成，可以调用ApplyExecutionPlan API进行执行    * `APPLY_IN_PROGRESS` - 执行中，可通过GetStackMetadata查询资源栈状态，通过ListStackEvents获取执行过程中产生的资源栈事件    * `APPLIED` - 已执行
 
         :param status: The status of this GetExecutionPlanMetadataResponse.
         :type status: str
         """
         self._status = status
 
     @property
@@ -344,48 +344,48 @@
         """
         self._status_message = status_message
 
     @property
     def create_time(self):
         """Gets the create_time of this GetExecutionPlanMetadataResponse.
 
-        执行计划的生成时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        执行计划的生成时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
 
         :return: The create_time of this GetExecutionPlanMetadataResponse.
         :rtype: str
         """
         return self._create_time
 
     @create_time.setter
     def create_time(self, create_time):
         """Sets the create_time of this GetExecutionPlanMetadataResponse.
 
-        执行计划的生成时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        执行计划的生成时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
 
         :param create_time: The create_time of this GetExecutionPlanMetadataResponse.
         :type create_time: str
         """
         self._create_time = create_time
 
     @property
     def apply_time(self):
         """Gets the apply_time of this GetExecutionPlanMetadataResponse.
 
-        执行计划的执行时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        执行计划的执行时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
 
         :return: The apply_time of this GetExecutionPlanMetadataResponse.
         :rtype: str
         """
         return self._apply_time
 
     @apply_time.setter
     def apply_time(self, apply_time):
         """Sets the apply_time of this GetExecutionPlanMetadataResponse.
 
-        执行计划的执行时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        执行计划的执行时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
 
         :param apply_time: The apply_time of this GetExecutionPlanMetadataResponse.
         :type apply_time: str
         """
         self._apply_time = apply_time
 
     @property
```

## huaweicloudsdkaos/v1/model/get_execution_plan_request.py

```diff
@@ -39,17 +39,17 @@
 
         :param client_request_id: 用户指定的，对于此请求的唯一ID，用于定位某个请求，推荐使用UUID
         :type client_request_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
         :param execution_plan_name: 执行计划的名称。此名字在domain_id+区域+project_id+stack_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type execution_plan_name: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
-        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        :param execution_plan_id: 执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
         :type execution_plan_id: str
         """
         
         
 
         self._client_request_id = None
         self._stack_name = None
@@ -132,48 +132,48 @@
         """
         self._execution_plan_name = execution_plan_name
 
     @property
     def stack_id(self):
         """Gets the stack_id of this GetExecutionPlanRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this GetExecutionPlanRequest.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this GetExecutionPlanRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this GetExecutionPlanRequest.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     @property
     def execution_plan_id(self):
         """Gets the execution_plan_id of this GetExecutionPlanRequest.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :return: The execution_plan_id of this GetExecutionPlanRequest.
         :rtype: str
         """
         return self._execution_plan_id
 
     @execution_plan_id.setter
     def execution_plan_id(self, execution_plan_id):
         """Sets the execution_plan_id of this GetExecutionPlanRequest.
 
-        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400 
+        执行计划（execution_plan）的唯一Id。  此Id由资源编排服务在生成执行计划的时候生成，为UUID。  由于执行计划名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的执行计划，删除，再重新创建一个同名执行计划。  对于团队并行开发，用户可能希望确保，当前我操作的执行计划就是我认为的那个，而不是其他队友删除后创建的同名执行计划。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的执行计划所对应的ID都不相同，更新不会影响ID。如果给与的execution_plan_id和当前执行计划的ID不一致，则返回400
 
         :param execution_plan_id: The execution_plan_id of this GetExecutionPlanRequest.
         :type execution_plan_id: str
         """
         self._execution_plan_id = execution_plan_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/get_stack_metadata_request.py

```diff
@@ -33,15 +33,15 @@
 
         The model defined in huaweicloud sdk
 
         :param client_request_id: 用户指定的，对于此请求的唯一ID，用于定位某个请求，推荐使用UUID
         :type client_request_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         """
         
         
 
         self._client_request_id = None
         self._stack_name = None
@@ -97,26 +97,26 @@
         """
         self._stack_name = stack_name
 
     @property
     def stack_id(self):
         """Gets the stack_id of this GetStackMetadataRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this GetStackMetadataRequest.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this GetStackMetadataRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this GetStackMetadataRequest.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/get_stack_metadata_response.py

```diff
@@ -50,39 +50,39 @@
     }
 
     def __init__(self, stack_id=None, stack_name=None, description=None, vars_structure=None, vars_body=None, enable_deletion_protection=None, enable_auto_rollback=None, status=None, agencies=None, status_message=None, vars_uri_content=None, create_time=None, update_time=None):
         """GetStackMetadataResponse
 
         The model defined in huaweicloud sdk
 
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
         :param description: 资源栈的描述。可用于客户识别自己的资源栈。
         :type description: str
-        :param vars_structure: HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        :param vars_structure: HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
         :type vars_structure: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
-        :param vars_body: HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        :param vars_body: HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
         :type vars_body: str
-        :param enable_deletion_protection: 删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新* 
+        :param enable_deletion_protection: 删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新*
         :type enable_deletion_protection: bool
-        :param enable_auto_rollback: 自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新* 
+        :param enable_auto_rollback: 自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新*
         :type enable_auto_rollback: bool
-        :param status: 资源栈的状态     * &#x60;CREATION_COMPLETE&#x60; - 生成空资源栈完成，并没有任何部署     * &#x60;DEPLOYMENT_IN_PROGRESS&#x60; - 正在部署，请等待     * &#x60;DEPLOYMENT_FAILED&#x60; - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * &#x60;DEPLOYMENT_COMPLETE&#x60; - 部署完成     * &#x60;ROLLBACK_IN_PROGRESS&#x60; - 部署失败，正在回滚，请等待     * &#x60;ROLLBACK_FAILED&#x60; - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * &#x60;ROLLBACK_COMPLETE&#x60; - 回滚完成     * &#x60;DELETION_IN_PROGRESS&#x60; - 正在删除，请等待     * &#x60;DELETION_FAILED&#x60; - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
+        :param status: 资源栈的状态    * &#x60;CREATION_COMPLETE&#x60; - 生成空资源栈完成，并没有任何部署    * &#x60;DEPLOYMENT_IN_PROGRESS&#x60; - 正在部署，请等待    * &#x60;DEPLOYMENT_FAILED&#x60; - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * &#x60;DEPLOYMENT_COMPLETE&#x60; - 部署完成    * &#x60;ROLLBACK_IN_PROGRESS&#x60; - 部署失败，正在回滚，请等待    * &#x60;ROLLBACK_FAILED&#x60; - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * &#x60;ROLLBACK_COMPLETE&#x60; - 回滚完成    * &#x60;DELETION_IN_PROGRESS&#x60; - 正在删除，请等待    * &#x60;DELETION_FAILED&#x60; - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
         :type status: str
-        :param agencies: 委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。 
+        :param agencies: 委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。
         :type agencies: list[:class:`huaweicloudsdkaos.v1.Agency`]
         :param status_message: 当资源栈的状态为任意失败状态（即以 &#x60;FAILED&#x60; 结尾时），将会展示简要的错误信息总结以供debug
         :type status_message: str
         :param vars_uri_content: vars_uri对应的文件内容
         :type vars_uri_content: str
-        :param create_time: 资源栈的生成时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        :param create_time: 资源栈的生成时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
         :type create_time: str
-        :param update_time: 资源栈的更新时间（更新场景包括元数据更新场景和部署场景） 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        :param update_time: 资源栈的更新时间（更新场景包括元数据更新场景和部署场景） 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
         :type update_time: str
         """
         
         super(GetStackMetadataResponse, self).__init__()
 
         self._stack_id = None
         self._stack_name = None
@@ -125,26 +125,26 @@
         if update_time is not None:
             self.update_time = update_time
 
     @property
     def stack_id(self):
         """Gets the stack_id of this GetStackMetadataResponse.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this GetStackMetadataResponse.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this GetStackMetadataResponse.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this GetStackMetadataResponse.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     @property
@@ -191,136 +191,136 @@
         """
         self._description = description
 
     @property
     def vars_structure(self):
         """Gets the vars_structure of this GetStackMetadataResponse.
 
-        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
 
         :return: The vars_structure of this GetStackMetadataResponse.
         :rtype: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         return self._vars_structure
 
     @vars_structure.setter
     def vars_structure(self, vars_structure):
         """Sets the vars_structure of this GetStackMetadataResponse.
 
-        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
 
         :param vars_structure: The vars_structure of this GetStackMetadataResponse.
         :type vars_structure: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         self._vars_structure = vars_structure
 
     @property
     def vars_body(self):
         """Gets the vars_body of this GetStackMetadataResponse.
 
-        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :return: The vars_body of this GetStackMetadataResponse.
         :rtype: str
         """
         return self._vars_body
 
     @vars_body.setter
     def vars_body(self, vars_body):
         """Sets the vars_body of this GetStackMetadataResponse.
 
-        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :param vars_body: The vars_body of this GetStackMetadataResponse.
         :type vars_body: str
         """
         self._vars_body = vars_body
 
     @property
     def enable_deletion_protection(self):
         """Gets the enable_deletion_protection of this GetStackMetadataResponse.
 
-        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新* 
+        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新*
 
         :return: The enable_deletion_protection of this GetStackMetadataResponse.
         :rtype: bool
         """
         return self._enable_deletion_protection
 
     @enable_deletion_protection.setter
     def enable_deletion_protection(self, enable_deletion_protection):
         """Sets the enable_deletion_protection of this GetStackMetadataResponse.
 
-        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新* 
+        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新*
 
         :param enable_deletion_protection: The enable_deletion_protection of this GetStackMetadataResponse.
         :type enable_deletion_protection: bool
         """
         self._enable_deletion_protection = enable_deletion_protection
 
     @property
     def enable_auto_rollback(self):
         """Gets the enable_auto_rollback of this GetStackMetadataResponse.
 
-        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新* 
+        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新*
 
         :return: The enable_auto_rollback of this GetStackMetadataResponse.
         :rtype: bool
         """
         return self._enable_auto_rollback
 
     @enable_auto_rollback.setter
     def enable_auto_rollback(self, enable_auto_rollback):
         """Sets the enable_auto_rollback of this GetStackMetadataResponse.
 
-        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新* 
+        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新*
 
         :param enable_auto_rollback: The enable_auto_rollback of this GetStackMetadataResponse.
         :type enable_auto_rollback: bool
         """
         self._enable_auto_rollback = enable_auto_rollback
 
     @property
     def status(self):
         """Gets the status of this GetStackMetadataResponse.
 
-        资源栈的状态     * `CREATION_COMPLETE` - 生成空资源栈完成，并没有任何部署     * `DEPLOYMENT_IN_PROGRESS` - 正在部署，请等待     * `DEPLOYMENT_FAILED` - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * `DEPLOYMENT_COMPLETE` - 部署完成     * `ROLLBACK_IN_PROGRESS` - 部署失败，正在回滚，请等待     * `ROLLBACK_FAILED` - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * `ROLLBACK_COMPLETE` - 回滚完成     * `DELETION_IN_PROGRESS` - 正在删除，请等待     * `DELETION_FAILED` - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
+        资源栈的状态    * `CREATION_COMPLETE` - 生成空资源栈完成，并没有任何部署    * `DEPLOYMENT_IN_PROGRESS` - 正在部署，请等待    * `DEPLOYMENT_FAILED` - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * `DEPLOYMENT_COMPLETE` - 部署完成    * `ROLLBACK_IN_PROGRESS` - 部署失败，正在回滚，请等待    * `ROLLBACK_FAILED` - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * `ROLLBACK_COMPLETE` - 回滚完成    * `DELETION_IN_PROGRESS` - 正在删除，请等待    * `DELETION_FAILED` - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
 
         :return: The status of this GetStackMetadataResponse.
         :rtype: str
         """
         return self._status
 
     @status.setter
     def status(self, status):
         """Sets the status of this GetStackMetadataResponse.
 
-        资源栈的状态     * `CREATION_COMPLETE` - 生成空资源栈完成，并没有任何部署     * `DEPLOYMENT_IN_PROGRESS` - 正在部署，请等待     * `DEPLOYMENT_FAILED` - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * `DEPLOYMENT_COMPLETE` - 部署完成     * `ROLLBACK_IN_PROGRESS` - 部署失败，正在回滚，请等待     * `ROLLBACK_FAILED` - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * `ROLLBACK_COMPLETE` - 回滚完成     * `DELETION_IN_PROGRESS` - 正在删除，请等待     * `DELETION_FAILED` - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
+        资源栈的状态    * `CREATION_COMPLETE` - 生成空资源栈完成，并没有任何部署    * `DEPLOYMENT_IN_PROGRESS` - 正在部署，请等待    * `DEPLOYMENT_FAILED` - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * `DEPLOYMENT_COMPLETE` - 部署完成    * `ROLLBACK_IN_PROGRESS` - 部署失败，正在回滚，请等待    * `ROLLBACK_FAILED` - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * `ROLLBACK_COMPLETE` - 回滚完成    * `DELETION_IN_PROGRESS` - 正在删除，请等待    * `DELETION_FAILED` - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
 
         :param status: The status of this GetStackMetadataResponse.
         :type status: str
         """
         self._status = status
 
     @property
     def agencies(self):
         """Gets the agencies of this GetStackMetadataResponse.
 
-        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。 
+        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。
 
         :return: The agencies of this GetStackMetadataResponse.
         :rtype: list[:class:`huaweicloudsdkaos.v1.Agency`]
         """
         return self._agencies
 
     @agencies.setter
     def agencies(self, agencies):
         """Sets the agencies of this GetStackMetadataResponse.
 
-        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。 
+        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。
 
         :param agencies: The agencies of this GetStackMetadataResponse.
         :type agencies: list[:class:`huaweicloudsdkaos.v1.Agency`]
         """
         self._agencies = agencies
 
     @property
@@ -367,48 +367,48 @@
         """
         self._vars_uri_content = vars_uri_content
 
     @property
     def create_time(self):
         """Gets the create_time of this GetStackMetadataResponse.
 
-        资源栈的生成时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        资源栈的生成时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
 
         :return: The create_time of this GetStackMetadataResponse.
         :rtype: str
         """
         return self._create_time
 
     @create_time.setter
     def create_time(self, create_time):
         """Sets the create_time of this GetStackMetadataResponse.
 
-        资源栈的生成时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        资源栈的生成时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
 
         :param create_time: The create_time of this GetStackMetadataResponse.
         :type create_time: str
         """
         self._create_time = create_time
 
     @property
     def update_time(self):
         """Gets the update_time of this GetStackMetadataResponse.
 
-        资源栈的更新时间（更新场景包括元数据更新场景和部署场景） 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        资源栈的更新时间（更新场景包括元数据更新场景和部署场景） 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
 
         :return: The update_time of this GetStackMetadataResponse.
         :rtype: str
         """
         return self._update_time
 
     @update_time.setter
     def update_time(self, update_time):
         """Sets the update_time of this GetStackMetadataResponse.
 
-        资源栈的更新时间（更新场景包括元数据更新场景和部署场景） 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        资源栈的更新时间（更新场景包括元数据更新场景和部署场景） 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
 
         :param update_time: The update_time of this GetStackMetadataResponse.
         :type update_time: str
         """
         self._update_time = update_time
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/get_stack_template_request.py

```diff
@@ -33,15 +33,15 @@
 
         The model defined in huaweicloud sdk
 
         :param client_request_id: 用户指定的，对于此请求的唯一ID，用于定位某个请求，推荐使用UUID
         :type client_request_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         """
         
         
 
         self._client_request_id = None
         self._stack_name = None
@@ -97,26 +97,26 @@
         """
         self._stack_name = stack_name
 
     @property
     def stack_id(self):
         """Gets the stack_id of this GetStackTemplateRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this GetStackTemplateRequest.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this GetStackTemplateRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this GetStackTemplateRequest.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/index_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, index=None):
         """IndexPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param index: 资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   count &#x3D; 2   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;,         \&quot;count\&quot;: 2       }     }   } } &#x60;&#x60;&#x60;  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   for_each &#x3D; {     \&quot;vpc1\&quot; &#x3D; \&quot;test_vpc\&quot;     \&quot;vpc2\&quot; &#x3D; \&quot;test_vpc\&quot;   }   name &#x3D; each.value } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;for_each\&quot;: {           \&quot;vpc1\&quot;: \&quot;test_vpc\&quot;,           \&quot;vpc2\&quot;: \&quot;test_vpc\&quot;         }         \&quot;name\&quot;: \&quot;${each.value}\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param index: 资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   count &#x3D; 2   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;,         \&quot;count\&quot;: 2       }     }   } } &#x60;&#x60;&#x60;  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   for_each &#x3D; {     \&quot;vpc1\&quot; &#x3D; \&quot;test_vpc\&quot;     \&quot;vpc2\&quot; &#x3D; \&quot;test_vpc\&quot;   }   name &#x3D; each.value } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;for_each\&quot;: {           \&quot;vpc1\&quot;: \&quot;test_vpc\&quot;,           \&quot;vpc2\&quot;: \&quot;test_vpc\&quot;         }         \&quot;name\&quot;: \&quot;${each.value}\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type index: str
         """
         
         
 
         self._index = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if index is not None:
             self.index = index
 
     @property
     def index(self):
         """Gets the index of this IndexPrimitiveTypeHolder.
 
-        资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ``` 
+        资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ```
 
         :return: The index of this IndexPrimitiveTypeHolder.
         :rtype: str
         """
         return self._index
 
     @index.setter
     def index(self, index):
         """Sets the index of this IndexPrimitiveTypeHolder.
 
-        资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ``` 
+        资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ```
 
         :param index: The index of this IndexPrimitiveTypeHolder.
         :type index: str
         """
         self._index = index
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/items_response.py

```diff
@@ -35,25 +35,25 @@
     }
 
     def __init__(self, resource_type=None, resource_name=None, index=None, supported=None, unsupported_message=None, resource_price=None):
         """ItemsResponse
 
         The model defined in huaweicloud sdk
 
-        :param resource_type: 资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param resource_type: 资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type resource_type: str
-        :param resource_name: 资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param resource_name: 资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type resource_name: str
-        :param index: 资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   count &#x3D; 2   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;,         \&quot;count\&quot;: 2       }     }   } } &#x60;&#x60;&#x60;  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   for_each &#x3D; {     \&quot;vpc1\&quot; &#x3D; \&quot;test_vpc\&quot;     \&quot;vpc2\&quot; &#x3D; \&quot;test_vpc\&quot;   }   name &#x3D; each.value } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;for_each\&quot;: {           \&quot;vpc1\&quot;: \&quot;test_vpc\&quot;,           \&quot;vpc2\&quot;: \&quot;test_vpc\&quot;         }         \&quot;name\&quot;: \&quot;${each.value}\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param index: 资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   count &#x3D; 2   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;,         \&quot;count\&quot;: 2       }     }   } } &#x60;&#x60;&#x60;  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   for_each &#x3D; {     \&quot;vpc1\&quot; &#x3D; \&quot;test_vpc\&quot;     \&quot;vpc2\&quot; &#x3D; \&quot;test_vpc\&quot;   }   name &#x3D; each.value } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;for_each\&quot;: {           \&quot;vpc1\&quot;: \&quot;test_vpc\&quot;,           \&quot;vpc2\&quot;: \&quot;test_vpc\&quot;         }         \&quot;name\&quot;: \&quot;${each.value}\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type index: str
         :param supported: 该资源或该资源当前所给予的参数是否支持进行询价
         :type supported: bool
         :param unsupported_message: 该资源不支持询价的具体原因
         :type unsupported_message: str
-        :param resource_price: 该资源的询价信息  若该资源支持包周期计费或按需计费，或者该资源为免费资源，则返回该字段；若该资源不支持询价，则不返回该字段。 
+        :param resource_price: 该资源的询价信息  若该资源支持包周期计费或按需计费，或者该资源为免费资源，则返回该字段；若该资源不支持询价，则不返回该字段。
         :type resource_price: list[:class:`huaweicloudsdkaos.v1.ResourcePriceResponse`]
         """
         
         
 
         self._resource_type = None
         self._resource_name = None
@@ -76,70 +76,70 @@
         if resource_price is not None:
             self.resource_price = resource_price
 
     @property
     def resource_type(self):
         """Gets the resource_type of this ItemsResponse.
 
-        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :return: The resource_type of this ItemsResponse.
         :rtype: str
         """
         return self._resource_type
 
     @resource_type.setter
     def resource_type(self, resource_type):
         """Sets the resource_type of this ItemsResponse.
 
-        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :param resource_type: The resource_type of this ItemsResponse.
         :type resource_type: str
         """
         self._resource_type = resource_type
 
     @property
     def resource_name(self):
         """Gets the resource_name of this ItemsResponse.
 
-        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :return: The resource_name of this ItemsResponse.
         :rtype: str
         """
         return self._resource_name
 
     @resource_name.setter
     def resource_name(self, resource_name):
         """Sets the resource_name of this ItemsResponse.
 
-        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :param resource_name: The resource_name of this ItemsResponse.
         :type resource_name: str
         """
         self._resource_name = resource_name
 
     @property
     def index(self):
         """Gets the index of this ItemsResponse.
 
-        资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ``` 
+        资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ```
 
         :return: The index of this ItemsResponse.
         :rtype: str
         """
         return self._index
 
     @index.setter
     def index(self, index):
         """Sets the index of this ItemsResponse.
 
-        资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ``` 
+        资源的索引，若用户在模板中使用了count或for_each则会返回index。若index出现，则resource_name + index可以作为该资源的一种标识  若用户在模板中使用count，则index为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ```
 
         :param index: The index of this ItemsResponse.
         :type index: str
         """
         self._index = index
 
     @property
@@ -186,26 +186,26 @@
         """
         self._unsupported_message = unsupported_message
 
     @property
     def resource_price(self):
         """Gets the resource_price of this ItemsResponse.
 
-        该资源的询价信息  若该资源支持包周期计费或按需计费，或者该资源为免费资源，则返回该字段；若该资源不支持询价，则不返回该字段。 
+        该资源的询价信息  若该资源支持包周期计费或按需计费，或者该资源为免费资源，则返回该字段；若该资源不支持询价，则不返回该字段。
 
         :return: The resource_price of this ItemsResponse.
         :rtype: list[:class:`huaweicloudsdkaos.v1.ResourcePriceResponse`]
         """
         return self._resource_price
 
     @resource_price.setter
     def resource_price(self, resource_price):
         """Sets the resource_price of this ItemsResponse.
 
-        该资源的询价信息  若该资源支持包周期计费或按需计费，或者该资源为免费资源，则返回该字段；若该资源不支持询价，则不返回该字段。 
+        该资源的询价信息  若该资源支持包周期计费或按需计费，或者该资源为免费资源，则返回该字段；若该资源不支持询价，则不返回该字段。
 
         :param resource_price: The resource_price of this ItemsResponse.
         :type resource_price: list[:class:`huaweicloudsdkaos.v1.ResourcePriceResponse`]
         """
         self._resource_price = resource_price
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/list_execution_plans_request.py

```diff
@@ -33,15 +33,15 @@
 
         The model defined in huaweicloud sdk
 
         :param client_request_id: 用户指定的，对于此请求的唯一ID，用于定位某个请求，推荐使用UUID
         :type client_request_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         """
         
         
 
         self._client_request_id = None
         self._stack_name = None
@@ -97,26 +97,26 @@
         """
         self._stack_name = stack_name
 
     @property
     def stack_id(self):
         """Gets the stack_id of this ListExecutionPlansRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this ListExecutionPlansRequest.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this ListExecutionPlansRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this ListExecutionPlansRequest.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/list_stack_events_request.py

```diff
@@ -39,21 +39,21 @@
 
         The model defined in huaweicloud sdk
 
         :param client_request_id: 用户指定的，对于此请求的唯一ID，用于定位某个请求，推荐使用UUID
         :type client_request_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         :param deployment_id: 标识部署的唯一Id，此Id由资源编排服务在触发部署、回滚等操作时生成，为UUID。
         :type deployment_id: str
-        :param filter: 过滤条件  * 与（AND）运算符使用逗号（，）定义 * 或（OR）运算符使用竖线（|）定义，OR运算符优先级高于AND运算符 * 不支持括号 * 过滤运算符仅支持等号（&#x3D;&#x3D;） * 过滤参数名及其值仅支持包含大小写英文、数字和下划线 * 过滤条件中禁止使用分号，若有分号，则此条过滤会被忽略 * 一个过滤参数仅能与一个与条件相关，一个与条件中的多个或条件仅能与一个过滤参数相关 
+        :param filter: 过滤条件  * 与（AND）运算符使用逗号（，）定义 * 或（OR）运算符使用竖线（|）定义，OR运算符优先级高于AND运算符 * 不支持括号 * 过滤运算符仅支持等号（&#x3D;&#x3D;） * 过滤参数名及其值仅支持包含大小写英文、数字和下划线 * 过滤条件中禁止使用分号，若有分号，则此条过滤会被忽略 * 一个过滤参数仅能与一个与条件相关，一个与条件中的多个或条件仅能与一个过滤参数相关
         :type filter: str
-        :param field: 选择的属性名称  * 属性名仅支持包含大小写英文、数字和下划线 * 多个属性名称之间以逗号（，）分隔 
+        :param field: 选择的属性名称  * 属性名仅支持包含大小写英文、数字和下划线 * 多个属性名称之间以逗号（，）分隔
         :type field: str
         """
         
         
 
         self._client_request_id = None
         self._stack_name = None
@@ -118,26 +118,26 @@
         """
         self._stack_name = stack_name
 
     @property
     def stack_id(self):
         """Gets the stack_id of this ListStackEventsRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this ListStackEventsRequest.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this ListStackEventsRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this ListStackEventsRequest.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     @property
@@ -162,48 +162,48 @@
         """
         self._deployment_id = deployment_id
 
     @property
     def filter(self):
         """Gets the filter of this ListStackEventsRequest.
 
-        过滤条件  * 与（AND）运算符使用逗号（，）定义 * 或（OR）运算符使用竖线（|）定义，OR运算符优先级高于AND运算符 * 不支持括号 * 过滤运算符仅支持等号（==） * 过滤参数名及其值仅支持包含大小写英文、数字和下划线 * 过滤条件中禁止使用分号，若有分号，则此条过滤会被忽略 * 一个过滤参数仅能与一个与条件相关，一个与条件中的多个或条件仅能与一个过滤参数相关 
+        过滤条件  * 与（AND）运算符使用逗号（，）定义 * 或（OR）运算符使用竖线（|）定义，OR运算符优先级高于AND运算符 * 不支持括号 * 过滤运算符仅支持等号（==） * 过滤参数名及其值仅支持包含大小写英文、数字和下划线 * 过滤条件中禁止使用分号，若有分号，则此条过滤会被忽略 * 一个过滤参数仅能与一个与条件相关，一个与条件中的多个或条件仅能与一个过滤参数相关
 
         :return: The filter of this ListStackEventsRequest.
         :rtype: str
         """
         return self._filter
 
     @filter.setter
     def filter(self, filter):
         """Sets the filter of this ListStackEventsRequest.
 
-        过滤条件  * 与（AND）运算符使用逗号（，）定义 * 或（OR）运算符使用竖线（|）定义，OR运算符优先级高于AND运算符 * 不支持括号 * 过滤运算符仅支持等号（==） * 过滤参数名及其值仅支持包含大小写英文、数字和下划线 * 过滤条件中禁止使用分号，若有分号，则此条过滤会被忽略 * 一个过滤参数仅能与一个与条件相关，一个与条件中的多个或条件仅能与一个过滤参数相关 
+        过滤条件  * 与（AND）运算符使用逗号（，）定义 * 或（OR）运算符使用竖线（|）定义，OR运算符优先级高于AND运算符 * 不支持括号 * 过滤运算符仅支持等号（==） * 过滤参数名及其值仅支持包含大小写英文、数字和下划线 * 过滤条件中禁止使用分号，若有分号，则此条过滤会被忽略 * 一个过滤参数仅能与一个与条件相关，一个与条件中的多个或条件仅能与一个过滤参数相关
 
         :param filter: The filter of this ListStackEventsRequest.
         :type filter: str
         """
         self._filter = filter
 
     @property
     def field(self):
         """Gets the field of this ListStackEventsRequest.
 
-        选择的属性名称  * 属性名仅支持包含大小写英文、数字和下划线 * 多个属性名称之间以逗号（，）分隔 
+        选择的属性名称  * 属性名仅支持包含大小写英文、数字和下划线 * 多个属性名称之间以逗号（，）分隔
 
         :return: The field of this ListStackEventsRequest.
         :rtype: str
         """
         return self._field
 
     @field.setter
     def field(self, field):
         """Sets the field of this ListStackEventsRequest.
 
-        选择的属性名称  * 属性名仅支持包含大小写英文、数字和下划线 * 多个属性名称之间以逗号（，）分隔 
+        选择的属性名称  * 属性名仅支持包含大小写英文、数字和下划线 * 多个属性名称之间以逗号（，）分隔
 
         :param field: The field of this ListStackEventsRequest.
         :type field: str
         """
         self._field = field
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/list_stack_outputs_request.py

```diff
@@ -33,15 +33,15 @@
 
         The model defined in huaweicloud sdk
 
         :param client_request_id: 用户指定的，对于此请求的唯一ID，用于定位某个请求，推荐使用UUID
         :type client_request_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         """
         
         
 
         self._client_request_id = None
         self._stack_name = None
@@ -97,26 +97,26 @@
         """
         self._stack_name = stack_name
 
     @property
     def stack_id(self):
         """Gets the stack_id of this ListStackOutputsRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this ListStackOutputsRequest.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this ListStackOutputsRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this ListStackOutputsRequest.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/list_stack_resources_request.py

```diff
@@ -33,15 +33,15 @@
 
         The model defined in huaweicloud sdk
 
         :param client_request_id: 用户指定的，对于此请求的唯一ID，用于定位某个请求，推荐使用UUID
         :type client_request_id: str
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         """
         
         
 
         self._client_request_id = None
         self._stack_name = None
@@ -97,26 +97,26 @@
         """
         self._stack_name = stack_name
 
     @property
     def stack_id(self):
         """Gets the stack_id of this ListStackResourcesRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this ListStackResourcesRequest.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this ListStackResourcesRequest.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this ListStackResourcesRequest.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/parse_template_variables_request_body.py

```diff
@@ -27,17 +27,17 @@
     }
 
     def __init__(self, template_body=None, template_uri=None):
         """ParseTemplateVariablesRequestBody
 
         The model defined in huaweicloud sdk
 
-        :param template_body: HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        :param template_body: HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
         :type template_body: str
-        :param template_uri: HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以&#x60;.tf&#x60;或者&#x60;.tf.json&#x60;结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以&#x60;.zip&#x60;结尾。解压后的文件不得包含\&quot;.tfvars\&quot;文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        :param template_uri: HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以&#x60;.tf&#x60;或者&#x60;.tf.json&#x60;结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以&#x60;.zip&#x60;结尾。解压后的文件不得包含\&quot;.tfvars\&quot;文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
         :type template_uri: str
         """
         
         
 
         self._template_body = None
         self._template_uri = None
@@ -48,48 +48,48 @@
         if template_uri is not None:
             self.template_uri = template_uri
 
     @property
     def template_body(self):
         """Gets the template_body of this ParseTemplateVariablesRequestBody.
 
-        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
 
         :return: The template_body of this ParseTemplateVariablesRequestBody.
         :rtype: str
         """
         return self._template_body
 
     @template_body.setter
     def template_body(self, template_body):
         """Sets the template_body of this ParseTemplateVariablesRequestBody.
 
-        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
 
         :param template_body: The template_body of this ParseTemplateVariablesRequestBody.
         :type template_body: str
         """
         self._template_body = template_body
 
     @property
     def template_uri(self):
         """Gets the template_uri of this ParseTemplateVariablesRequestBody.
 
-        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
 
         :return: The template_uri of this ParseTemplateVariablesRequestBody.
         :rtype: str
         """
         return self._template_uri
 
     @template_uri.setter
     def template_uri(self, template_uri):
         """Sets the template_uri of this ParseTemplateVariablesRequestBody.
 
-        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
 
         :param template_uri: The template_uri of this ParseTemplateVariablesRequestBody.
         :type template_uri: str
         """
         self._template_uri = template_uri
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/resource_name_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, resource_name=None):
         """ResourceNamePrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param resource_name: 资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param resource_name: 资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type resource_name: str
         """
         
         
 
         self._resource_name = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if resource_name is not None:
             self.resource_name = resource_name
 
     @property
     def resource_name(self):
         """Gets the resource_name of this ResourceNamePrimitiveTypeHolder.
 
-        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :return: The resource_name of this ResourceNamePrimitiveTypeHolder.
         :rtype: str
         """
         return self._resource_name
 
     @resource_name.setter
     def resource_name(self, resource_name):
         """Sets the resource_name of this ResourceNamePrimitiveTypeHolder.
 
-        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :param resource_name: The resource_name of this ResourceNamePrimitiveTypeHolder.
         :type resource_name: str
         """
         self._resource_name = resource_name
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/resource_price_response.py

```diff
@@ -35,25 +35,25 @@
     }
 
     def __init__(self, charge_mode=None, sale_price=None, discount=None, original_price=None, period_type=None, period_count=None):
         """ResourcePriceResponse
 
         The model defined in huaweicloud sdk
 
-        :param charge_mode: 计费模式  * &#x60;PRE_PAID&#x60; - 包周期计费 * &#x60;POST_PAID&#x60; - 按需计费 * &#x60;FREE&#x60; - 免费 
+        :param charge_mode: 计费模式  * &#x60;PRE_PAID&#x60; - 包周期计费 * &#x60;POST_PAID&#x60; - 按需计费 * &#x60;FREE&#x60; - 免费
         :type charge_mode: str
         :param sale_price: 该资源最终优惠后的金额（只考虑官网折扣、商务折扣以及伙伴折扣，不包含促销折扣及优惠券），保留小数点后2位，向上取整，默认单位是元。
         :type sale_price: float
         :param discount: 该资源的总优惠额，保留小数点后2位，向上取整，默认单位是元。
         :type discount: float
         :param original_price: 该资源的原价，保留小数点后2位，向上取整，默认单位是元。
         :type original_price: float
-        :param period_type: 计费单位  若该资源支持包周期计费或按需计费，则会返回该字段；若该资源为免费资源，则不返回该字段。  * &#x60;HOUR&#x60; - 小时，按需计费的单位 * &#x60;DAY&#x60; - 天，按需计费的单位 * &#x60;MONTH&#x60; - 月，包周期计费的单位 * &#x60;YEAR&#x60; - 年，包周期计费的单位 * &#x60;BYTE&#x60; - 字节，按需计费的单位 * &#x60;MB&#x60; - 百万字节，包周期计费和按需计费的单位 * &#x60;GB&#x60; - 千兆字节，包周期计费和按需计费的单位 
+        :param period_type: 计费单位  若该资源支持包周期计费或按需计费，则会返回该字段；若该资源为免费资源，则不返回该字段。  * &#x60;HOUR&#x60; - 小时，按需计费的单位 * &#x60;DAY&#x60; - 天，按需计费的单位 * &#x60;MONTH&#x60; - 月，包周期计费的单位 * &#x60;YEAR&#x60; - 年，包周期计费的单位 * &#x60;BYTE&#x60; - 字节，按需计费的单位 * &#x60;MB&#x60; - 百万字节，包周期计费和按需计费的单位 * &#x60;GB&#x60; - 千兆字节，包周期计费和按需计费的单位
         :type period_type: str
-        :param period_count: 该资源的计费数量，需要和period_type搭配使用  若该资源支持包周期计费或按需计费，则会返回该字段；若该资源为免费资源，则不返回该字段。  * 对于按需计费资源，此值默认返回1，代表在1个计费单位下，该资源的价格 * 对于包周期计费资源，此值与模板中该资源的period字段保持一致 
+        :param period_count: 该资源的计费数量，需要和period_type搭配使用  若该资源支持包周期计费或按需计费，则会返回该字段；若该资源为免费资源，则不返回该字段。  * 对于按需计费资源，此值默认返回1，代表在1个计费单位下，该资源的价格 * 对于包周期计费资源，此值与模板中该资源的period字段保持一致
         :type period_count: int
         """
         
         
 
         self._charge_mode = None
         self._sale_price = None
@@ -76,26 +76,26 @@
         if period_count is not None:
             self.period_count = period_count
 
     @property
     def charge_mode(self):
         """Gets the charge_mode of this ResourcePriceResponse.
 
-        计费模式  * `PRE_PAID` - 包周期计费 * `POST_PAID` - 按需计费 * `FREE` - 免费 
+        计费模式  * `PRE_PAID` - 包周期计费 * `POST_PAID` - 按需计费 * `FREE` - 免费
 
         :return: The charge_mode of this ResourcePriceResponse.
         :rtype: str
         """
         return self._charge_mode
 
     @charge_mode.setter
     def charge_mode(self, charge_mode):
         """Sets the charge_mode of this ResourcePriceResponse.
 
-        计费模式  * `PRE_PAID` - 包周期计费 * `POST_PAID` - 按需计费 * `FREE` - 免费 
+        计费模式  * `PRE_PAID` - 包周期计费 * `POST_PAID` - 按需计费 * `FREE` - 免费
 
         :param charge_mode: The charge_mode of this ResourcePriceResponse.
         :type charge_mode: str
         """
         self._charge_mode = charge_mode
 
     @property
@@ -164,48 +164,48 @@
         """
         self._original_price = original_price
 
     @property
     def period_type(self):
         """Gets the period_type of this ResourcePriceResponse.
 
-        计费单位  若该资源支持包周期计费或按需计费，则会返回该字段；若该资源为免费资源，则不返回该字段。  * `HOUR` - 小时，按需计费的单位 * `DAY` - 天，按需计费的单位 * `MONTH` - 月，包周期计费的单位 * `YEAR` - 年，包周期计费的单位 * `BYTE` - 字节，按需计费的单位 * `MB` - 百万字节，包周期计费和按需计费的单位 * `GB` - 千兆字节，包周期计费和按需计费的单位 
+        计费单位  若该资源支持包周期计费或按需计费，则会返回该字段；若该资源为免费资源，则不返回该字段。  * `HOUR` - 小时，按需计费的单位 * `DAY` - 天，按需计费的单位 * `MONTH` - 月，包周期计费的单位 * `YEAR` - 年，包周期计费的单位 * `BYTE` - 字节，按需计费的单位 * `MB` - 百万字节，包周期计费和按需计费的单位 * `GB` - 千兆字节，包周期计费和按需计费的单位
 
         :return: The period_type of this ResourcePriceResponse.
         :rtype: str
         """
         return self._period_type
 
     @period_type.setter
     def period_type(self, period_type):
         """Sets the period_type of this ResourcePriceResponse.
 
-        计费单位  若该资源支持包周期计费或按需计费，则会返回该字段；若该资源为免费资源，则不返回该字段。  * `HOUR` - 小时，按需计费的单位 * `DAY` - 天，按需计费的单位 * `MONTH` - 月，包周期计费的单位 * `YEAR` - 年，包周期计费的单位 * `BYTE` - 字节，按需计费的单位 * `MB` - 百万字节，包周期计费和按需计费的单位 * `GB` - 千兆字节，包周期计费和按需计费的单位 
+        计费单位  若该资源支持包周期计费或按需计费，则会返回该字段；若该资源为免费资源，则不返回该字段。  * `HOUR` - 小时，按需计费的单位 * `DAY` - 天，按需计费的单位 * `MONTH` - 月，包周期计费的单位 * `YEAR` - 年，包周期计费的单位 * `BYTE` - 字节，按需计费的单位 * `MB` - 百万字节，包周期计费和按需计费的单位 * `GB` - 千兆字节，包周期计费和按需计费的单位
 
         :param period_type: The period_type of this ResourcePriceResponse.
         :type period_type: str
         """
         self._period_type = period_type
 
     @property
     def period_count(self):
         """Gets the period_count of this ResourcePriceResponse.
 
-        该资源的计费数量，需要和period_type搭配使用  若该资源支持包周期计费或按需计费，则会返回该字段；若该资源为免费资源，则不返回该字段。  * 对于按需计费资源，此值默认返回1，代表在1个计费单位下，该资源的价格 * 对于包周期计费资源，此值与模板中该资源的period字段保持一致 
+        该资源的计费数量，需要和period_type搭配使用  若该资源支持包周期计费或按需计费，则会返回该字段；若该资源为免费资源，则不返回该字段。  * 对于按需计费资源，此值默认返回1，代表在1个计费单位下，该资源的价格 * 对于包周期计费资源，此值与模板中该资源的period字段保持一致
 
         :return: The period_count of this ResourcePriceResponse.
         :rtype: int
         """
         return self._period_count
 
     @period_count.setter
     def period_count(self, period_count):
         """Sets the period_count of this ResourcePriceResponse.
 
-        该资源的计费数量，需要和period_type搭配使用  若该资源支持包周期计费或按需计费，则会返回该字段；若该资源为免费资源，则不返回该字段。  * 对于按需计费资源，此值默认返回1，代表在1个计费单位下，该资源的价格 * 对于包周期计费资源，此值与模板中该资源的period字段保持一致 
+        该资源的计费数量，需要和period_type搭配使用  若该资源支持包周期计费或按需计费，则会返回该字段；若该资源为免费资源，则不返回该字段。  * 对于按需计费资源，此值默认返回1，代表在1个计费单位下，该资源的价格 * 对于包周期计费资源，此值与模板中该资源的period字段保持一致
 
         :param period_count: The period_count of this ResourcePriceResponse.
         :type period_count: int
         """
         self._period_count = period_count
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/resource_type_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, resource_type=None):
         """ResourceTypePrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param resource_type: 资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param resource_type: 资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type resource_type: str
         """
         
         
 
         self._resource_type = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if resource_type is not None:
             self.resource_type = resource_type
 
     @property
     def resource_type(self):
         """Gets the resource_type of this ResourceTypePrimitiveTypeHolder.
 
-        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :return: The resource_type of this ResourceTypePrimitiveTypeHolder.
         :rtype: str
         """
         return self._resource_type
 
     @resource_type.setter
     def resource_type(self, resource_type):
         """Sets the resource_type of this ResourceTypePrimitiveTypeHolder.
 
-        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :param resource_type: The resource_type of this ResourceTypePrimitiveTypeHolder.
         :type resource_type: str
         """
         self._resource_type = resource_type
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/stack.py

```diff
@@ -41,17 +41,17 @@
 
         The model defined in huaweicloud sdk
 
         :param stack_name: 资源栈的名称。此名字在domain_id+区域+project_id下应唯一，可以使用中文、大小写英文、数字、下划线、中划线。首字符需为中文或者英文，区分大小写。
         :type stack_name: str
         :param description: 资源栈的描述。可用于客户识别自己的资源栈。
         :type description: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
-        :param status: 资源栈的状态     * &#x60;CREATION_COMPLETE&#x60; - 生成空资源栈完成，并没有任何部署     * &#x60;DEPLOYMENT_IN_PROGRESS&#x60; - 正在部署，请等待     * &#x60;DEPLOYMENT_FAILED&#x60; - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * &#x60;DEPLOYMENT_COMPLETE&#x60; - 部署完成     * &#x60;ROLLBACK_IN_PROGRESS&#x60; - 部署失败，正在回滚，请等待     * &#x60;ROLLBACK_FAILED&#x60; - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * &#x60;ROLLBACK_COMPLETE&#x60; - 回滚完成     * &#x60;DELETION_IN_PROGRESS&#x60; - 正在删除，请等待     * &#x60;DELETION_FAILED&#x60; - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
+        :param status: 资源栈的状态    * &#x60;CREATION_COMPLETE&#x60; - 生成空资源栈完成，并没有任何部署    * &#x60;DEPLOYMENT_IN_PROGRESS&#x60; - 正在部署，请等待    * &#x60;DEPLOYMENT_FAILED&#x60; - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * &#x60;DEPLOYMENT_COMPLETE&#x60; - 部署完成    * &#x60;ROLLBACK_IN_PROGRESS&#x60; - 部署失败，正在回滚，请等待    * &#x60;ROLLBACK_FAILED&#x60; - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * &#x60;ROLLBACK_COMPLETE&#x60; - 回滚完成    * &#x60;DELETION_IN_PROGRESS&#x60; - 正在删除，请等待    * &#x60;DELETION_FAILED&#x60; - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
         :type status: str
         :param create_time: 资源栈的生成时间，格式遵循RFC3339，精确到秒，UTC时区，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
         :type create_time: str
         :param update_time: 资源栈的更新时间，格式遵循RFC3339，精确到秒，UTC时区，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
         :type update_time: str
         :param status_message: 在失败的时候（资源栈状态以FAILED结尾）会显示简要的错误信息总结以供debug
         :type status_message: str
@@ -126,48 +126,48 @@
         """
         self._description = description
 
     @property
     def stack_id(self):
         """Gets the stack_id of this Stack.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this Stack.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this Stack.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this Stack.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     @property
     def status(self):
         """Gets the status of this Stack.
 
-        资源栈的状态     * `CREATION_COMPLETE` - 生成空资源栈完成，并没有任何部署     * `DEPLOYMENT_IN_PROGRESS` - 正在部署，请等待     * `DEPLOYMENT_FAILED` - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * `DEPLOYMENT_COMPLETE` - 部署完成     * `ROLLBACK_IN_PROGRESS` - 部署失败，正在回滚，请等待     * `ROLLBACK_FAILED` - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * `ROLLBACK_COMPLETE` - 回滚完成     * `DELETION_IN_PROGRESS` - 正在删除，请等待     * `DELETION_FAILED` - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
+        资源栈的状态    * `CREATION_COMPLETE` - 生成空资源栈完成，并没有任何部署    * `DEPLOYMENT_IN_PROGRESS` - 正在部署，请等待    * `DEPLOYMENT_FAILED` - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * `DEPLOYMENT_COMPLETE` - 部署完成    * `ROLLBACK_IN_PROGRESS` - 部署失败，正在回滚，请等待    * `ROLLBACK_FAILED` - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * `ROLLBACK_COMPLETE` - 回滚完成    * `DELETION_IN_PROGRESS` - 正在删除，请等待    * `DELETION_FAILED` - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
 
         :return: The status of this Stack.
         :rtype: str
         """
         return self._status
 
     @status.setter
     def status(self, status):
         """Sets the status of this Stack.
 
-        资源栈的状态     * `CREATION_COMPLETE` - 生成空资源栈完成，并没有任何部署     * `DEPLOYMENT_IN_PROGRESS` - 正在部署，请等待     * `DEPLOYMENT_FAILED` - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * `DEPLOYMENT_COMPLETE` - 部署完成     * `ROLLBACK_IN_PROGRESS` - 部署失败，正在回滚，请等待     * `ROLLBACK_FAILED` - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * `ROLLBACK_COMPLETE` - 回滚完成     * `DELETION_IN_PROGRESS` - 正在删除，请等待     * `DELETION_FAILED` - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
+        资源栈的状态    * `CREATION_COMPLETE` - 生成空资源栈完成，并没有任何部署    * `DEPLOYMENT_IN_PROGRESS` - 正在部署，请等待    * `DEPLOYMENT_FAILED` - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * `DEPLOYMENT_COMPLETE` - 部署完成    * `ROLLBACK_IN_PROGRESS` - 部署失败，正在回滚，请等待    * `ROLLBACK_FAILED` - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * `ROLLBACK_COMPLETE` - 回滚完成    * `DELETION_IN_PROGRESS` - 正在删除，请等待    * `DELETION_FAILED` - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
 
         :param status: The status of this Stack.
         :type status: str
         """
         self._status = status
 
     @property
```

## huaweicloudsdkaos/v1/model/stack_event.py

```diff
@@ -41,27 +41,27 @@
     }
 
     def __init__(self, resource_type=None, resource_name=None, resource_id_key=None, resource_id_value=None, resource_key=None, time=None, event_type=None, event_message=None, elapsed_seconds=None):
         """StackEvent
 
         The model defined in huaweicloud sdk
 
-        :param resource_type: 资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param resource_type: 资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type resource_type: str
-        :param resource_name: 资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param resource_name: 资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type resource_name: str
-        :param resource_id_key: 资源id的名称，即对应资源作为id使用的值的名称，当资源未创建的时候，不返回resource_id_key 此id由provider定义，因此不同的provider可能遵循了不同的命名规则，具体的命名规则请与provider开发者确认或阅读provider文档 
+        :param resource_id_key: 资源id的名称，即对应资源作为id使用的值的名称，当资源未创建的时候，不返回resource_id_key 此id由provider定义，因此不同的provider可能遵循了不同的命名规则，具体的命名规则请与provider开发者确认或阅读provider文档
         :type resource_id_key: str
         :param resource_id_value: 资源id的值，即对应资源作为id使用的值，当资源未创建的时候，不返回resource_id_value
         :type resource_id_value: str
-        :param resource_key: 资源键，若用户在模板中使用了count或for_each则会返回resource_key  若用户在模板中使用count，则resource_key为从0开始的数字  以HCL格式的模板为例，模板中count为2，意味着将会生成两个资源，对应的resource_key分别为0和1  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   count &#x3D; 2   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，模板中count为2，意味着将会生成两个资源，对应的resource_key分别为0和1  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;,         \&quot;count\&quot;: 2       }     }   } } &#x60;&#x60;&#x60;  若用户在模板中使用for_each，则resource_key为用户自定义的字符串  以HCL格式的模板为例，resource_key分别为vpc1和vpc2  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   for_each &#x3D; {     \&quot;vpc1\&quot; &#x3D; \&quot;test_vpc\&quot;     \&quot;vpc2\&quot; &#x3D; \&quot;test_vpc\&quot;   }   name &#x3D; each.value } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_key分别为vpc1和vpc2  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;for_each\&quot;: {           \&quot;vpc1\&quot;: \&quot;test_vpc\&quot;,           \&quot;vpc2\&quot;: \&quot;test_vpc\&quot;         }         \&quot;name\&quot;: \&quot;${each.value}\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param resource_key: 资源键，若用户在模板中使用了count或for_each则会返回resource_key  若用户在模板中使用count，则resource_key为从0开始的数字  以HCL格式的模板为例，模板中count为2，意味着将会生成两个资源，对应的resource_key分别为0和1  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   count &#x3D; 2   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，模板中count为2，意味着将会生成两个资源，对应的resource_key分别为0和1  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;,         \&quot;count\&quot;: 2       }     }   } } &#x60;&#x60;&#x60;  若用户在模板中使用for_each，则resource_key为用户自定义的字符串  以HCL格式的模板为例，resource_key分别为vpc1和vpc2  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   for_each &#x3D; {     \&quot;vpc1\&quot; &#x3D; \&quot;test_vpc\&quot;     \&quot;vpc2\&quot; &#x3D; \&quot;test_vpc\&quot;   }   name &#x3D; each.value } &#x60;&#x60;&#x60;  以json格式的模板为例，resource_key分别为vpc1和vpc2  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;for_each\&quot;: {           \&quot;vpc1\&quot;: \&quot;test_vpc\&quot;,           \&quot;vpc2\&quot;: \&quot;test_vpc\&quot;         }         \&quot;name\&quot;: \&quot;${each.value}\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type resource_key: str
-        :param time: 事件发生的时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        :param time: 事件发生的时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
         :type time: str
-        :param event_type: 此次事件的类型   * &#x60;LOG&#x60; - 记录状态信息，比如当前状态，目标状态等。   * &#x60;ERROR&#x60; - 记录失败信息   * &#x60;DRIFT&#x60; - 记录资源偏移信息   * &#x60;SUMMARY&#x60; - 记录资源变更结果总结   * &#x60;CREATION_IN_PROGRESS&#x60; - 正在生成   * &#x60;CREATION_FAILED&#x60; - 生成失败   * &#x60;CREATION_COMPLETE&#x60; - 生成完成   * &#x60;DELETION_IN_PROGRESS&#x60; - 正在删除   * &#x60;DELETION_FAILED&#x60; - 删除失败   * &#x60;DELETION_COMPLETE&#x60; - 已经删除   * &#x60;UPDATE_IN_PROGRESS&#x60; - 正在更新。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。   * &#x60;UPDATE_FAILED&#x60; - 更新失败。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。   * &#x60;UPDATE_COMPLETE&#x60; - 更新完成。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。 
+        :param event_type: 此次事件的类型   * &#x60;LOG&#x60; - 记录状态信息，比如当前状态，目标状态等。   * &#x60;ERROR&#x60; - 记录失败信息   * &#x60;DRIFT&#x60; - 记录资源偏移信息   * &#x60;SUMMARY&#x60; - 记录资源变更结果总结   * &#x60;CREATION_IN_PROGRESS&#x60; - 正在生成   * &#x60;CREATION_FAILED&#x60; - 生成失败   * &#x60;CREATION_COMPLETE&#x60; - 生成完成   * &#x60;DELETION_IN_PROGRESS&#x60; - 正在删除   * &#x60;DELETION_FAILED&#x60; - 删除失败   * &#x60;DELETION_COMPLETE&#x60; - 已经删除   * &#x60;UPDATE_IN_PROGRESS&#x60; - 正在更新。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。   * &#x60;UPDATE_FAILED&#x60; - 更新失败。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。   * &#x60;UPDATE_COMPLETE&#x60; - 更新完成。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。
         :type event_type: str
         :param event_message: 该资源栈事件对应的详细信息
         :type event_message: str
         :param elapsed_seconds: 此事件执行所花的时间，以秒为单位
         :type elapsed_seconds: int
         """
         
@@ -97,70 +97,70 @@
         if elapsed_seconds is not None:
             self.elapsed_seconds = elapsed_seconds
 
     @property
     def resource_type(self):
         """Gets the resource_type of this StackEvent.
 
-        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :return: The resource_type of this StackEvent.
         :rtype: str
         """
         return self._resource_type
 
     @resource_type.setter
     def resource_type(self, resource_type):
         """Sets the resource_type of this StackEvent.
 
-        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的类型  以HCL格式的模板为例，resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :param resource_type: The resource_type of this StackEvent.
         :type resource_type: str
         """
         self._resource_type = resource_type
 
     @property
     def resource_name(self):
         """Gets the resource_name of this StackEvent.
 
-        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :return: The resource_name of this StackEvent.
         :rtype: str
         """
         return self._resource_name
 
     @resource_name.setter
     def resource_name(self, resource_name):
         """Sets the resource_name of this StackEvent.
 
-        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的名称，默认为资源的逻辑名称  以HCL格式的模板为例，resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :param resource_name: The resource_name of this StackEvent.
         :type resource_name: str
         """
         self._resource_name = resource_name
 
     @property
     def resource_id_key(self):
         """Gets the resource_id_key of this StackEvent.
 
-        资源id的名称，即对应资源作为id使用的值的名称，当资源未创建的时候，不返回resource_id_key 此id由provider定义，因此不同的provider可能遵循了不同的命名规则，具体的命名规则请与provider开发者确认或阅读provider文档 
+        资源id的名称，即对应资源作为id使用的值的名称，当资源未创建的时候，不返回resource_id_key 此id由provider定义，因此不同的provider可能遵循了不同的命名规则，具体的命名规则请与provider开发者确认或阅读provider文档
 
         :return: The resource_id_key of this StackEvent.
         :rtype: str
         """
         return self._resource_id_key
 
     @resource_id_key.setter
     def resource_id_key(self, resource_id_key):
         """Sets the resource_id_key of this StackEvent.
 
-        资源id的名称，即对应资源作为id使用的值的名称，当资源未创建的时候，不返回resource_id_key 此id由provider定义，因此不同的provider可能遵循了不同的命名规则，具体的命名规则请与provider开发者确认或阅读provider文档 
+        资源id的名称，即对应资源作为id使用的值的名称，当资源未创建的时候，不返回resource_id_key 此id由provider定义，因此不同的provider可能遵循了不同的命名规则，具体的命名规则请与provider开发者确认或阅读provider文档
 
         :param resource_id_key: The resource_id_key of this StackEvent.
         :type resource_id_key: str
         """
         self._resource_id_key = resource_id_key
 
     @property
@@ -185,70 +185,70 @@
         """
         self._resource_id_value = resource_id_value
 
     @property
     def resource_key(self):
         """Gets the resource_key of this StackEvent.
 
-        资源键，若用户在模板中使用了count或for_each则会返回resource_key  若用户在模板中使用count，则resource_key为从0开始的数字  以HCL格式的模板为例，模板中count为2，意味着将会生成两个资源，对应的resource_key分别为0和1  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，模板中count为2，意味着将会生成两个资源，对应的resource_key分别为0和1  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则resource_key为用户自定义的字符串  以HCL格式的模板为例，resource_key分别为vpc1和vpc2  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，resource_key分别为vpc1和vpc2  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ``` 
+        资源键，若用户在模板中使用了count或for_each则会返回resource_key  若用户在模板中使用count，则resource_key为从0开始的数字  以HCL格式的模板为例，模板中count为2，意味着将会生成两个资源，对应的resource_key分别为0和1  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，模板中count为2，意味着将会生成两个资源，对应的resource_key分别为0和1  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则resource_key为用户自定义的字符串  以HCL格式的模板为例，resource_key分别为vpc1和vpc2  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，resource_key分别为vpc1和vpc2  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ```
 
         :return: The resource_key of this StackEvent.
         :rtype: str
         """
         return self._resource_key
 
     @resource_key.setter
     def resource_key(self, resource_key):
         """Sets the resource_key of this StackEvent.
 
-        资源键，若用户在模板中使用了count或for_each则会返回resource_key  若用户在模板中使用count，则resource_key为从0开始的数字  以HCL格式的模板为例，模板中count为2，意味着将会生成两个资源，对应的resource_key分别为0和1  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，模板中count为2，意味着将会生成两个资源，对应的resource_key分别为0和1  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则resource_key为用户自定义的字符串  以HCL格式的模板为例，resource_key分别为vpc1和vpc2  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，resource_key分别为vpc1和vpc2  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ``` 
+        资源键，若用户在模板中使用了count或for_each则会返回resource_key  若用户在模板中使用count，则resource_key为从0开始的数字  以HCL格式的模板为例，模板中count为2，意味着将会生成两个资源，对应的resource_key分别为0和1  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，模板中count为2，意味着将会生成两个资源，对应的resource_key分别为0和1  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则resource_key为用户自定义的字符串  以HCL格式的模板为例，resource_key分别为vpc1和vpc2  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，resource_key分别为vpc1和vpc2  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ```
 
         :param resource_key: The resource_key of this StackEvent.
         :type resource_key: str
         """
         self._resource_key = resource_key
 
     @property
     def time(self):
         """Gets the time of this StackEvent.
 
-        事件发生的时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        事件发生的时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
 
         :return: The time of this StackEvent.
         :rtype: str
         """
         return self._time
 
     @time.setter
     def time(self, time):
         """Sets the time of this StackEvent.
 
-        事件发生的时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z 
+        事件发生的时间 格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
 
         :param time: The time of this StackEvent.
         :type time: str
         """
         self._time = time
 
     @property
     def event_type(self):
         """Gets the event_type of this StackEvent.
 
-        此次事件的类型   * `LOG` - 记录状态信息，比如当前状态，目标状态等。   * `ERROR` - 记录失败信息   * `DRIFT` - 记录资源偏移信息   * `SUMMARY` - 记录资源变更结果总结   * `CREATION_IN_PROGRESS` - 正在生成   * `CREATION_FAILED` - 生成失败   * `CREATION_COMPLETE` - 生成完成   * `DELETION_IN_PROGRESS` - 正在删除   * `DELETION_FAILED` - 删除失败   * `DELETION_COMPLETE` - 已经删除   * `UPDATE_IN_PROGRESS` - 正在更新。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。   * `UPDATE_FAILED` - 更新失败。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。   * `UPDATE_COMPLETE` - 更新完成。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。 
+        此次事件的类型   * `LOG` - 记录状态信息，比如当前状态，目标状态等。   * `ERROR` - 记录失败信息   * `DRIFT` - 记录资源偏移信息   * `SUMMARY` - 记录资源变更结果总结   * `CREATION_IN_PROGRESS` - 正在生成   * `CREATION_FAILED` - 生成失败   * `CREATION_COMPLETE` - 生成完成   * `DELETION_IN_PROGRESS` - 正在删除   * `DELETION_FAILED` - 删除失败   * `DELETION_COMPLETE` - 已经删除   * `UPDATE_IN_PROGRESS` - 正在更新。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。   * `UPDATE_FAILED` - 更新失败。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。   * `UPDATE_COMPLETE` - 更新完成。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。
 
         :return: The event_type of this StackEvent.
         :rtype: str
         """
         return self._event_type
 
     @event_type.setter
     def event_type(self, event_type):
         """Sets the event_type of this StackEvent.
 
-        此次事件的类型   * `LOG` - 记录状态信息，比如当前状态，目标状态等。   * `ERROR` - 记录失败信息   * `DRIFT` - 记录资源偏移信息   * `SUMMARY` - 记录资源变更结果总结   * `CREATION_IN_PROGRESS` - 正在生成   * `CREATION_FAILED` - 生成失败   * `CREATION_COMPLETE` - 生成完成   * `DELETION_IN_PROGRESS` - 正在删除   * `DELETION_FAILED` - 删除失败   * `DELETION_COMPLETE` - 已经删除   * `UPDATE_IN_PROGRESS` - 正在更新。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。   * `UPDATE_FAILED` - 更新失败。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。   * `UPDATE_COMPLETE` - 更新完成。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。 
+        此次事件的类型   * `LOG` - 记录状态信息，比如当前状态，目标状态等。   * `ERROR` - 记录失败信息   * `DRIFT` - 记录资源偏移信息   * `SUMMARY` - 记录资源变更结果总结   * `CREATION_IN_PROGRESS` - 正在生成   * `CREATION_FAILED` - 生成失败   * `CREATION_COMPLETE` - 生成完成   * `DELETION_IN_PROGRESS` - 正在删除   * `DELETION_FAILED` - 删除失败   * `DELETION_COMPLETE` - 已经删除   * `UPDATE_IN_PROGRESS` - 正在更新。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。   * `UPDATE_FAILED` - 更新失败。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。   * `UPDATE_COMPLETE` - 更新完成。此处的更新特指非替换式更新，如果是替换式更新，则是DELETION后CREATION，或者CREATION后DELETION，具体以何种行为进行替换式更新由Provider定义。
 
         :param event_type: The event_type of this StackEvent.
         :type event_type: str
         """
         self._event_type = event_type
 
     @property
```

## huaweicloudsdkaos/v1/model/stack_id_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, stack_id=None):
         """StackIdPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
         """
         
         
 
         self._stack_id = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if stack_id is not None:
             self.stack_id = stack_id
 
     @property
     def stack_id(self):
         """Gets the stack_id of this StackIdPrimitiveTypeHolder.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this StackIdPrimitiveTypeHolder.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this StackIdPrimitiveTypeHolder.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this StackIdPrimitiveTypeHolder.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/stack_output.py

```diff
@@ -33,23 +33,23 @@
     }
 
     def __init__(self, name=None, description=None, type=None, value=None, sensitive=None):
         """StackOutput
 
         The model defined in huaweicloud sdk
 
-        :param name: 资源栈输出的名称，由用户在模板中定义  以 HCL 模板为例，name 为 vpc_id  &#x60;&#x60;&#x60;hcl output \&quot;vpc_id\&quot; {   value &#x3D; huaweicloud_vpc.my_hello_world_vpc.id } &#x60;&#x60;&#x60;  以 json 模板为例，name 为 vpc_id &#x60;&#x60;&#x60;json {   \&quot;output\&quot;: {     \&quot;vpc_id\&quot;: [       {         \&quot;value\&quot;: \&quot;${huaweicloud_vpc.my_hello_world_vpc.id}\&quot;       }     ]   } } &#x60;&#x60;&#x60; 
+        :param name: 资源栈输出的名称，由用户在模板中定义  以 HCL 模板为例，name 为 vpc_id  &#x60;&#x60;&#x60;hcl output \&quot;vpc_id\&quot; {   value &#x3D; huaweicloud_vpc.my_hello_world_vpc.id } &#x60;&#x60;&#x60;  以 json 模板为例，name 为 vpc_id &#x60;&#x60;&#x60;json {   \&quot;output\&quot;: {     \&quot;vpc_id\&quot;: [       {         \&quot;value\&quot;: \&quot;${huaweicloud_vpc.my_hello_world_vpc.id}\&quot;       }     ]   } } &#x60;&#x60;&#x60;
         :type name: str
         :param description: 资源栈输出的描述，由用户在模板中定义
         :type description: str
         :param type: 资源栈输出的类型
         :type type: str
         :param value: 资源栈输出的值
         :type value: str
-        :param sensitive: 标识该资源栈输出是否为敏感信息，由用户在模板中定义  若用户在模板中将该输出定义为sensitive，则返回体中该输出的value和type不会返回真实值，而是返回&#x60;&lt;sensitive&gt;&#x60; 
+        :param sensitive: 标识该资源栈输出是否为敏感信息，由用户在模板中定义  若用户在模板中将该输出定义为sensitive，则返回体中该输出的value和type不会返回真实值，而是返回&#x60;&lt;sensitive&gt;&#x60;
         :type sensitive: bool
         """
         
         
 
         self._name = None
         self._description = None
@@ -69,26 +69,26 @@
         if sensitive is not None:
             self.sensitive = sensitive
 
     @property
     def name(self):
         """Gets the name of this StackOutput.
 
-        资源栈输出的名称，由用户在模板中定义  以 HCL 模板为例，name 为 vpc_id  ```hcl output \"vpc_id\" {   value = huaweicloud_vpc.my_hello_world_vpc.id } ```  以 json 模板为例，name 为 vpc_id ```json {   \"output\": {     \"vpc_id\": [       {         \"value\": \"${huaweicloud_vpc.my_hello_world_vpc.id}\"       }     ]   } } ``` 
+        资源栈输出的名称，由用户在模板中定义  以 HCL 模板为例，name 为 vpc_id  ```hcl output \"vpc_id\" {   value = huaweicloud_vpc.my_hello_world_vpc.id } ```  以 json 模板为例，name 为 vpc_id ```json {   \"output\": {     \"vpc_id\": [       {         \"value\": \"${huaweicloud_vpc.my_hello_world_vpc.id}\"       }     ]   } } ```
 
         :return: The name of this StackOutput.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this StackOutput.
 
-        资源栈输出的名称，由用户在模板中定义  以 HCL 模板为例，name 为 vpc_id  ```hcl output \"vpc_id\" {   value = huaweicloud_vpc.my_hello_world_vpc.id } ```  以 json 模板为例，name 为 vpc_id ```json {   \"output\": {     \"vpc_id\": [       {         \"value\": \"${huaweicloud_vpc.my_hello_world_vpc.id}\"       }     ]   } } ``` 
+        资源栈输出的名称，由用户在模板中定义  以 HCL 模板为例，name 为 vpc_id  ```hcl output \"vpc_id\" {   value = huaweicloud_vpc.my_hello_world_vpc.id } ```  以 json 模板为例，name 为 vpc_id ```json {   \"output\": {     \"vpc_id\": [       {         \"value\": \"${huaweicloud_vpc.my_hello_world_vpc.id}\"       }     ]   } } ```
 
         :param name: The name of this StackOutput.
         :type name: str
         """
         self._name = name
 
     @property
@@ -157,26 +157,26 @@
         """
         self._value = value
 
     @property
     def sensitive(self):
         """Gets the sensitive of this StackOutput.
 
-        标识该资源栈输出是否为敏感信息，由用户在模板中定义  若用户在模板中将该输出定义为sensitive，则返回体中该输出的value和type不会返回真实值，而是返回`<sensitive>` 
+        标识该资源栈输出是否为敏感信息，由用户在模板中定义  若用户在模板中将该输出定义为sensitive，则返回体中该输出的value和type不会返回真实值，而是返回`<sensitive>`
 
         :return: The sensitive of this StackOutput.
         :rtype: bool
         """
         return self._sensitive
 
     @sensitive.setter
     def sensitive(self, sensitive):
         """Sets the sensitive of this StackOutput.
 
-        标识该资源栈输出是否为敏感信息，由用户在模板中定义  若用户在模板中将该输出定义为sensitive，则返回体中该输出的value和type不会返回真实值，而是返回`<sensitive>` 
+        标识该资源栈输出是否为敏感信息，由用户在模板中定义  若用户在模板中将该输出定义为sensitive，则返回体中该输出的value和type不会返回真实值，而是返回`<sensitive>`
 
         :param sensitive: The sensitive of this StackOutput.
         :type sensitive: bool
         """
         self._sensitive = sensitive
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/stack_resource.py

```diff
@@ -39,25 +39,25 @@
     }
 
     def __init__(self, physical_resource_id=None, physical_resource_name=None, logical_resource_name=None, logical_resource_type=None, index_key=None, resource_status=None, status_message=None, resource_attributes=None):
         """StackResource
 
         The model defined in huaweicloud sdk
 
-        :param physical_resource_id: 资源的物理id，由该资源的provider、云服务或其他服务提供方在资源部署的时候生成  注：与physical相关的参数可以在模板以外的地方，作为该资源的一种标识 
+        :param physical_resource_id: 资源的物理id，由该资源的provider、云服务或其他服务提供方在资源部署的时候生成  注：与physical相关的参数可以在模板以外的地方，作为该资源的一种标识
         :type physical_resource_id: str
-        :param physical_resource_name: 资源的物理名称，由该资源的provider、云服务或其他服务提供方在资源部署的时候定义  注：与physical相关的参数可以在模板以外的地方，作为该资源的一种标识 
+        :param physical_resource_name: 资源的物理名称，由该资源的provider、云服务或其他服务提供方在资源部署的时候定义  注：与physical相关的参数可以在模板以外的地方，作为该资源的一种标识
         :type physical_resource_name: str
-        :param logical_resource_name: 资源的逻辑名称，由用户在模板中定义  注：与 logical 相关的参数仅仅在模板内部，作为该资源的一种标识  以HCL格式的模板为例，logical_resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，logical_resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param logical_resource_name: 资源的逻辑名称，由用户在模板中定义  注：与 logical 相关的参数仅仅在模板内部，作为该资源的一种标识  以HCL格式的模板为例，logical_resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，logical_resource_name 为 my_hello_world_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type logical_resource_name: str
-        :param logical_resource_type: 资源的类型  注：与 logical 相关的参数仅仅在模板内部，作为该资源的一种标识  以HCL格式的模板为例，logical_resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，logical_resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param logical_resource_type: 资源的类型  注：与 logical 相关的参数仅仅在模板内部，作为该资源的一种标识  以HCL格式的模板为例，logical_resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，logical_resource_type 为 huaweicloud_vpc  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type logical_resource_type: str
-        :param index_key: 资源的索引，若用户在模板中使用了count或for_each则会返回index_key。若index_key出现，则logical_resource_name + index_key可以作为该资源的一种标识  若用户在模板中使用count，则index_key为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   count &#x3D; 2   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;,         \&quot;count\&quot;: 2       }     }   } } &#x60;&#x60;&#x60;  若用户在模板中使用for_each，则index_key为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   for_each &#x3D; {     \&quot;vpc1\&quot; &#x3D; \&quot;test_vpc\&quot;     \&quot;vpc2\&quot; &#x3D; \&quot;test_vpc\&quot;   }   name &#x3D; each.value } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;for_each\&quot;: {           \&quot;vpc1\&quot;: \&quot;test_vpc\&quot;,           \&quot;vpc2\&quot;: \&quot;test_vpc\&quot;         }         \&quot;name\&quot;: \&quot;${each.value}\&quot;       }     }   } } &#x60;&#x60;&#x60; 
+        :param index_key: 资源的索引，若用户在模板中使用了count或for_each则会返回index_key。若index_key出现，则logical_resource_name + index_key可以作为该资源的一种标识  若用户在模板中使用count，则index_key为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   count &#x3D; 2   name &#x3D; \&quot;test_vpc\&quot; } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[0]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[1]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;name\&quot;: \&quot;test_vpc\&quot;,         \&quot;count\&quot;: 2       }     }   } } &#x60;&#x60;&#x60;  若用户在模板中使用for_each，则index_key为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;hcl resource \&quot;huaweicloud_vpc\&quot; \&quot;my_hello_world_vpc\&quot; {   for_each &#x3D; {     \&quot;vpc1\&quot; &#x3D; \&quot;test_vpc\&quot;     \&quot;vpc2\&quot; &#x3D; \&quot;test_vpc\&quot;   }   name &#x3D; each.value } &#x60;&#x60;&#x60;  以json格式的模板为例，用户在模板中可以通过&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc1\&quot;]&#x60;和&#x60;huaweicloud_vpc.my_hello_world_vpc[\&quot;vpc2\&quot;]&#x60;标识两个资源  &#x60;&#x60;&#x60;json {   \&quot;resource\&quot;: {     \&quot;huaweicloud_vpc\&quot;: {       \&quot;my_hello_world_vpc\&quot;: {         \&quot;for_each\&quot;: {           \&quot;vpc1\&quot;: \&quot;test_vpc\&quot;,           \&quot;vpc2\&quot;: \&quot;test_vpc\&quot;         }         \&quot;name\&quot;: \&quot;${each.value}\&quot;       }     }   } } &#x60;&#x60;&#x60;
         :type index_key: str
-        :param resource_status: 资源的状态 * &#x60;CREATION_IN_PROGRESS&#x60; - 正在生成 * &#x60;CREATION_FAILED&#x60;      - 生成失败 * &#x60;CREATION_COMPLETE&#x60;    - 生成完成 * &#x60;DELETION_IN_PROGRESS&#x60; - 正在删除 * &#x60;DELETION_FAILED&#x60;      - 删除失败 * &#x60;DELETION_COMPLETE&#x60;    - 已经删除 * &#x60;UPDATE_IN_PROGRESS&#x60;   - 正在更新。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION * &#x60;UPDATE_FAILED&#x60;        - 更新失败。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION * &#x60;UPDATE_COMPLETE&#x60;      - 更新完成。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION 
+        :param resource_status: 资源的状态 * &#x60;CREATION_IN_PROGRESS&#x60; - 正在生成 * &#x60;CREATION_FAILED&#x60;      - 生成失败 * &#x60;CREATION_COMPLETE&#x60;    - 生成完成 * &#x60;DELETION_IN_PROGRESS&#x60; - 正在删除 * &#x60;DELETION_FAILED&#x60;      - 删除失败 * &#x60;DELETION_COMPLETE&#x60;    - 已经删除 * &#x60;UPDATE_IN_PROGRESS&#x60;   - 正在更新。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION * &#x60;UPDATE_FAILED&#x60;        - 更新失败。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION * &#x60;UPDATE_COMPLETE&#x60;      - 更新完成。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION
         :type resource_status: str
         :param status_message: 当该资源状态为任意失败状态（即以 &#x60;FAILED&#x60; 结尾时），将会展示简要的错误信息总结以供debug
         :type status_message: str
         :param resource_attributes: 资源属性列表
         :type resource_attributes: list[:class:`huaweicloudsdkaos.v1.ResourceAttribute`]
         """
         
@@ -90,136 +90,136 @@
         if resource_attributes is not None:
             self.resource_attributes = resource_attributes
 
     @property
     def physical_resource_id(self):
         """Gets the physical_resource_id of this StackResource.
 
-        资源的物理id，由该资源的provider、云服务或其他服务提供方在资源部署的时候生成  注：与physical相关的参数可以在模板以外的地方，作为该资源的一种标识 
+        资源的物理id，由该资源的provider、云服务或其他服务提供方在资源部署的时候生成  注：与physical相关的参数可以在模板以外的地方，作为该资源的一种标识
 
         :return: The physical_resource_id of this StackResource.
         :rtype: str
         """
         return self._physical_resource_id
 
     @physical_resource_id.setter
     def physical_resource_id(self, physical_resource_id):
         """Sets the physical_resource_id of this StackResource.
 
-        资源的物理id，由该资源的provider、云服务或其他服务提供方在资源部署的时候生成  注：与physical相关的参数可以在模板以外的地方，作为该资源的一种标识 
+        资源的物理id，由该资源的provider、云服务或其他服务提供方在资源部署的时候生成  注：与physical相关的参数可以在模板以外的地方，作为该资源的一种标识
 
         :param physical_resource_id: The physical_resource_id of this StackResource.
         :type physical_resource_id: str
         """
         self._physical_resource_id = physical_resource_id
 
     @property
     def physical_resource_name(self):
         """Gets the physical_resource_name of this StackResource.
 
-        资源的物理名称，由该资源的provider、云服务或其他服务提供方在资源部署的时候定义  注：与physical相关的参数可以在模板以外的地方，作为该资源的一种标识 
+        资源的物理名称，由该资源的provider、云服务或其他服务提供方在资源部署的时候定义  注：与physical相关的参数可以在模板以外的地方，作为该资源的一种标识
 
         :return: The physical_resource_name of this StackResource.
         :rtype: str
         """
         return self._physical_resource_name
 
     @physical_resource_name.setter
     def physical_resource_name(self, physical_resource_name):
         """Sets the physical_resource_name of this StackResource.
 
-        资源的物理名称，由该资源的provider、云服务或其他服务提供方在资源部署的时候定义  注：与physical相关的参数可以在模板以外的地方，作为该资源的一种标识 
+        资源的物理名称，由该资源的provider、云服务或其他服务提供方在资源部署的时候定义  注：与physical相关的参数可以在模板以外的地方，作为该资源的一种标识
 
         :param physical_resource_name: The physical_resource_name of this StackResource.
         :type physical_resource_name: str
         """
         self._physical_resource_name = physical_resource_name
 
     @property
     def logical_resource_name(self):
         """Gets the logical_resource_name of this StackResource.
 
-        资源的逻辑名称，由用户在模板中定义  注：与 logical 相关的参数仅仅在模板内部，作为该资源的一种标识  以HCL格式的模板为例，logical_resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，logical_resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的逻辑名称，由用户在模板中定义  注：与 logical 相关的参数仅仅在模板内部，作为该资源的一种标识  以HCL格式的模板为例，logical_resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，logical_resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :return: The logical_resource_name of this StackResource.
         :rtype: str
         """
         return self._logical_resource_name
 
     @logical_resource_name.setter
     def logical_resource_name(self, logical_resource_name):
         """Sets the logical_resource_name of this StackResource.
 
-        资源的逻辑名称，由用户在模板中定义  注：与 logical 相关的参数仅仅在模板内部，作为该资源的一种标识  以HCL格式的模板为例，logical_resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，logical_resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的逻辑名称，由用户在模板中定义  注：与 logical 相关的参数仅仅在模板内部，作为该资源的一种标识  以HCL格式的模板为例，logical_resource_name 为 my_hello_world_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，logical_resource_name 为 my_hello_world_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :param logical_resource_name: The logical_resource_name of this StackResource.
         :type logical_resource_name: str
         """
         self._logical_resource_name = logical_resource_name
 
     @property
     def logical_resource_type(self):
         """Gets the logical_resource_type of this StackResource.
 
-        资源的类型  注：与 logical 相关的参数仅仅在模板内部，作为该资源的一种标识  以HCL格式的模板为例，logical_resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，logical_resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的类型  注：与 logical 相关的参数仅仅在模板内部，作为该资源的一种标识  以HCL格式的模板为例，logical_resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，logical_resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :return: The logical_resource_type of this StackResource.
         :rtype: str
         """
         return self._logical_resource_type
 
     @logical_resource_type.setter
     def logical_resource_type(self, logical_resource_type):
         """Sets the logical_resource_type of this StackResource.
 
-        资源的类型  注：与 logical 相关的参数仅仅在模板内部，作为该资源的一种标识  以HCL格式的模板为例，logical_resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，logical_resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ``` 
+        资源的类型  注：与 logical 相关的参数仅仅在模板内部，作为该资源的一种标识  以HCL格式的模板为例，logical_resource_type 为 huaweicloud_vpc  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   name = \"test_vpc\" } ```  以json格式的模板为例，logical_resource_type 为 huaweicloud_vpc  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\"       }     }   } } ```
 
         :param logical_resource_type: The logical_resource_type of this StackResource.
         :type logical_resource_type: str
         """
         self._logical_resource_type = logical_resource_type
 
     @property
     def index_key(self):
         """Gets the index_key of this StackResource.
 
-        资源的索引，若用户在模板中使用了count或for_each则会返回index_key。若index_key出现，则logical_resource_name + index_key可以作为该资源的一种标识  若用户在模板中使用count，则index_key为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index_key为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ``` 
+        资源的索引，若用户在模板中使用了count或for_each则会返回index_key。若index_key出现，则logical_resource_name + index_key可以作为该资源的一种标识  若用户在模板中使用count，则index_key为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index_key为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ```
 
         :return: The index_key of this StackResource.
         :rtype: str
         """
         return self._index_key
 
     @index_key.setter
     def index_key(self, index_key):
         """Sets the index_key of this StackResource.
 
-        资源的索引，若用户在模板中使用了count或for_each则会返回index_key。若index_key出现，则logical_resource_name + index_key可以作为该资源的一种标识  若用户在模板中使用count，则index_key为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index_key为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ``` 
+        资源的索引，若用户在模板中使用了count或for_each则会返回index_key。若index_key出现，则logical_resource_name + index_key可以作为该资源的一种标识  若用户在模板中使用count，则index_key为从0开始的数字  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   count = 2   name = \"test_vpc\" } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[0]`和`huaweicloud_vpc.my_hello_world_vpc[1]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"name\": \"test_vpc\",         \"count\": 2       }     }   } } ```  若用户在模板中使用for_each，则index_key为用户自定义的字符串  以HCL格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```hcl resource \"huaweicloud_vpc\" \"my_hello_world_vpc\" {   for_each = {     \"vpc1\" = \"test_vpc\"     \"vpc2\" = \"test_vpc\"   }   name = each.value } ```  以json格式的模板为例，用户在模板中可以通过`huaweicloud_vpc.my_hello_world_vpc[\"vpc1\"]`和`huaweicloud_vpc.my_hello_world_vpc[\"vpc2\"]`标识两个资源  ```json {   \"resource\": {     \"huaweicloud_vpc\": {       \"my_hello_world_vpc\": {         \"for_each\": {           \"vpc1\": \"test_vpc\",           \"vpc2\": \"test_vpc\"         }         \"name\": \"${each.value}\"       }     }   } } ```
 
         :param index_key: The index_key of this StackResource.
         :type index_key: str
         """
         self._index_key = index_key
 
     @property
     def resource_status(self):
         """Gets the resource_status of this StackResource.
 
-        资源的状态 * `CREATION_IN_PROGRESS` - 正在生成 * `CREATION_FAILED`      - 生成失败 * `CREATION_COMPLETE`    - 生成完成 * `DELETION_IN_PROGRESS` - 正在删除 * `DELETION_FAILED`      - 删除失败 * `DELETION_COMPLETE`    - 已经删除 * `UPDATE_IN_PROGRESS`   - 正在更新。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION * `UPDATE_FAILED`        - 更新失败。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION * `UPDATE_COMPLETE`      - 更新完成。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION 
+        资源的状态 * `CREATION_IN_PROGRESS` - 正在生成 * `CREATION_FAILED`      - 生成失败 * `CREATION_COMPLETE`    - 生成完成 * `DELETION_IN_PROGRESS` - 正在删除 * `DELETION_FAILED`      - 删除失败 * `DELETION_COMPLETE`    - 已经删除 * `UPDATE_IN_PROGRESS`   - 正在更新。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION * `UPDATE_FAILED`        - 更新失败。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION * `UPDATE_COMPLETE`      - 更新完成。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION
 
         :return: The resource_status of this StackResource.
         :rtype: str
         """
         return self._resource_status
 
     @resource_status.setter
     def resource_status(self, resource_status):
         """Sets the resource_status of this StackResource.
 
-        资源的状态 * `CREATION_IN_PROGRESS` - 正在生成 * `CREATION_FAILED`      - 生成失败 * `CREATION_COMPLETE`    - 生成完成 * `DELETION_IN_PROGRESS` - 正在删除 * `DELETION_FAILED`      - 删除失败 * `DELETION_COMPLETE`    - 已经删除 * `UPDATE_IN_PROGRESS`   - 正在更新。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION * `UPDATE_FAILED`        - 更新失败。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION * `UPDATE_COMPLETE`      - 更新完成。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION 
+        资源的状态 * `CREATION_IN_PROGRESS` - 正在生成 * `CREATION_FAILED`      - 生成失败 * `CREATION_COMPLETE`    - 生成完成 * `DELETION_IN_PROGRESS` - 正在删除 * `DELETION_FAILED`      - 删除失败 * `DELETION_COMPLETE`    - 已经删除 * `UPDATE_IN_PROGRESS`   - 正在更新。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION * `UPDATE_FAILED`        - 更新失败。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION * `UPDATE_COMPLETE`      - 更新完成。此处的更新特指非替换式更新，如果是替换式更新，则使用CREATION后DELETION
 
         :param resource_status: The resource_status of this StackResource.
         :type resource_status: str
         """
         self._resource_status = resource_status
 
     @property
```

## huaweicloudsdkaos/v1/model/stack_status_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, status=None):
         """StackStatusPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param status: 资源栈的状态     * &#x60;CREATION_COMPLETE&#x60; - 生成空资源栈完成，并没有任何部署     * &#x60;DEPLOYMENT_IN_PROGRESS&#x60; - 正在部署，请等待     * &#x60;DEPLOYMENT_FAILED&#x60; - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * &#x60;DEPLOYMENT_COMPLETE&#x60; - 部署完成     * &#x60;ROLLBACK_IN_PROGRESS&#x60; - 部署失败，正在回滚，请等待     * &#x60;ROLLBACK_FAILED&#x60; - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * &#x60;ROLLBACK_COMPLETE&#x60; - 回滚完成     * &#x60;DELETION_IN_PROGRESS&#x60; - 正在删除，请等待     * &#x60;DELETION_FAILED&#x60; - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
+        :param status: 资源栈的状态    * &#x60;CREATION_COMPLETE&#x60; - 生成空资源栈完成，并没有任何部署    * &#x60;DEPLOYMENT_IN_PROGRESS&#x60; - 正在部署，请等待    * &#x60;DEPLOYMENT_FAILED&#x60; - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * &#x60;DEPLOYMENT_COMPLETE&#x60; - 部署完成    * &#x60;ROLLBACK_IN_PROGRESS&#x60; - 部署失败，正在回滚，请等待    * &#x60;ROLLBACK_FAILED&#x60; - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * &#x60;ROLLBACK_COMPLETE&#x60; - 回滚完成    * &#x60;DELETION_IN_PROGRESS&#x60; - 正在删除，请等待    * &#x60;DELETION_FAILED&#x60; - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
         :type status: str
         """
         
         
 
         self._status = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if status is not None:
             self.status = status
 
     @property
     def status(self):
         """Gets the status of this StackStatusPrimitiveTypeHolder.
 
-        资源栈的状态     * `CREATION_COMPLETE` - 生成空资源栈完成，并没有任何部署     * `DEPLOYMENT_IN_PROGRESS` - 正在部署，请等待     * `DEPLOYMENT_FAILED` - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * `DEPLOYMENT_COMPLETE` - 部署完成     * `ROLLBACK_IN_PROGRESS` - 部署失败，正在回滚，请等待     * `ROLLBACK_FAILED` - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * `ROLLBACK_COMPLETE` - 回滚完成     * `DELETION_IN_PROGRESS` - 正在删除，请等待     * `DELETION_FAILED` - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
+        资源栈的状态    * `CREATION_COMPLETE` - 生成空资源栈完成，并没有任何部署    * `DEPLOYMENT_IN_PROGRESS` - 正在部署，请等待    * `DEPLOYMENT_FAILED` - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * `DEPLOYMENT_COMPLETE` - 部署完成    * `ROLLBACK_IN_PROGRESS` - 部署失败，正在回滚，请等待    * `ROLLBACK_FAILED` - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * `ROLLBACK_COMPLETE` - 回滚完成    * `DELETION_IN_PROGRESS` - 正在删除，请等待    * `DELETION_FAILED` - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
 
         :return: The status of this StackStatusPrimitiveTypeHolder.
         :rtype: str
         """
         return self._status
 
     @status.setter
     def status(self, status):
         """Sets the status of this StackStatusPrimitiveTypeHolder.
 
-        资源栈的状态     * `CREATION_COMPLETE` - 生成空资源栈完成，并没有任何部署     * `DEPLOYMENT_IN_PROGRESS` - 正在部署，请等待     * `DEPLOYMENT_FAILED` - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * `DEPLOYMENT_COMPLETE` - 部署完成     * `ROLLBACK_IN_PROGRESS` - 部署失败，正在回滚，请等待     * `ROLLBACK_FAILED` - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情     * `ROLLBACK_COMPLETE` - 回滚完成     * `DELETION_IN_PROGRESS` - 正在删除，请等待     * `DELETION_FAILED` - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
+        资源栈的状态    * `CREATION_COMPLETE` - 生成空资源栈完成，并没有任何部署    * `DEPLOYMENT_IN_PROGRESS` - 正在部署，请等待    * `DEPLOYMENT_FAILED` - 部署失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * `DEPLOYMENT_COMPLETE` - 部署完成    * `ROLLBACK_IN_PROGRESS` - 部署失败，正在回滚，请等待    * `ROLLBACK_FAILED` - 回滚失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情    * `ROLLBACK_COMPLETE` - 回滚完成    * `DELETION_IN_PROGRESS` - 正在删除，请等待    * `DELETION_FAILED` - 删除失败。请从status_message获取错误信息汇总，或者调用ListStackEvents获得事件详情
 
         :param status: The status of this StackStatusPrimitiveTypeHolder.
         :type status: str
         """
         self._status = status
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/template.py

```diff
@@ -49,15 +49,15 @@
         :type template_description: str
         :param create_time: 模板的生成时间，格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
         :type create_time: str
         :param update_time: 模板的更新时间，格式遵循RFC3339，即yyyy-mm-ddTHH:MM:SSZ，如1970-01-01T00:00:00Z
         :type update_time: str
         :param latest_version_id: 模板中最新的模板版本ID
         :type latest_version_id: str
-        :param latest_version_description: -&gt; 模板中最新模板版本的版本描述
+        :param latest_version_description: 模板中最新模板版本的版本描述
         :type latest_version_description: str
         """
         
         
 
         self._template_id = None
         self._template_name = None
@@ -209,26 +209,26 @@
         """
         self._latest_version_id = latest_version_id
 
     @property
     def latest_version_description(self):
         """Gets the latest_version_description of this Template.
 
-        -> 模板中最新模板版本的版本描述
+        模板中最新模板版本的版本描述
 
         :return: The latest_version_description of this Template.
         :rtype: str
         """
         return self._latest_version_description
 
     @latest_version_description.setter
     def latest_version_description(self, latest_version_description):
         """Sets the latest_version_description of this Template.
 
-        -> 模板中最新模板版本的版本描述
+        模板中最新模板版本的版本描述
 
         :param latest_version_description: The latest_version_description of this Template.
         :type latest_version_description: str
         """
         self._latest_version_description = latest_version_description
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/template_body_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, template_body=None):
         """TemplateBodyPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param template_body: HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        :param template_body: HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
         :type template_body: str
         """
         
         
 
         self._template_body = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if template_body is not None:
             self.template_body = template_body
 
     @property
     def template_body(self):
         """Gets the template_body of this TemplateBodyPrimitiveTypeHolder.
 
-        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
 
         :return: The template_body of this TemplateBodyPrimitiveTypeHolder.
         :rtype: str
         """
         return self._template_body
 
     @template_body.setter
     def template_body(self, template_body):
         """Sets the template_body of this TemplateBodyPrimitiveTypeHolder.
 
-        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密 
+        HCL模板，描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_body中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的template_body。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密
 
         :param template_body: The template_body of this TemplateBodyPrimitiveTypeHolder.
         :type template_body: str
         """
         self._template_body = template_body
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/template_uri_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, template_uri=None):
         """TemplateURIPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param template_uri: HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以&#x60;.tf&#x60;或者&#x60;.tf.json&#x60;结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以&#x60;.zip&#x60;结尾。解压后的文件不得包含\&quot;.tfvars\&quot;文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        :param template_uri: HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以&#x60;.tf&#x60;或者&#x60;.tf.json&#x60;结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以&#x60;.zip&#x60;结尾。解压后的文件不得包含\&quot;.tfvars\&quot;文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
         :type template_uri: str
         """
         
         
 
         self._template_uri = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if template_uri is not None:
             self.template_uri = template_uri
 
     @property
     def template_uri(self):
         """Gets the template_uri of this TemplateURIPrimitiveTypeHolder.
 
-        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
 
         :return: The template_uri of this TemplateURIPrimitiveTypeHolder.
         :rtype: str
         """
         return self._template_uri
 
     @template_uri.setter
     def template_uri(self, template_uri):
         """Sets the template_uri of this TemplateURIPrimitiveTypeHolder.
 
-        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB 
+        HCL模板的OBS地址，该模板描述了资源的目标状态。资源编排服务将比较此模板与当前远程资源的状态之间的区别。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  对应的文件应该是纯tf文件或zip压缩包  纯tf文件需要以`.tf`或者`.tf.json`结尾，并遵守HCL语法  压缩包目前只支持zip格式，文件需要以`.zip`结尾。解压后的文件不得包含\".tfvars\"文件且必须是UTF8编码（其中.tf.json不能包含BOM头），zip压缩包当前支持的子文件数量最大为100  template_body和template_uri 必须有且只有一个存在  *在CreateStack API中，template_body和template_uri可以都不给予*  **注意：**   * template_uri对应的模板文件中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的模板文件内容。如为敏感信息，建议将敏感信息通过vars_structure参数化，并设置encryption字段开启加密   * template_uri对应的文件（或文件夹、zip包）名的长度不得超过255个字节，文件大小不得超过1MB
 
         :param template_uri: The template_uri of this TemplateURIPrimitiveTypeHolder.
         :type template_uri: str
         """
         self._template_uri = template_uri
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/update_stack_request_body.py

```diff
@@ -35,21 +35,21 @@
     def __init__(self, description=None, stack_id=None, enable_deletion_protection=None, enable_auto_rollback=None, agencies=None):
         """UpdateStackRequestBody
 
         The model defined in huaweicloud sdk
 
         :param description: 资源栈的描述。可用于客户识别自己的资源栈。
         :type description: str
-        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        :param stack_id: 资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
         :type stack_id: str
-        :param enable_deletion_protection: 删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新* 
+        :param enable_deletion_protection: 删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新*
         :type enable_deletion_protection: bool
-        :param enable_auto_rollback: 自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新* 
+        :param enable_auto_rollback: 自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新*
         :type enable_auto_rollback: bool
-        :param agencies: 委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。 
+        :param agencies: 委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。
         :type agencies: list[:class:`huaweicloudsdkaos.v1.Agency`]
         """
         
         
 
         self._description = None
         self._stack_id = None
@@ -91,92 +91,92 @@
         """
         self._description = description
 
     @property
     def stack_id(self):
         """Gets the stack_id of this UpdateStackRequestBody.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :return: The stack_id of this UpdateStackRequestBody.
         :rtype: str
         """
         return self._stack_id
 
     @stack_id.setter
     def stack_id(self, stack_id):
         """Sets the stack_id of this UpdateStackRequestBody.
 
-        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400 
+        资源栈（stack）的唯一Id。  此Id由资源编排服务在生成资源栈的时候生成，为UUID。  由于资源栈名仅仅在同一时间下唯一，即用户允许先生成一个叫HelloWorld的资源栈，删除，再重新创建一个同名资源栈。  对于团队并行开发，用户可能希望确保，当前我操作的资源栈就是我认为的那个，而不是其他队友删除后创建的同名资源栈。因此，使用ID就可以做到强匹配。  资源编排服务保证每次创建的资源栈所对应的ID都不相同，更新不会影响ID。如果给与的stack_id和当前资源栈的ID不一致，则返回400
 
         :param stack_id: The stack_id of this UpdateStackRequestBody.
         :type stack_id: str
         """
         self._stack_id = stack_id
 
     @property
     def enable_deletion_protection(self):
         """Gets the enable_deletion_protection of this UpdateStackRequestBody.
 
-        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新* 
+        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新*
 
         :return: The enable_deletion_protection of this UpdateStackRequestBody.
         :rtype: bool
         """
         return self._enable_deletion_protection
 
     @enable_deletion_protection.setter
     def enable_deletion_protection(self, enable_deletion_protection):
         """Sets the enable_deletion_protection of this UpdateStackRequestBody.
 
-        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新* 
+        删除保护的标识位，如果不传默认为false，即默认不开启资源栈删除保护（删除保护开启后资源栈不允许被删除）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的删除保护属性进行更新*
 
         :param enable_deletion_protection: The enable_deletion_protection of this UpdateStackRequestBody.
         :type enable_deletion_protection: bool
         """
         self._enable_deletion_protection = enable_deletion_protection
 
     @property
     def enable_auto_rollback(self):
         """Gets the enable_auto_rollback of this UpdateStackRequestBody.
 
-        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新* 
+        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新*
 
         :return: The enable_auto_rollback of this UpdateStackRequestBody.
         :rtype: bool
         """
         return self._enable_auto_rollback
 
     @enable_auto_rollback.setter
     def enable_auto_rollback(self, enable_auto_rollback):
         """Sets the enable_auto_rollback of this UpdateStackRequestBody.
 
-        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新* 
+        自动回滚的标识位，如果不传默认为false，即默认不开启资源栈自动回滚（自动回滚开启后，如果部署失败，则会自动回滚，并返回上一个稳定状态）  *在UpdateStack API中，若该参数未在RequestBody中给予，则不会对资源栈的自动回滚属性进行更新*
 
         :param enable_auto_rollback: The enable_auto_rollback of this UpdateStackRequestBody.
         :type enable_auto_rollback: bool
         """
         self._enable_auto_rollback = enable_auto_rollback
 
     @property
     def agencies(self):
         """Gets the agencies of this UpdateStackRequestBody.
 
-        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。 
+        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。
 
         :return: The agencies of this UpdateStackRequestBody.
         :rtype: list[:class:`huaweicloudsdkaos.v1.Agency`]
         """
         return self._agencies
 
     @agencies.setter
     def agencies(self, agencies):
         """Sets the agencies of this UpdateStackRequestBody.
 
-        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。 
+        委托授权的信息。  RFS仅在创建资源栈（触发部署）、创建执行计划、部署资源栈、删除资源栈等涉及资源操作的请求中使用委托，且该委托仅作用于与之绑定的Provider对资源的操作中。若委托中提供的权限不足，有可能导致相关资源操作失败。
 
         :param agencies: The agencies of this UpdateStackRequestBody.
         :type agencies: list[:class:`huaweicloudsdkaos.v1.Agency`]
         """
         self._agencies = agencies
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/variable_response.py

```diff
@@ -37,25 +37,25 @@
     }
 
     def __init__(self, name=None, type=None, description=None, default=None, sensitive=None, nullable=None, validations=None):
         """VariableResponse
 
         The model defined in huaweicloud sdk
 
-        :param name: 参数的名字  以HCL格式的模板为例，name 为 &#x60;my_hello_world_variable&#x60;  &#x60;&#x60;&#x60;hcl variable \&quot;my_hello_world_variable\&quot; {   type &#x3D; string   description &#x3D; \&quot;this is a variable\&quot;   default &#x3D; \&quot;hello world\&quot;   sensitive &#x3D; false   nullable &#x3D; false   validation {     condition     &#x3D; length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \&quot;hello\&quot;     error_message &#x3D; \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;   } } &#x60;&#x60;&#x60;  以json格式的模板为例，name 为 &#x60;my_hello_world_variable&#x60;  &#x60;&#x60;&#x60;json {   \&quot;variable\&quot;: {     \&quot;my_hello_world_variable\&quot;: [       {         \&quot;default\&quot;: \&quot;hello world\&quot;,         \&quot;description\&quot;: \&quot;this is a variable\&quot;,         \&quot;nullable\&quot;: false,         \&quot;sensitive\&quot;: false,         \&quot;type\&quot;: \&quot;string\&quot;,         \&quot;validation\&quot;: [           {             \&quot;condition\&quot;: \&quot;${length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \\\&quot;hello\\\&quot;}\&quot;,             \&quot;error_message\&quot;: \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;           }         ]       }     ]   } } &#x60;&#x60;&#x60; 
+        :param name: 参数的名字  以HCL格式的模板为例，name 为 &#x60;my_hello_world_variable&#x60;  &#x60;&#x60;&#x60;hcl variable \&quot;my_hello_world_variable\&quot; {   type &#x3D; string   description &#x3D; \&quot;this is a variable\&quot;   default &#x3D; \&quot;hello world\&quot;   sensitive &#x3D; false   nullable &#x3D; false   validation {     condition     &#x3D; length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \&quot;hello\&quot;     error_message &#x3D; \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;   } } &#x60;&#x60;&#x60;  以json格式的模板为例，name 为 &#x60;my_hello_world_variable&#x60;  &#x60;&#x60;&#x60;json {   \&quot;variable\&quot;: {     \&quot;my_hello_world_variable\&quot;: [       {         \&quot;default\&quot;: \&quot;hello world\&quot;,         \&quot;description\&quot;: \&quot;this is a variable\&quot;,         \&quot;nullable\&quot;: false,         \&quot;sensitive\&quot;: false,         \&quot;type\&quot;: \&quot;string\&quot;,         \&quot;validation\&quot;: [           {             \&quot;condition\&quot;: \&quot;${length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \\\&quot;hello\\\&quot;}\&quot;,             \&quot;error_message\&quot;: \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;           }         ]       }     ]   } } &#x60;&#x60;&#x60;
         :type name: str
-        :param type: 参数的类型  以HCL格式的模板为例，type 为 &#x60;string&#x60;  &#x60;&#x60;&#x60;hcl variable \&quot;my_hello_world_variable\&quot; {   type &#x3D; string   description &#x3D; \&quot;this is a variable\&quot;   default &#x3D; \&quot;hello world\&quot;   sensitive &#x3D; false   nullable &#x3D; false   validation {     condition     &#x3D; length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \&quot;hello\&quot;     error_message &#x3D; \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;   } } &#x60;&#x60;&#x60;  以json格式的模板为例，type 为 &#x60;string&#x60;  &#x60;&#x60;&#x60;json {   \&quot;variable\&quot;: {     \&quot;my_hello_world_variable\&quot;: [       {         \&quot;default\&quot;: \&quot;hello world\&quot;,         \&quot;description\&quot;: \&quot;this is a variable\&quot;,         \&quot;nullable\&quot;: false,         \&quot;sensitive\&quot;: false,         \&quot;type\&quot;: \&quot;string\&quot;,         \&quot;validation\&quot;: [           {             \&quot;condition\&quot;: \&quot;${length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \\\&quot;hello\\\&quot;}\&quot;,             \&quot;error_message\&quot;: \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;           }         ]       }     ]   } } &#x60;&#x60;&#x60; 
+        :param type: 参数的类型  以HCL格式的模板为例，type 为 &#x60;string&#x60;  &#x60;&#x60;&#x60;hcl variable \&quot;my_hello_world_variable\&quot; {   type &#x3D; string   description &#x3D; \&quot;this is a variable\&quot;   default &#x3D; \&quot;hello world\&quot;   sensitive &#x3D; false   nullable &#x3D; false   validation {     condition     &#x3D; length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \&quot;hello\&quot;     error_message &#x3D; \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;   } } &#x60;&#x60;&#x60;  以json格式的模板为例，type 为 &#x60;string&#x60;  &#x60;&#x60;&#x60;json {   \&quot;variable\&quot;: {     \&quot;my_hello_world_variable\&quot;: [       {         \&quot;default\&quot;: \&quot;hello world\&quot;,         \&quot;description\&quot;: \&quot;this is a variable\&quot;,         \&quot;nullable\&quot;: false,         \&quot;sensitive\&quot;: false,         \&quot;type\&quot;: \&quot;string\&quot;,         \&quot;validation\&quot;: [           {             \&quot;condition\&quot;: \&quot;${length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \\\&quot;hello\\\&quot;}\&quot;,             \&quot;error_message\&quot;: \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;           }         ]       }     ]   } } &#x60;&#x60;&#x60;
         :type type: str
-        :param description: 参数的描述  以HCL格式的模板为例，description 为 &#x60;this is a variable&#x60;  &#x60;&#x60;&#x60;hcl variable \&quot;my_hello_world_variable\&quot; {   type &#x3D; string   description &#x3D; \&quot;this is a variable\&quot;   default &#x3D; \&quot;hello world\&quot;   sensitive &#x3D; false   nullable &#x3D; false   validation {     condition     &#x3D; length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \&quot;hello\&quot;     error_message &#x3D; \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;   } } &#x60;&#x60;&#x60;  以json格式的模板为例，description 为 &#x60;this is a variable&#x60;  &#x60;&#x60;&#x60;json {   \&quot;variable\&quot;: {     \&quot;my_hello_world_variable\&quot;: [       {         \&quot;default\&quot;: \&quot;hello world\&quot;,         \&quot;description\&quot;: \&quot;this is a variable\&quot;,         \&quot;nullable\&quot;: false,         \&quot;sensitive\&quot;: false,         \&quot;type\&quot;: \&quot;string\&quot;,         \&quot;validation\&quot;: [           {             \&quot;condition\&quot;: \&quot;${length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \\\&quot;hello\\\&quot;}\&quot;,             \&quot;error_message\&quot;: \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;           }         ]       }     ]   } } &#x60;&#x60;&#x60; 
+        :param description: 参数的描述  以HCL格式的模板为例，description 为 &#x60;this is a variable&#x60;  &#x60;&#x60;&#x60;hcl variable \&quot;my_hello_world_variable\&quot; {   type &#x3D; string   description &#x3D; \&quot;this is a variable\&quot;   default &#x3D; \&quot;hello world\&quot;   sensitive &#x3D; false   nullable &#x3D; false   validation {     condition     &#x3D; length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \&quot;hello\&quot;     error_message &#x3D; \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;   } } &#x60;&#x60;&#x60;  以json格式的模板为例，description 为 &#x60;this is a variable&#x60;  &#x60;&#x60;&#x60;json {   \&quot;variable\&quot;: {     \&quot;my_hello_world_variable\&quot;: [       {         \&quot;default\&quot;: \&quot;hello world\&quot;,         \&quot;description\&quot;: \&quot;this is a variable\&quot;,         \&quot;nullable\&quot;: false,         \&quot;sensitive\&quot;: false,         \&quot;type\&quot;: \&quot;string\&quot;,         \&quot;validation\&quot;: [           {             \&quot;condition\&quot;: \&quot;${length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \\\&quot;hello\\\&quot;}\&quot;,             \&quot;error_message\&quot;: \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;           }         ]       }     ]   } } &#x60;&#x60;&#x60;
         :type description: str
-        :param default: 参数默认值。此返回值的类型将与type保持一致  例如，对于type为string的变量，此值的返回类型为string；对于type为number的变量，此值的返回类型为number  以HCL格式的模板为例，default 为 &#x60;hello world&#x60;  &#x60;&#x60;&#x60;hcl variable \&quot;my_hello_world_variable\&quot; {   type &#x3D; string   description &#x3D; \&quot;this is a variable\&quot;   default &#x3D; \&quot;hello world\&quot;   sensitive &#x3D; false   nullable &#x3D; false   validation {     condition     &#x3D; length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \&quot;hello\&quot;     error_message &#x3D; \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;   } } &#x60;&#x60;&#x60;  以json格式的模板为例，default 为 &#x60;hello world&#x60;  &#x60;&#x60;&#x60;json {   \&quot;variable\&quot;: {     \&quot;my_hello_world_variable\&quot;: [       {         \&quot;default\&quot;: \&quot;hello world\&quot;,         \&quot;description\&quot;: \&quot;this is a variable\&quot;,         \&quot;nullable\&quot;: false,         \&quot;sensitive\&quot;: false,         \&quot;type\&quot;: \&quot;string\&quot;,         \&quot;validation\&quot;: [           {             \&quot;condition\&quot;: \&quot;${length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \\\&quot;hello\\\&quot;}\&quot;,             \&quot;error_message\&quot;: \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;           }         ]       }     ]   } } &#x60;&#x60;&#x60; 
+        :param default: 参数默认值。此返回值的类型将与type保持一致  例如，对于type为string的变量，此值的返回类型为string；对于type为number的变量，此值的返回类型为number  以HCL格式的模板为例，default 为 &#x60;hello world&#x60;  &#x60;&#x60;&#x60;hcl variable \&quot;my_hello_world_variable\&quot; {   type &#x3D; string   description &#x3D; \&quot;this is a variable\&quot;   default &#x3D; \&quot;hello world\&quot;   sensitive &#x3D; false   nullable &#x3D; false   validation {     condition     &#x3D; length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \&quot;hello\&quot;     error_message &#x3D; \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;   } } &#x60;&#x60;&#x60;  以json格式的模板为例，default 为 &#x60;hello world&#x60;  &#x60;&#x60;&#x60;json {   \&quot;variable\&quot;: {     \&quot;my_hello_world_variable\&quot;: [       {         \&quot;default\&quot;: \&quot;hello world\&quot;,         \&quot;description\&quot;: \&quot;this is a variable\&quot;,         \&quot;nullable\&quot;: false,         \&quot;sensitive\&quot;: false,         \&quot;type\&quot;: \&quot;string\&quot;,         \&quot;validation\&quot;: [           {             \&quot;condition\&quot;: \&quot;${length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \\\&quot;hello\\\&quot;}\&quot;,             \&quot;error_message\&quot;: \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;           }         ]       }     ]   } } &#x60;&#x60;&#x60;
         :type default: object
-        :param sensitive: 参数是否为敏感字段  若variable中没有定义sensitive，默认返回false。  以HCL格式的模板为例，sensitive 为 &#x60;false&#x60;  &#x60;&#x60;&#x60;hcl variable \&quot;my_hello_world_variable\&quot; {   type &#x3D; string   description &#x3D; \&quot;this is a variable\&quot;   default &#x3D; \&quot;hello world\&quot;   sensitive &#x3D; false   nullable &#x3D; false   validation {     condition     &#x3D; length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \&quot;hello\&quot;     error_message &#x3D; \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;   } } &#x60;&#x60;&#x60;  以json格式的模板为例，sensitive 为 &#x60;false&#x60;  &#x60;&#x60;&#x60;json {   \&quot;variable\&quot;: {     \&quot;my_hello_world_variable\&quot;: [       {         \&quot;default\&quot;: \&quot;hello world\&quot;,         \&quot;description\&quot;: \&quot;this is a variable\&quot;,         \&quot;nullable\&quot;: false,         \&quot;sensitive\&quot;: false,         \&quot;type\&quot;: \&quot;string\&quot;,         \&quot;validation\&quot;: [           {             \&quot;condition\&quot;: \&quot;${length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \\\&quot;hello\\\&quot;}\&quot;,             \&quot;error_message\&quot;: \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;           }         ]       }     ]   } } &#x60;&#x60;&#x60; 
+        :param sensitive: 参数是否为敏感字段  若variable中没有定义sensitive，默认返回false。  以HCL格式的模板为例，sensitive 为 &#x60;false&#x60;  &#x60;&#x60;&#x60;hcl variable \&quot;my_hello_world_variable\&quot; {   type &#x3D; string   description &#x3D; \&quot;this is a variable\&quot;   default &#x3D; \&quot;hello world\&quot;   sensitive &#x3D; false   nullable &#x3D; false   validation {     condition     &#x3D; length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \&quot;hello\&quot;     error_message &#x3D; \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;   } } &#x60;&#x60;&#x60;  以json格式的模板为例，sensitive 为 &#x60;false&#x60;  &#x60;&#x60;&#x60;json {   \&quot;variable\&quot;: {     \&quot;my_hello_world_variable\&quot;: [       {         \&quot;default\&quot;: \&quot;hello world\&quot;,         \&quot;description\&quot;: \&quot;this is a variable\&quot;,         \&quot;nullable\&quot;: false,         \&quot;sensitive\&quot;: false,         \&quot;type\&quot;: \&quot;string\&quot;,         \&quot;validation\&quot;: [           {             \&quot;condition\&quot;: \&quot;${length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \\\&quot;hello\\\&quot;}\&quot;,             \&quot;error_message\&quot;: \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;           }         ]       }     ]   } } &#x60;&#x60;&#x60;
         :type sensitive: bool
-        :param nullable: 参数是否可设置为null。  若variable中没有定义nullable，默认返回true。  以HCL格式的模板为例，nullable 为 &#x60;false&#x60;  &#x60;&#x60;&#x60;hcl variable \&quot;my_hello_world_variable\&quot; {   type &#x3D; string   description &#x3D; \&quot;this is a variable\&quot;   default &#x3D; \&quot;hello world\&quot;   sensitive &#x3D; false   nullable &#x3D; false   validation {     condition     &#x3D; length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \&quot;hello\&quot;     error_message &#x3D; \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;   } } &#x60;&#x60;&#x60;  以json格式的模板为例，nullable 为 &#x60;false&#x60;  &#x60;&#x60;&#x60;json {   \&quot;variable\&quot;: {     \&quot;my_hello_world_variable\&quot;: [       {         \&quot;default\&quot;: \&quot;hello world\&quot;,         \&quot;description\&quot;: \&quot;this is a variable\&quot;,         \&quot;nullable\&quot;: false,         \&quot;sensitive\&quot;: false,         \&quot;type\&quot;: \&quot;string\&quot;,         \&quot;validation\&quot;: [           {             \&quot;condition\&quot;: \&quot;${length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \\\&quot;hello\\\&quot;}\&quot;,             \&quot;error_message\&quot;: \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;           }         ]       }     ]   } } &#x60;&#x60;&#x60; 
+        :param nullable: 参数是否可设置为null。  若variable中没有定义nullable，默认返回true。  以HCL格式的模板为例，nullable 为 &#x60;false&#x60;  &#x60;&#x60;&#x60;hcl variable \&quot;my_hello_world_variable\&quot; {   type &#x3D; string   description &#x3D; \&quot;this is a variable\&quot;   default &#x3D; \&quot;hello world\&quot;   sensitive &#x3D; false   nullable &#x3D; false   validation {     condition     &#x3D; length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \&quot;hello\&quot;     error_message &#x3D; \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;   } } &#x60;&#x60;&#x60;  以json格式的模板为例，nullable 为 &#x60;false&#x60;  &#x60;&#x60;&#x60;json {   \&quot;variable\&quot;: {     \&quot;my_hello_world_variable\&quot;: [       {         \&quot;default\&quot;: \&quot;hello world\&quot;,         \&quot;description\&quot;: \&quot;this is a variable\&quot;,         \&quot;nullable\&quot;: false,         \&quot;sensitive\&quot;: false,         \&quot;type\&quot;: \&quot;string\&quot;,         \&quot;validation\&quot;: [           {             \&quot;condition\&quot;: \&quot;${length(var.my_hello_world_variable) &gt; 0 &amp;&amp; substr(var.my_hello_world_variable, 0, 5) &#x3D;&#x3D; \\\&quot;hello\\\&quot;}\&quot;,             \&quot;error_message\&quot;: \&quot;my_hello_world_variable should start with &#39;hello&#39;.\&quot;           }         ]       }     ]   } } &#x60;&#x60;&#x60;
         :type nullable: bool
         :param validations: 参数的校验模块
         :type validations: list[:class:`huaweicloudsdkaos.v1.VariableValidationResponse`]
         """
         
         
 
@@ -83,136 +83,136 @@
         if validations is not None:
             self.validations = validations
 
     @property
     def name(self):
         """Gets the name of this VariableResponse.
 
-        参数的名字  以HCL格式的模板为例，name 为 `my_hello_world_variable`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，name 为 `my_hello_world_variable`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ``` 
+        参数的名字  以HCL格式的模板为例，name 为 `my_hello_world_variable`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，name 为 `my_hello_world_variable`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ```
 
         :return: The name of this VariableResponse.
         :rtype: str
         """
         return self._name
 
     @name.setter
     def name(self, name):
         """Sets the name of this VariableResponse.
 
-        参数的名字  以HCL格式的模板为例，name 为 `my_hello_world_variable`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，name 为 `my_hello_world_variable`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ``` 
+        参数的名字  以HCL格式的模板为例，name 为 `my_hello_world_variable`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，name 为 `my_hello_world_variable`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ```
 
         :param name: The name of this VariableResponse.
         :type name: str
         """
         self._name = name
 
     @property
     def type(self):
         """Gets the type of this VariableResponse.
 
-        参数的类型  以HCL格式的模板为例，type 为 `string`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，type 为 `string`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ``` 
+        参数的类型  以HCL格式的模板为例，type 为 `string`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，type 为 `string`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ```
 
         :return: The type of this VariableResponse.
         :rtype: str
         """
         return self._type
 
     @type.setter
     def type(self, type):
         """Sets the type of this VariableResponse.
 
-        参数的类型  以HCL格式的模板为例，type 为 `string`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，type 为 `string`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ``` 
+        参数的类型  以HCL格式的模板为例，type 为 `string`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，type 为 `string`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ```
 
         :param type: The type of this VariableResponse.
         :type type: str
         """
         self._type = type
 
     @property
     def description(self):
         """Gets the description of this VariableResponse.
 
-        参数的描述  以HCL格式的模板为例，description 为 `this is a variable`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，description 为 `this is a variable`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ``` 
+        参数的描述  以HCL格式的模板为例，description 为 `this is a variable`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，description 为 `this is a variable`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ```
 
         :return: The description of this VariableResponse.
         :rtype: str
         """
         return self._description
 
     @description.setter
     def description(self, description):
         """Sets the description of this VariableResponse.
 
-        参数的描述  以HCL格式的模板为例，description 为 `this is a variable`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，description 为 `this is a variable`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ``` 
+        参数的描述  以HCL格式的模板为例，description 为 `this is a variable`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，description 为 `this is a variable`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ```
 
         :param description: The description of this VariableResponse.
         :type description: str
         """
         self._description = description
 
     @property
     def default(self):
         """Gets the default of this VariableResponse.
 
-        参数默认值。此返回值的类型将与type保持一致  例如，对于type为string的变量，此值的返回类型为string；对于type为number的变量，此值的返回类型为number  以HCL格式的模板为例，default 为 `hello world`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，default 为 `hello world`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ``` 
+        参数默认值。此返回值的类型将与type保持一致  例如，对于type为string的变量，此值的返回类型为string；对于type为number的变量，此值的返回类型为number  以HCL格式的模板为例，default 为 `hello world`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，default 为 `hello world`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ```
 
         :return: The default of this VariableResponse.
         :rtype: object
         """
         return self._default
 
     @default.setter
     def default(self, default):
         """Sets the default of this VariableResponse.
 
-        参数默认值。此返回值的类型将与type保持一致  例如，对于type为string的变量，此值的返回类型为string；对于type为number的变量，此值的返回类型为number  以HCL格式的模板为例，default 为 `hello world`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，default 为 `hello world`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ``` 
+        参数默认值。此返回值的类型将与type保持一致  例如，对于type为string的变量，此值的返回类型为string；对于type为number的变量，此值的返回类型为number  以HCL格式的模板为例，default 为 `hello world`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，default 为 `hello world`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ```
 
         :param default: The default of this VariableResponse.
         :type default: object
         """
         self._default = default
 
     @property
     def sensitive(self):
         """Gets the sensitive of this VariableResponse.
 
-        参数是否为敏感字段  若variable中没有定义sensitive，默认返回false。  以HCL格式的模板为例，sensitive 为 `false`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，sensitive 为 `false`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ``` 
+        参数是否为敏感字段  若variable中没有定义sensitive，默认返回false。  以HCL格式的模板为例，sensitive 为 `false`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，sensitive 为 `false`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ```
 
         :return: The sensitive of this VariableResponse.
         :rtype: bool
         """
         return self._sensitive
 
     @sensitive.setter
     def sensitive(self, sensitive):
         """Sets the sensitive of this VariableResponse.
 
-        参数是否为敏感字段  若variable中没有定义sensitive，默认返回false。  以HCL格式的模板为例，sensitive 为 `false`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，sensitive 为 `false`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ``` 
+        参数是否为敏感字段  若variable中没有定义sensitive，默认返回false。  以HCL格式的模板为例，sensitive 为 `false`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，sensitive 为 `false`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ```
 
         :param sensitive: The sensitive of this VariableResponse.
         :type sensitive: bool
         """
         self._sensitive = sensitive
 
     @property
     def nullable(self):
         """Gets the nullable of this VariableResponse.
 
-        参数是否可设置为null。  若variable中没有定义nullable，默认返回true。  以HCL格式的模板为例，nullable 为 `false`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，nullable 为 `false`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ``` 
+        参数是否可设置为null。  若variable中没有定义nullable，默认返回true。  以HCL格式的模板为例，nullable 为 `false`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，nullable 为 `false`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ```
 
         :return: The nullable of this VariableResponse.
         :rtype: bool
         """
         return self._nullable
 
     @nullable.setter
     def nullable(self, nullable):
         """Sets the nullable of this VariableResponse.
 
-        参数是否可设置为null。  若variable中没有定义nullable，默认返回true。  以HCL格式的模板为例，nullable 为 `false`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，nullable 为 `false`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ``` 
+        参数是否可设置为null。  若variable中没有定义nullable，默认返回true。  以HCL格式的模板为例，nullable 为 `false`  ```hcl variable \"my_hello_world_variable\" {   type = string   description = \"this is a variable\"   default = \"hello world\"   sensitive = false   nullable = false   validation {     condition     = length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \"hello\"     error_message = \"my_hello_world_variable should start with 'hello'.\"   } } ```  以json格式的模板为例，nullable 为 `false`  ```json {   \"variable\": {     \"my_hello_world_variable\": [       {         \"default\": \"hello world\",         \"description\": \"this is a variable\",         \"nullable\": false,         \"sensitive\": false,         \"type\": \"string\",         \"validation\": [           {             \"condition\": \"${length(var.my_hello_world_variable) > 0 && substr(var.my_hello_world_variable, 0, 5) == \\\"hello\\\"}\",             \"error_message\": \"my_hello_world_variable should start with 'hello'.\"           }         ]       }     ]   } } ```
 
         :param nullable: The nullable of this VariableResponse.
         :type nullable: bool
         """
         self._nullable = nullable
 
     @property
```

## huaweicloudsdkaos/v1/model/vars_body_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, vars_body=None):
         """VarsBodyPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param vars_body: HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        :param vars_body: HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
         :type vars_body: str
         """
         
         
 
         self._vars_body = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if vars_body is not None:
             self.vars_body = vars_body
 
     @property
     def vars_body(self):
         """Gets the vars_body of this VarsBodyPrimitiveTypeHolder.
 
-        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :return: The vars_body of this VarsBodyPrimitiveTypeHolder.
         :rtype: str
         """
         return self._vars_body
 
     @vars_body.setter
     def vars_body(self, vars_body):
         """Sets the vars_body of this VarsBodyPrimitiveTypeHolder.
 
-        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的内容。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * vars_body使用HCL的tfvars格式，用户可以将“.tfvars”中的内容提交到vars_body中。  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * 如果vars_body过大，可以使用vars_uri  * 如果vars中都是简单的字符串格式，可以使用var_structure  * 注意：vars_body中不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :param vars_body: The vars_body of this VarsBodyPrimitiveTypeHolder.
         :type vars_body: str
         """
         self._vars_body = vars_body
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/vars_structure.py

```diff
@@ -31,15 +31,15 @@
     def __init__(self, var_key=None, var_value=None, encryption=None):
         """VarsStructure
 
         The model defined in huaweicloud sdk
 
         :param var_key: 参数的名字
         :type var_key: str
-        :param var_value: 参数的值。  注意，参数需要以字符串形式存在，如果是数字，也需要以字符串形式存在，如&#39;10&#39;。  如果需要支持不同类型，或者复杂结构，请使用vars_uri或vars_body 
+        :param var_value: 参数的值。  注意，参数需要以字符串形式存在，如果是数字，也需要以字符串形式存在，如&#39;10&#39;。  如果需要支持不同类型，或者复杂结构，请使用vars_uri或vars_body
         :type var_value: str
         :param encryption: 
         :type encryption: :class:`huaweicloudsdkaos.v1.EncryptionStructure`
         """
         
         
 
@@ -75,26 +75,26 @@
         """
         self._var_key = var_key
 
     @property
     def var_value(self):
         """Gets the var_value of this VarsStructure.
 
-        参数的值。  注意，参数需要以字符串形式存在，如果是数字，也需要以字符串形式存在，如'10'。  如果需要支持不同类型，或者复杂结构，请使用vars_uri或vars_body 
+        参数的值。  注意，参数需要以字符串形式存在，如果是数字，也需要以字符串形式存在，如'10'。  如果需要支持不同类型，或者复杂结构，请使用vars_uri或vars_body
 
         :return: The var_value of this VarsStructure.
         :rtype: str
         """
         return self._var_value
 
     @var_value.setter
     def var_value(self, var_value):
         """Sets the var_value of this VarsStructure.
 
-        参数的值。  注意，参数需要以字符串形式存在，如果是数字，也需要以字符串形式存在，如'10'。  如果需要支持不同类型，或者复杂结构，请使用vars_uri或vars_body 
+        参数的值。  注意，参数需要以字符串形式存在，如果是数字，也需要以字符串形式存在，如'10'。  如果需要支持不同类型，或者复杂结构，请使用vars_uri或vars_body
 
         :param var_value: The var_value of this VarsStructure.
         :type var_value: str
         """
         self._var_value = var_value
 
     @property
```

## huaweicloudsdkaos/v1/model/vars_structure_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, vars_structure=None):
         """VarsStructurePrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param vars_structure: HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        :param vars_structure: HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
         :type vars_structure: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         
         
 
         self._vars_structure = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if vars_structure is not None:
             self.vars_structure = vars_structure
 
     @property
     def vars_structure(self):
         """Gets the vars_structure of this VarsStructurePrimitiveTypeHolder.
 
-        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
 
         :return: The vars_structure of this VarsStructurePrimitiveTypeHolder.
         :rtype: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         return self._vars_structure
 
     @vars_structure.setter
     def vars_structure(self, vars_structure):
         """Sets the vars_structure of this VarsStructurePrimitiveTypeHolder.
 
-        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密 
+        HCL参数结构。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  * var_structure可以允许客户提交最简单的字符串类型的参数  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400  * vars_structure中的值只支持简单的字符串类型，如果需要使用其他类型，需要用户自己在HCL引用时转换， 或者用户可以使用vars_uri、vars_body，vars_uri和vars_body中支持HCL支持的各种类型以及复杂结构  * 如果vars_structure过大，可以使用vars_uri  * 注意：vars_structure中默认不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议设置encryption字段开启加密
 
         :param vars_structure: The vars_structure of this VarsStructurePrimitiveTypeHolder.
         :type vars_structure: list[:class:`huaweicloudsdkaos.v1.VarsStructure`]
         """
         self._vars_structure = vars_structure
 
     def to_dict(self):
```

## huaweicloudsdkaos/v1/model/vars_uri_primitive_type_holder.py

```diff
@@ -25,15 +25,15 @@
     }
 
     def __init__(self, vars_uri=None):
         """VarsURIPrimitiveTypeHolder
 
         The model defined in huaweicloud sdk
 
-        :param vars_uri: HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        :param vars_uri: HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
         :type vars_uri: str
         """
         
         
 
         self._vars_uri = None
         self.discriminator = None
@@ -41,26 +41,26 @@
         if vars_uri is not None:
             self.vars_uri = vars_uri
 
     @property
     def vars_uri(self):
         """Gets the vars_uri of this VarsURIPrimitiveTypeHolder.
 
-        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :return: The vars_uri of this VarsURIPrimitiveTypeHolder.
         :rtype: str
         """
         return self._vars_uri
 
     @vars_uri.setter
     def vars_uri(self, vars_uri):
         """Sets the vars_uri of this VarsURIPrimitiveTypeHolder.
 
-        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递 
+        HCL参数文件的OBS地址。HCL模板支持参数传入，即，同一个模板可以给予不同的参数而达到不同的效果。  OBS地址支持同类型Region之间进行互相访问（Region分为通用Region和专属Region，通用Region指面向公共租户提供通用云服务的Region；专属Region指只承载同一类业务或只面向特定租户提供业务服务的专用Region）  * 资源编排服务支持vars_structure，vars_body和vars_uri，如果他们中声名了同一个变量，将报错400 * vars_uri中的内容使用HCL的tfvars格式，用户可以将“.tfvars”中的内容保存到文件并上传到OBS中，并将OBS pre-signed URL传递给vars_uri。 * 注意：vars_uri的内容不应该含有任何敏感信息，资源编排服务会直接明文使用、log、展示、存储对应的vars。如为敏感信息，建议通过vars_structure并设置encryption字段传递
 
         :param vars_uri: The vars_uri of this VarsURIPrimitiveTypeHolder.
         :type vars_uri: str
         """
         self._vars_uri = vars_uri
 
     def to_dict(self):
```

## Comparing `huaweicloudsdkaos-3.1.47.dist-info/LICENSE` & `huaweicloudsdkaos-3.1.48.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `huaweicloudsdkaos-3.1.47.dist-info/METADATA` & `huaweicloudsdkaos-3.1.48.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: huaweicloudsdkaos
-Version: 3.1.47
+Version: 3.1.48
 Summary: AOS
 Home-page: https://github.com/huaweicloud/huaweicloud-sdk-python-v3
 Author: HuaweiCloud SDK
 Author-email: hwcloudsdk@huawei.com
 License: Apache LICENSE 2.0
 Keywords: huaweicloud,sdk,AOS
 Classifier: Development Status :: 5 - Production/Stable
@@ -18,10 +18,10 @@
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Topic :: Software Development
 Requires-Python: >=2.7,!=3.0.*,!=3.1.*,!=3.2.*
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: huaweicloudsdkcore (>=3.1.47)
+Requires-Dist: huaweicloudsdkcore (>=3.1.48)
 
 See detailed information in [huaweicloud-sdk-python-v3](https://github.com/huaweicloud/huaweicloud-sdk-python-v3).
```

## Comparing `huaweicloudsdkaos-3.1.47.dist-info/RECORD` & `huaweicloudsdkaos-3.1.48.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,121 +1,121 @@
 huaweicloudsdkaos/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-huaweicloudsdkaos/v1/__init__.py,sha256=U1fmNM2dEeiPg6aMgrn5JDVQrm9chCYCl_NxiBbkHM0,10498
-huaweicloudsdkaos/v1/aos_async_client.py,sha256=BAfB2ODLH4wxzDimdoFtiH9DJCVztTtWT6841NScme0,83506
-huaweicloudsdkaos/v1/aos_client.py,sha256=-pR1cumnhWK-lrzhW4IAMnr6l7s3SXa_EBgYGBor9VQ,83263
+huaweicloudsdkaos/v1/__init__.py,sha256=UMAWQL5hKgQLmd-awJW4VQsB8rKpYK040aNvZ1DjVyw,10447
+huaweicloudsdkaos/v1/aos_async_client.py,sha256=KZBbtxDol93RC2Ebv1K1Dk9noh1u3gKr8ynEEfHNOt4,87676
+huaweicloudsdkaos/v1/aos_client.py,sha256=t60U4F45tpXP9LNggpIvJOcpmTptCx401mQAYCFTam4,87433
 huaweicloudsdkaos/v1/model/__init__.py,sha256=BEdatBIxBcT4KM2ORR6Tp7HrbqTU6-z0l-uUcIBgEqw,10361
-huaweicloudsdkaos/v1/model/agencies_primitive_type_holder.py,sha256=AczHGkKyApM9F57YBYWhT79Nj3oHBCVlcBGJb6VZQZ0,4189
+huaweicloudsdkaos/v1/model/agencies_primitive_type_holder.py,sha256=LbbipkFdKQMHPGj25iKst7TGOk4WhhM6uOt65ZxOTnI,4186
 huaweicloudsdkaos/v1/model/agency.py,sha256=murIfHOfoYqHI7n69-Tqg2zYRD6RttBbm_yI5uRbzRA,4416
 huaweicloudsdkaos/v1/model/apply_execution_plan_request.py,sha256=H0rBcH5-vvg3Y0adFO_nOAxN28I0SqJOopDdMwuy2WE,7325
-huaweicloudsdkaos/v1/model/apply_execution_plan_request_body.py,sha256=IogWoPvUIbm5b4ylN_5izJZDrah4Ram4LDXEYQp6-_Y,8119
-huaweicloudsdkaos/v1/model/apply_execution_plan_response.py,sha256=mo91O68W0cCMUBTkz6mS-HiXVO57WUp8kBRaolfmuPE,3645
+huaweicloudsdkaos/v1/model/apply_execution_plan_request_body.py,sha256=mMP-dW58OXdXo72iUxAIKcOT2xial6OWtJGRI5jXmn4,8113
+huaweicloudsdkaos/v1/model/apply_execution_plan_response.py,sha256=0-sDWG9MZocViFdQzMuh3pyxGuAsb82pVsyq_M7HFRE,3642
 huaweicloudsdkaos/v1/model/base_template.py,sha256=0xkbyW8yW2Us6SGLD-f7rACU1XyGXCRGSI-5YJvKErA,7177
 huaweicloudsdkaos/v1/model/base_template_version.py,sha256=iqVVIipwTFa63QkIwNSUyG6UnkLdbxIl8g1lZb1nglA,6305
 huaweicloudsdkaos/v1/model/continue_deploy_stack_request.py,sha256=s0xowb8qhIw0U-gqaesPLtXkH036dp-1RP3T7n72r0A,5754
-huaweicloudsdkaos/v1/model/continue_deploy_stack_request_body.py,sha256=dZHx-sne89EJ4h2iI2bpP_EtrMbefu_iTdtMVI3HADs,5068
+huaweicloudsdkaos/v1/model/continue_deploy_stack_request_body.py,sha256=SJ7AE3GEtXwl795nd81Vv_IMwS_zKCLMeJWqZ93jX8g,5065
 huaweicloudsdkaos/v1/model/continue_deploy_stack_response.py,sha256=QRn6zNHKunFJIHSSpZZsIGLIGmRUJt4tiJ7ScFnCwdE,3353
 huaweicloudsdkaos/v1/model/continue_rollback_stack_request.py,sha256=gZySggNjp3gU-2yPssuO-Qzab9Rzxab5JhAwD3f_NJM,5794
-huaweicloudsdkaos/v1/model/continue_rollback_stack_request_body.py,sha256=TXd5XwxCiNp9jToh6VTdYqGZYWvSubTGQsDug7n7OrY,5082
+huaweicloudsdkaos/v1/model/continue_rollback_stack_request_body.py,sha256=tPF_6wPxbdglep9uCKjGkMhgrWXGNmQAPkBNVYi7K78,5079
 huaweicloudsdkaos/v1/model/continue_rollback_stack_response.py,sha256=zvUYNW3xLUaLzToANGTFjN4g0O-vMonDkbS_xcDlKW8,3648
 huaweicloudsdkaos/v1/model/create_execution_plan_request.py,sha256=NrGBtW7DD47E-Ec9VrZgQXn0YaeD_IZ78s0x34ix9Fc,5754
-huaweicloudsdkaos/v1/model/create_execution_plan_request_body.py,sha256=rDIl35RpO4FFpq3clro2TeNxSfYXSaZxuCyGRh3dW3M,25127
-huaweicloudsdkaos/v1/model/create_execution_plan_response.py,sha256=tAyFg0aXZDZvYQZfgDdWPD-Z8thSvN8QhqcE6sBaA8Q,5509
+huaweicloudsdkaos/v1/model/create_execution_plan_request_body.py,sha256=-dBe402ZPozoFIdfNGztA8jJKNKENI6JOxyKTaNTJbE,25109
+huaweicloudsdkaos/v1/model/create_execution_plan_response.py,sha256=eeronM_Gia9R-28X-NzY99kbFVbTp6q5bTI2E_jQaYY,5506
 huaweicloudsdkaos/v1/model/create_stack_request.py,sha256=4k4w8Vk3GuqDPOeSKPZj8csOgbLij6YsYXDJyiJ3yXM,4265
-huaweicloudsdkaos/v1/model/create_stack_request_body.py,sha256=SiGZCA2KPL-KNKS8FpGkhOKxw7hmlvqpXClu8ncWpPw,27687
-huaweicloudsdkaos/v1/model/create_stack_response.py,sha256=gKjU0o7WANPomz8L7fqP9KDIsON03NWM6yI2Xcc67pA,5965
-huaweicloudsdkaos/v1/model/delete_execution_plan_request.py,sha256=p-WzR0yEDuoeMKbZp1s_pSMcWZM9eFiwyp59LnNknsU,12224
+huaweicloudsdkaos/v1/model/create_stack_request_body.py,sha256=uy_GFwnY40Djm2LsI1THRIx5ksd3vgN2TPiarpo5xHc,27663
+huaweicloudsdkaos/v1/model/create_stack_response.py,sha256=Ifcw54D28nxKX026et2NllfGlyb5dHWGs24sIgdpPV4,5962
+huaweicloudsdkaos/v1/model/delete_execution_plan_request.py,sha256=aBA458Six7ySTVxGnso_gcuKWG1RCrQcZdgElqDpg90,12218
 huaweicloudsdkaos/v1/model/delete_execution_plan_response.py,sha256=4CHmhzk-JsCy6mCXL0qkYyeSJghWPI0Geei3I18T2es,2459
-huaweicloudsdkaos/v1/model/delete_stack_request.py,sha256=FRwTUcUwOCoYwU18mGoB2UQOPSqvYUXUKcuuI_6gFl4,7463
+huaweicloudsdkaos/v1/model/delete_stack_request.py,sha256=0by3BLWg-7VQnYIMJ_qb9KkGlUvRk6Dr94IYbB6O2QE,7460
 huaweicloudsdkaos/v1/model/delete_stack_response.py,sha256=EDoFgmLpLCuVj7aiEsZHM_IU6wbepNd5vu_KOHQFg-A,2427
 huaweicloudsdkaos/v1/model/delete_template_request.py,sha256=XLv7CZKJCYnY0zHLOwbrleiClVLcCglDTJvFmUw4uxw,5558
 huaweicloudsdkaos/v1/model/delete_template_response.py,sha256=ysetgsjLJzYrNHKmn4Io8qBfE4zm26E386qPa4rrNZw,2439
 huaweicloudsdkaos/v1/model/delete_template_version_request.py,sha256=hGzukx9y12Ggsozs0sa4inNpCW0pCGqfSrtrCxW-S2o,6741
 huaweicloudsdkaos/v1/model/delete_template_version_response.py,sha256=FtK5Die5UWEMAQr1b6bZlWnlOfqVFF-bhL0nsAYyxnY,2467
 huaweicloudsdkaos/v1/model/deploy_stack_request.py,sha256=cZy5ZSqG14p7pZ3NIAr4RqEdV1EfNZR1bGwYviZRuyo,5594
-huaweicloudsdkaos/v1/model/deploy_stack_request_body.py,sha256=XQuhLapuvBLHQEtDIJd4JJfR3UiilryupM5KcjSbPlI,22257
+huaweicloudsdkaos/v1/model/deploy_stack_request_body.py,sha256=xOo7poyIjOWC0uLlH8CcSgC7CXr7nBp53-z3DguRkUo,22239
 huaweicloudsdkaos/v1/model/deploy_stack_response.py,sha256=gbNMJNnvC8w1COgQcfoTSSvX4hSGk0jyIAg3VU6DPw0,3289
-huaweicloudsdkaos/v1/model/deployment_id_primitive_type_holder.py,sha256=uG3VzM9hXy2y-n2J1P84KbKE36ASZ2JaZQH7zbt196k,3561
-huaweicloudsdkaos/v1/model/enable_auto_rollback_primitive_type_holder.py,sha256=OMIcvoaz9WCcTVBHMjyK1e7ldrt0kB93MYD_zcjHNNg,4407
-huaweicloudsdkaos/v1/model/enable_deletion_protection_primitive_type_holder.py,sha256=iPLtAfIXTrYCT5GckqvcFB53PkI0hvwNyN6aqd-KgC8,4443
+huaweicloudsdkaos/v1/model/deployment_id_primitive_type_holder.py,sha256=iZEDhZHbU0oSQ8AypHt9VkvXj1T5GWpxMGk5VjDjKvk,3558
+huaweicloudsdkaos/v1/model/enable_auto_rollback_primitive_type_holder.py,sha256=hSx7TwnSrOcj8PWFAMY3LNTTJb9kxp-euhVvrYproM8,4404
+huaweicloudsdkaos/v1/model/enable_deletion_protection_primitive_type_holder.py,sha256=ohNWIv-iC2hjDZKEbXhlvsu6DjOhIcqv8w5FFAWBhio,4440
 huaweicloudsdkaos/v1/model/encryption_structure.py,sha256=xa8hTqwMwzMfEc4pNI8Wjl1fK2DsE-PXmMncvwBApfw,2997
-huaweicloudsdkaos/v1/model/estimate_execution_plan_price_request.py,sha256=i0TXxVc792eOCnKBGXq33-PKdaxQiPge4fKLjVgXD5I,12385
-huaweicloudsdkaos/v1/model/estimate_execution_plan_price_response.py,sha256=D-ZGNTRvHEn-RVkPlhN0J7PqGeebBMBdYFo9C_NFC8g,4608
-huaweicloudsdkaos/v1/model/execution_plan.py,sha256=T-plETmrAjXPG7T6jbbg0NSF2xv_UljKulw3IzH9T34,17284
+huaweicloudsdkaos/v1/model/estimate_execution_plan_price_request.py,sha256=9E8o9ivveR_T5lIuyqsK3qaTwbs3fxUODo4brBpB1_Y,12379
+huaweicloudsdkaos/v1/model/estimate_execution_plan_price_response.py,sha256=DtUhNUrl9LcvwKlvCq9Yu62r9HMRvPS5SIQYpWkWSVw,4605
+huaweicloudsdkaos/v1/model/execution_plan.py,sha256=6ycFgn691cBQ1rWO52inXb6OcgQZ6FM5rl0PSpp_wrc,17263
 huaweicloudsdkaos/v1/model/execution_plan_description_primitive_type_holder.py,sha256=5RJLsPIye5NPX0FwElHF7vQizb222NfRUvvjC8LjowY,3482
-huaweicloudsdkaos/v1/model/execution_plan_diff_attribute.py,sha256=kb-4yBCtHgy6MBFFwDcV2Sdk1L9rKYUgRvFtb-OwQ5w,8615
-huaweicloudsdkaos/v1/model/execution_plan_id_primitive_type_holder.py,sha256=H-FMjg9ZIHpETShVKaOyuNZN1vX5c52VLaVC4b6Mun8,5438
-huaweicloudsdkaos/v1/model/execution_plan_item.py,sha256=gFzcBDtyqE4OZmviutcigGUuKC7WN0TM77S-y_XA6kQ,24968
+huaweicloudsdkaos/v1/model/execution_plan_diff_attribute.py,sha256=aPTrGrQx0s1N1F5kWKxe3NcTNoMmIexanC9epAJv7fM,8609
+huaweicloudsdkaos/v1/model/execution_plan_id_primitive_type_holder.py,sha256=gykoNbUCn9Yc6_fsxNcQvGjORGoc1GMtuBd_4xsQByg,5435
+huaweicloudsdkaos/v1/model/execution_plan_item.py,sha256=UVWlDt8rOGbg-DU1KUV6inJI0L1Ojr_b_Tb5sbA0nGk,24950
 huaweicloudsdkaos/v1/model/execution_plan_name_primitive_type_holder.py,sha256=nMDFMwCnCYqzZAl9bf_Hc32L6Vc1pI5AkBpbDbTD5y4,4001
 huaweicloudsdkaos/v1/model/execution_plan_status_message_primitive_type_holder.py,sha256=sagL_TW0Z63bHojLTgMuEtMz0j5fIlv-SU1zKuTxlgk,3764
-huaweicloudsdkaos/v1/model/execution_plan_status_primitive_type_holder.py,sha256=l4NYVn_JOYgzwzcuNpuwAA0ODnkO3CRlHrIPLYWCGrA,4462
+huaweicloudsdkaos/v1/model/execution_plan_status_primitive_type_holder.py,sha256=ljXjk1naBQJE2tmX3FQyyFAtxFFlg0eYTfK3Kj48EoE,4447
 huaweicloudsdkaos/v1/model/execution_plan_summary.py,sha256=7NdIMLn0AsF0yxqZJMl2BfkAYubjxoVN5FvQP2sWAwA,5048
-huaweicloudsdkaos/v1/model/get_execution_plan_metadata_request.py,sha256=Ftb2vKTIBT2-uBvDiXdThCWcPUY9jOc8C0Y05LAwKB4,12339
-huaweicloudsdkaos/v1/model/get_execution_plan_metadata_response.py,sha256=UjtTz2RQUGa46MHibuz-1mxq4PUQ8HYFyWBLkgUmd6c,26418
-huaweicloudsdkaos/v1/model/get_execution_plan_request.py,sha256=xB-EXMudodmcB3Rp86CY7dR-38q7aswh6D4W-XTfK4A,12155
+huaweicloudsdkaos/v1/model/get_execution_plan_metadata_request.py,sha256=ki500kYyxmeFH8sLh3GJbQun-lTbDIFgl9dUfQiyVHc,12333
+huaweicloudsdkaos/v1/model/get_execution_plan_metadata_response.py,sha256=8DhTO_eXElHm-BSM7UVUNVwZe8VN_Ly4XvL5nAA7gdI,26385
+huaweicloudsdkaos/v1/model/get_execution_plan_request.py,sha256=yYD3TLzyT1-w10kzg-KOqBdakLQYFrXYtzISGVqQ1fg,12149
 huaweicloudsdkaos/v1/model/get_execution_plan_response.py,sha256=M_vnC61ch_4IUpbwSKZmrKgaqRKhHyPVokJ40r8RvCw,3717
-huaweicloudsdkaos/v1/model/get_stack_metadata_request.py,sha256=3f46bHoQnKtyjt1CsraVZY5c9IyIcM7s_jEJE5lZdHs,7538
-huaweicloudsdkaos/v1/model/get_stack_metadata_response.py,sha256=B24eaCaR47rN3YDbl-zlpJNZWcWz3tKLsBHVnxXG8HU,27497
-huaweicloudsdkaos/v1/model/get_stack_template_request.py,sha256=mthLr4pYZI1r0d_0YCCwjLfxEtFLhfIjvEgTB0pNfNg,7538
+huaweicloudsdkaos/v1/model/get_stack_metadata_request.py,sha256=K1mHXW30PZi44yqelmJtSJr92YBcjMJk1M8axzY6OBk,7535
+huaweicloudsdkaos/v1/model/get_stack_metadata_response.py,sha256=riONTxw-BoEIQcnZPwfoCwBJTFrBFvSuafUKKAHBw60,27446
+huaweicloudsdkaos/v1/model/get_stack_template_request.py,sha256=5w0JhC8k43QCLEYyBZ2dZnqq92i8YdgK7I6TYF5gVwo,7535
 huaweicloudsdkaos/v1/model/get_stack_template_response.py,sha256=jYoc4775_9ItRLxLbmasDzSB936BXw5ZImE3pA6cxD8,3170
-huaweicloudsdkaos/v1/model/index_primitive_type_holder.py,sha256=QTkmY4KrJHR2OuoEnmA-yY9zR8UBxdrey-mOHhzy5iI,8504
-huaweicloudsdkaos/v1/model/items_response.py,sha256=7PptHR23hj19_VQ_R1yNCbbZWWgen_FQlZay-5qL3c4,16325
+huaweicloudsdkaos/v1/model/index_primitive_type_holder.py,sha256=6Lmuf7i8qEMzXpI7tHgK-ECscSlAADuWRp_q-GIm7vk,8501
+huaweicloudsdkaos/v1/model/items_response.py,sha256=ufUDhjIFazBxHfyKaqkyp0bKAOXWebriU8WWWS9UDuU,16313
 huaweicloudsdkaos/v1/model/kms_structure.py,sha256=4VERkPOZbDVbBxWcgnc0r6ANFyl9mnefslbT5Lq3eIs,3952
-huaweicloudsdkaos/v1/model/list_execution_plans_request.py,sha256=qQBV1fUhUj18LE8Av1QV2Zt0FBWbAG4ywh-LVM2iRLw,7568
+huaweicloudsdkaos/v1/model/list_execution_plans_request.py,sha256=aMj4GE5MOt78ETXElcsLD3AUByUBtOYbEEM8eTPp0SY,7565
 huaweicloudsdkaos/v1/model/list_execution_plans_response.py,sha256=LvktmOal4fBF6LAxJDvStxcTORPRKGo6s-K0SgKzlkY,3755
-huaweicloudsdkaos/v1/model/list_stack_events_request.py,sha256=VlGJ0ZCFNDvgOPq65ssnSqqNO-t5flilCy3szxwx1Kg,11955
+huaweicloudsdkaos/v1/model/list_stack_events_request.py,sha256=y5IsTqG1ZNEDzGMp-6eczWP-rfzLgqe4y5c56SLDD90,11946
 huaweicloudsdkaos/v1/model/list_stack_events_response.py,sha256=dbqU0JbVWgCa0uj2ChUd39q_VcSJeU2n9k89DolfhLA,3479
-huaweicloudsdkaos/v1/model/list_stack_outputs_request.py,sha256=BY5FmlgGhMrP5_8ONizzaxioFQd0CEEXw026ybTdVHk,7538
+huaweicloudsdkaos/v1/model/list_stack_outputs_request.py,sha256=VKHieSTtPL2ocVX_eH4hapEKonX5VXzkwNPBnwHw8Kw,7535
 huaweicloudsdkaos/v1/model/list_stack_outputs_response.py,sha256=ehX5RXrd7sNs9uFf4XKv-ER3PTsw9LNpa98ehtPvfHk,3376
-huaweicloudsdkaos/v1/model/list_stack_resources_request.py,sha256=C_QguFcpz6C42OhO8npQpl6QeplB7Lx_oCDhbJAq-CA,7568
+huaweicloudsdkaos/v1/model/list_stack_resources_request.py,sha256=qD1SQuGMt2X-yl8TMY8oLrMS9_00LNxkQ3tJTlGMHa8,7565
 huaweicloudsdkaos/v1/model/list_stack_resources_response.py,sha256=EDd_AHV59lW5Fy8lKO2QeXyYXDr0cA76G4GNk1zjqvI,3647
 huaweicloudsdkaos/v1/model/list_stacks_request.py,sha256=2D-NtDBXX7SiMVjzv9ck8la5BfHlil5YhiXfp0FR1XU,3455
 huaweicloudsdkaos/v1/model/list_stacks_response.py,sha256=llHY8HQSeWcYfekzilTNU-WUIHc_-ioH5Qd8IIrp9Ic,3443
 huaweicloudsdkaos/v1/model/list_template_versions_request.py,sha256=QTrXPUcgjn7e2RPa--xEtuyUsZ18THNGZQY4ZyPgwC8,5648
 huaweicloudsdkaos/v1/model/list_template_versions_response.py,sha256=F7T3cLJshQg71Qj0qKl15OOEuW_dY7FwNSu1fdJtRVI,3438
 huaweicloudsdkaos/v1/model/list_templates_request.py,sha256=uWUct22XwCs_Iazd_dFgBEC0Ba9QUGwUgOz6FZFgQI8,3476
 huaweicloudsdkaos/v1/model/list_templates_response.py,sha256=W1iBc3oZs4xtUgnCdxQEunAeJ2o0n1MChV_ZiuLqLAM,3359
 huaweicloudsdkaos/v1/model/parse_template_variables_request.py,sha256=1mrUwwQ2l-ANWu70ejylNovir0-jg20wL5x4xy9W-74,4441
-huaweicloudsdkaos/v1/model/parse_template_variables_request_body.py,sha256=0RM01_87-fMTrVHXiYsEAVUQeWizPX4bE3XjFDQil_c,9787
+huaweicloudsdkaos/v1/model/parse_template_variables_request_body.py,sha256=-xZOQJPuY5PEUgKbLmbYdwI_4PGy4unNoN1zCqASOMs,9781
 huaweicloudsdkaos/v1/model/parse_template_variables_response.py,sha256=KYu53vZSO8Usco40l8d87eNSWlwWJJbYGpuRp6Hd7dM,3526
 huaweicloudsdkaos/v1/model/resource_attribute.py,sha256=wNZi2UCQTvuSBjQazatK5U1RODfZImAtWKAIbVZ9cVo,3663
-huaweicloudsdkaos/v1/model/resource_name_primitive_type_holder.py,sha256=GqYx_6EeQakC0tQVdHhT8gPafcIcwxmfaCiYc3w1_LE,4639
-huaweicloudsdkaos/v1/model/resource_price_response.py,sha256=fq82IZkrHvxGwcAGlPZL6tfbLnSxZPjumfuYyX20Q5Q,11190
-huaweicloudsdkaos/v1/model/resource_type_primitive_type_holder.py,sha256=YXUc3pI_zaNUNcXhUFiZO1BsZl1Mln1d_gvBZykRm9E,4522
+huaweicloudsdkaos/v1/model/resource_name_primitive_type_holder.py,sha256=jpktNB6rMhWfbzDaS9Nbf1DPAuUqRjQg8OY1PhXXrOc,4636
+huaweicloudsdkaos/v1/model/resource_price_response.py,sha256=d_1-GmCOrN4Gif2yYzR7YnKWW8QKX9gN5I8h_gOBk8c,11181
+huaweicloudsdkaos/v1/model/resource_type_primitive_type_holder.py,sha256=CF7MGvpoGtXRjfffMv1Hr1UFJd-0zOFpNaRSPXadwiw,4519
 huaweicloudsdkaos/v1/model/show_template_metadata_request.py,sha256=z8F1FMjzQkyzF2TeDF7H85grZZ-ABUwUSblawigHmVM,5648
 huaweicloudsdkaos/v1/model/show_template_metadata_response.py,sha256=GJr7pzml_WrMX3w2PieYOC8B3CDPES7lZUXi1ILl5Vo,7666
 huaweicloudsdkaos/v1/model/show_template_version_content_request.py,sha256=nbaioXAXquAXgoyXGZnaHSzI8fr5qSkZ3EBv_-LdX78,6836
 huaweicloudsdkaos/v1/model/show_template_version_content_response.py,sha256=vKNpf3nzS_yL9z4xZxUj5xMEfs27PoXYkylw-DZQh4Q,3250
 huaweicloudsdkaos/v1/model/show_template_version_metadata_request.py,sha256=5GczcBYdD6ReqxMXix262ZSmqfhHO1Ig7JR2lW6UDjU,6855
 huaweicloudsdkaos/v1/model/show_template_version_metadata_response.py,sha256=DDR-wOOIOP0T6Bupq1zypn_uwWlLEYoNcdtQieFHRpE,6737
-huaweicloudsdkaos/v1/model/stack.py,sha256=ylP80VNNurfQb34B42sa8C5NPzX-dlD-_BnRR339MXs,13440
+huaweicloudsdkaos/v1/model/stack.py,sha256=EE8qNO3_gR4Lg5mI55PnLKyJpJROrAV-gK2nzpnLZkg,13410
 huaweicloudsdkaos/v1/model/stack_description_primitive_type_holder.py,sha256=bRZ-3HZJx7XQm6nNyozu0vuJkVED4PaIeZ25KopM8Jg,3408
-huaweicloudsdkaos/v1/model/stack_event.py,sha256=O64RVwoRukWN9o-Ri549LC_bdkGQeKza-JF4wlL4TI8,21626
-huaweicloudsdkaos/v1/model/stack_id_primitive_type_holder.py,sha256=3LGkVNj_nCJh-OdPhd2RCRmboLZ9ydLObZM7VNE_Yms,5040
+huaweicloudsdkaos/v1/model/stack_event.py,sha256=-7DeUGNnb2ijR2Ca1ak6EitAxOY4B1TzT56Ejhvspa8,21608
+huaweicloudsdkaos/v1/model/stack_id_primitive_type_holder.py,sha256=Fad5DRj3nf0TXsKQawgp6ejSQHvZycmMNGlTTHBRubI,5037
 huaweicloudsdkaos/v1/model/stack_name_primitive_type_holder.py,sha256=ssEBoBoLsoJLyvedApcfyTLmHCUaYsMLhCrEeL9Xr9A,3711
-huaweicloudsdkaos/v1/model/stack_output.py,sha256=TNqJoL7lj9-GKJlvIZ9knkErEa1AV31DxZGtLZ868wQ,7751
-huaweicloudsdkaos/v1/model/stack_resource.py,sha256=oMPmg123TgtW99AxSFTSu8JsLClSrFkJs2GvntqBld4,22545
+huaweicloudsdkaos/v1/model/stack_output.py,sha256=sQlzGHW7InmtlclSb6WUjDuyUggtRVa7klsWe4Rvo30,7745
+huaweicloudsdkaos/v1/model/stack_resource.py,sha256=n75goB9jzTiYsKm-OY5ws7vTXOtrDBXJUtEWOpxa2nU,22527
 huaweicloudsdkaos/v1/model/stack_status_message_primitive_type_holder.py,sha256=fX2iKZ8f4EE4Y_zIuaoFbct3_kTSROVV_0Iu8ujfmxE,3690
-huaweicloudsdkaos/v1/model/stack_status_primitive_type_holder.py,sha256=LKwTV_leiAC8Z2sClQYMdR-joPlwTVqP3F3mFxMdEoY,5463
-huaweicloudsdkaos/v1/model/template.py,sha256=gZCG7Eva9AbpTMrPxFyyY3UUhEWlVcuinLpu5vapj8I,9197
-huaweicloudsdkaos/v1/model/template_body_primitive_type_holder.py,sha256=PXHDUXp4aLN8l9psmPqjOwAyNacnJFR0klOA6tAws10,4863
-huaweicloudsdkaos/v1/model/template_uri_primitive_type_holder.py,sha256=-glhwVrogBoyEsrX8-1a2v6KtDTOPkQlROy7sfzNj6s,7246
+huaweicloudsdkaos/v1/model/stack_status_primitive_type_holder.py,sha256=CnBfwaGRh483P2veOabYDVdJ2ZoDlFL_21D597xdEKI,5436
+huaweicloudsdkaos/v1/model/template.py,sha256=Cdbr9P8kBeZSowOx1szfdFKWuveB5IBPOae0clXmORQ,9185
+huaweicloudsdkaos/v1/model/template_body_primitive_type_holder.py,sha256=_zNkuu1k8zKIVlP2l29h2fst80ddKVVqzSFRyXFKbfo,4860
+huaweicloudsdkaos/v1/model/template_uri_primitive_type_holder.py,sha256=5kVeWufN9Rd488d_VTn0McFi1kKqcvF7ccCBXgR_v8U,7243
 huaweicloudsdkaos/v1/model/template_version.py,sha256=LmcFi_kXDFUfTrc3y_1nQArV1XVT69-vLXLAogkcBKI,7003
 huaweicloudsdkaos/v1/model/update_stack_request.py,sha256=X7B5wqdU1zhtcQrWkDMBwfeW9UjvTyV9TotVlUbmzQU,5594
-huaweicloudsdkaos/v1/model/update_stack_request_body.py,sha256=JKQ_iaeU_yx61i5eX85KDUPvbyr4SOrRs40ZJU1qfMI,11785
+huaweicloudsdkaos/v1/model/update_stack_request_body.py,sha256=hd0irRuxcSraQyxedamg3OzE4-ZLo3kgCoABo2H3psk,11773
 huaweicloudsdkaos/v1/model/update_stack_response.py,sha256=tp2lpM6lwI6L0GBB8nkv0H-bpxwFQdFcw2bLLzMgK94,2427
 huaweicloudsdkaos/v1/model/update_template_metadata_request.py,sha256=LaaqEsAs-256LPcJ3Y9Bg8g7RnVGvEjCJCdk8RZffvk,5376
 huaweicloudsdkaos/v1/model/update_template_metadata_request_body.py,sha256=o4-CbMda0Vg5JHB1sl5gmzkR80MP3SNzWucObhZ2XKU,4563
 huaweicloudsdkaos/v1/model/update_template_metadata_response.py,sha256=iYIEhSXjkS1UL1Mw5iMNwOkyuT1UeGs-v1FXq0u6i2c,2471
-huaweicloudsdkaos/v1/model/variable_response.py,sha256=JxMO3EWJ5UbfkB5CMTe9upwVcxI9a3Hd9bfdVi_pWAs,30140
+huaweicloudsdkaos/v1/model/variable_response.py,sha256=ay_fkyAh9l-FVx6RuAPDXyLboc8qJlobunf2kbxWeao,30122
 huaweicloudsdkaos/v1/model/variable_validation_response.py,sha256=gElraVNtsBByMcrkJ3AF3WKCF598CLV3VS_9XDkhaf8,4111
-huaweicloudsdkaos/v1/model/vars_body_primitive_type_holder.py,sha256=nsiDKEJlENfLDoUTcDvLywfUPUxJe9WVvYxIP71eh4s,5217
-huaweicloudsdkaos/v1/model/vars_structure.py,sha256=AsQ7_Ykt_GTPSAYj6tG1xpp5YlVqWNO_uqzCkpSPISw,5198
-huaweicloudsdkaos/v1/model/vars_structure_primitive_type_holder.py,sha256=nwqyZ_cc9nBUHQ1QSZufIdVFcQdOtT41-LF71h4hTAs,5956
+huaweicloudsdkaos/v1/model/vars_body_primitive_type_holder.py,sha256=zI3NngSwoYnuFv9_br9WWiatsM5p_dIIM8o4uCuBPnA,5214
+huaweicloudsdkaos/v1/model/vars_structure.py,sha256=JJjWxowqhIkpeL3fFwB7k4as0q3ajA8Fckhhx4ksMZo,5195
+huaweicloudsdkaos/v1/model/vars_structure_primitive_type_holder.py,sha256=lXbI5wc8EJFRuvW6ZgAWl4ik2_133efWPmCn0_ct3EA,5953
 huaweicloudsdkaos/v1/model/vars_uri_content_primitive_type_holder.py,sha256=A3QHKXpcewYEHs2Pd5QBRLu8TmeEqGvr67ZNCUOe_Oo,3407
-huaweicloudsdkaos/v1/model/vars_uri_primitive_type_holder.py,sha256=nB0q7mGVdlN4XDKapU4d583JCrhPToDIAjFPWge5NaQ,5835
+huaweicloudsdkaos/v1/model/vars_uri_primitive_type_holder.py,sha256=zacPftidrti8Gef6Jw1kiNHZ-KF9umzQt699Aufo0eY,5832
 huaweicloudsdkaos/v1/region/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 huaweicloudsdkaos/v1/region/aos_region.py,sha256=xro_1TK-S2CLwCEj6GZvQ6V06KmjHsznSr-SRQkncrs,1337
-huaweicloudsdkaos-3.1.47.dist-info/LICENSE,sha256=4_VSTLuxcsybRG9N4Isktlj1rAIBBsfl0Tjc0gBTijo,604
-huaweicloudsdkaos-3.1.47.dist-info/METADATA,sha256=w4ylWmXZbxjzu12J766cChoyOA4V3IXij8kDG2LzsJc,1136
-huaweicloudsdkaos-3.1.47.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
-huaweicloudsdkaos-3.1.47.dist-info/top_level.txt,sha256=ANPIsGl-ZgzufoOzmHBCuM8WraAZmKdC-KMm4kYO9tc,18
-huaweicloudsdkaos-3.1.47.dist-info/RECORD,,
+huaweicloudsdkaos-3.1.48.dist-info/LICENSE,sha256=4_VSTLuxcsybRG9N4Isktlj1rAIBBsfl0Tjc0gBTijo,604
+huaweicloudsdkaos-3.1.48.dist-info/METADATA,sha256=F7DG-UKvBanescSpD9bffjKE_TN-2cqnAudPXl_TOOI,1136
+huaweicloudsdkaos-3.1.48.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+huaweicloudsdkaos-3.1.48.dist-info/top_level.txt,sha256=ANPIsGl-ZgzufoOzmHBCuM8WraAZmKdC-KMm4kYO9tc,18
+huaweicloudsdkaos-3.1.48.dist-info/RECORD,,
```

