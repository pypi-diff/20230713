# Comparing `tmp/piargus-0.2.0-py3-none-any.whl.zip` & `tmp/piargus-0.3.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,32 @@
-Zip file size: 30410 bytes, number of entries: 24
--rw-rw-rw-  2.0 fat      823 b- defN 23-Jun-19 09:47 piargus/__init__.py
+Zip file size: 34231 bytes, number of entries: 30
+-rw-rw-rw-  2.0 fat      940 b- defN 23-Jul-09 19:54 piargus/__init__.py
+-rw-rw-rw-  2.0 fat     1917 b- defN 23-Jul-09 19:54 piargus/anytree_utils.py
 -rw-rw-rw-  2.0 fat     4108 b- defN 23-Feb-01 17:28 piargus/apriori.py
 -rw-rw-rw-  2.0 fat     2933 b- defN 23-Feb-01 17:28 piargus/argusreport.py
--rw-rw-rw-  2.0 fat     3784 b- defN 23-Jun-20 23:19 piargus/batchwriter.py
--rw-rw-rw-  2.0 fat     1673 b- defN 23-Feb-01 17:28 piargus/codelist.py
--rw-rw-rw-  2.0 fat      379 b- defN 23-Jan-20 19:08 piargus/constants.py
--rw-rw-rw-  2.0 fat     1251 b- defN 23-Jun-19 21:19 piargus/graphrecode.py
--rw-rw-rw-  2.0 fat     4353 b- defN 23-Jun-21 10:15 piargus/hierarchy.py
--rw-rw-rw-  2.0 fat     4550 b- defN 23-Jun-18 22:08 piargus/inputdata.py
--rw-rw-rw-  2.0 fat    10671 b- defN 23-Jun-19 21:26 piargus/job.py
--rw-rw-rw-  2.0 fat     5310 b- defN 23-Feb-20 21:51 piargus/metadata.py
+-rw-rw-rw-  2.0 fat     3796 b- defN 23-Jul-09 20:00 piargus/batchwriter.py
+-rw-rw-rw-  2.0 fat      628 b- defN 23-Jul-09 22:01 piargus/codehierarchy.py
+-rw-rw-rw-  2.0 fat     1766 b- defN 23-Jul-09 19:54 piargus/codelist.py
+-rw-rw-rw-  2.0 fat      379 b- defN 23-Jul-09 22:00 piargus/constants.py
+-rw-rw-rw-  2.0 fat     1251 b- defN 23-Jul-03 21:03 piargus/graphrecode.py
+-rw-rw-rw-  2.0 fat     1093 b- defN 23-Jul-10 10:38 piargus/hierarchy.py
+-rw-rw-rw-  2.0 fat      408 b- defN 23-Jul-06 22:15 piargus/hierarchycode.py
+-rw-rw-rw-  2.0 fat      403 b- defN 23-Jul-06 16:59 piargus/hiercode.py
+-rw-rw-rw-  2.0 fat     4774 b- defN 23-Jul-10 11:58 piargus/inputdata.py
+-rw-rw-rw-  2.0 fat    10703 b- defN 23-Jul-09 19:54 piargus/job.py
+-rw-rw-rw-  2.0 fat     6149 b- defN 23-Jul-09 22:16 piargus/metadata.py
 -rw-rw-rw-  2.0 fat     3000 b- defN 23-Feb-10 16:24 piargus/microdata.py
--rw-rw-rw-  2.0 fat     5046 b- defN 23-Jun-21 13:50 piargus/safetyrule.py
--rw-rw-rw-  2.0 fat     5107 b- defN 23-Jun-21 13:46 piargus/table.py
--rw-rw-rw-  2.0 fat     5606 b- defN 23-Jun-18 22:08 piargus/tabledata.py
+-rw-rw-rw-  2.0 fat     5046 b- defN 23-Jul-03 21:03 piargus/safetyrule.py
+-rw-rw-rw-  2.0 fat     5102 b- defN 23-Jul-09 19:54 piargus/table.py
+-rw-rw-rw-  2.0 fat     5660 b- defN 23-Jul-09 22:02 piargus/tabledata.py
 -rw-rw-rw-  2.0 fat     2180 b- defN 23-Feb-01 17:28 piargus/tableresult.py
--rw-rw-rw-  2.0 fat     2581 b- defN 23-Jun-18 23:39 piargus/tableset.py
--rw-rw-rw-  2.0 fat     4311 b- defN 23-Jun-19 18:21 piargus/tauargus.py
--rw-rw-rw-  2.0 fat     1368 b- defN 23-Jun-19 20:30 piargus/utils.py
--rw-rw-rw-  2.0 fat    11357 b- defN 23-Jun-23 10:33 piargus-0.2.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     3070 b- defN 23-Jun-23 10:33 piargus-0.2.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Jun-23 10:33 piargus-0.2.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        8 b- defN 23-Jun-23 10:33 piargus-0.2.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1836 b- defN 23-Jun-23 10:33 piargus-0.2.0.dist-info/RECORD
-24 files, 85397 bytes uncompressed, 27510 bytes compressed:  67.8%
+-rw-rw-rw-  2.0 fat     2581 b- defN 23-Jul-03 21:03 piargus/tableset.py
+-rw-rw-rw-  2.0 fat     4311 b- defN 23-Jul-03 21:03 piargus/tauargus.py
+-rw-rw-rw-  2.0 fat     4101 b- defN 23-Jul-11 14:16 piargus/treehierarchy.py
+-rw-rw-rw-  2.0 fat     1205 b- defN 23-Jul-09 19:54 piargus/treerecode.py
+-rw-rw-rw-  2.0 fat     1368 b- defN 23-Jul-03 21:03 piargus/utils.py
+-rw-rw-rw-  2.0 fat    11357 b- defN 23-Jul-13 08:33 piargus-0.3.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     3104 b- defN 23-Jul-13 08:33 piargus-0.3.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-13 08:33 piargus-0.3.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        8 b- defN 23-Jul-13 08:33 piargus-0.3.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2311 b- defN 23-Jul-13 08:33 piargus-0.3.0.dist-info/RECORD
+30 files, 92674 bytes uncompressed, 30603 bytes compressed:  67.0%
```

## zipnote {}

```diff
@@ -1,31 +1,43 @@
 Filename: piargus/__init__.py
 Comment: 
 
+Filename: piargus/anytree_utils.py
+Comment: 
+
 Filename: piargus/apriori.py
 Comment: 
 
 Filename: piargus/argusreport.py
 Comment: 
 
 Filename: piargus/batchwriter.py
 Comment: 
 
+Filename: piargus/codehierarchy.py
+Comment: 
+
 Filename: piargus/codelist.py
 Comment: 
 
 Filename: piargus/constants.py
 Comment: 
 
 Filename: piargus/graphrecode.py
 Comment: 
 
 Filename: piargus/hierarchy.py
 Comment: 
 
+Filename: piargus/hierarchycode.py
+Comment: 
+
+Filename: piargus/hiercode.py
+Comment: 
+
 Filename: piargus/inputdata.py
 Comment: 
 
 Filename: piargus/job.py
 Comment: 
 
 Filename: piargus/metadata.py
@@ -48,26 +60,32 @@
 
 Filename: piargus/tableset.py
 Comment: 
 
 Filename: piargus/tauargus.py
 Comment: 
 
+Filename: piargus/treehierarchy.py
+Comment: 
+
+Filename: piargus/treerecode.py
+Comment: 
+
 Filename: piargus/utils.py
 Comment: 
 
-Filename: piargus-0.2.0.dist-info/LICENSE
+Filename: piargus-0.3.0.dist-info/LICENSE
 Comment: 
 
-Filename: piargus-0.2.0.dist-info/METADATA
+Filename: piargus-0.3.0.dist-info/METADATA
 Comment: 
 
-Filename: piargus-0.2.0.dist-info/WHEEL
+Filename: piargus-0.3.0.dist-info/WHEEL
 Comment: 
 
-Filename: piargus-0.2.0.dist-info/top_level.txt
+Filename: piargus-0.3.0.dist-info/top_level.txt
 Comment: 
 
-Filename: piargus-0.2.0.dist-info/RECORD
+Filename: piargus-0.3.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## piargus/__init__.py

```diff
@@ -1,21 +1,23 @@
 from piargus.apriori import Apriori
 from piargus.argusreport import TauArgusException
 from piargus.batchwriter import BatchWriter
 from piargus.codelist import CodeList
 from piargus.constants import *
-from piargus.graphrecode import GraphRecode
+from piargus.treerecode import TreeRecode
 from piargus.hierarchy import Hierarchy
+from piargus.treehierarchy import TreeHierarchy, TreeHierarchyNode
+from piargus.codehierarchy import CodeHierarchy
 from piargus.inputdata import InputData
 from piargus.job import Job
 from piargus.job import JobSetupError
 from piargus.metadata import MetaData
 from piargus.microdata import MicroData
 from piargus.safetyrule import dominance_rule, percent_rule, frequency_rule, request_rule, zero_rule, \
     missing_rule, weight_rule, manual_rule, p_rule, nk_rule
 from piargus.table import Table
 from piargus.tabledata import TableData
 from piargus.tableset import TableSet
 from piargus.tauargus import TauArgus
 
 
-__version__ = "0.2.0"
+__version__ = "0.3.0"
```

## piargus/batchwriter.py

```diff
@@ -70,15 +70,15 @@
         return self.write_command("RECODE", arg)
 
     def safety_rule(self, rule="", /, *, individual="", holding=""):
         rule = make_safety_rule(rule, individual=individual, holding=holding)
         return self.write_command('SAFETYRULE', rule)
 
     def suppress(self, method, table, *method_args):
-        args = ",".join(map(str, [table, *method_args]))
+        args = ",".join(map(format_argument, [table, *method_args]))
         return self.write_command('SUPPRESS', f"{method}({args})")
 
     def write_table(self, table, kind, options, filename):
         if hasattr(options, 'items'):
             options = "".join([k + {True: "+", False: "-"}[v] for k, v in options.items()])
 
         result = f"({table}, {kind}, {options}, {format_argument(filename)})"
```

## piargus/codelist.py

```diff
@@ -41,18 +41,21 @@
 
     def __eq__(self, other):
         if hasattr(other, 'to_dict'):
             other = other.to_dict()
 
         return self.to_dict() == other
 
+    def column_length(self) -> int:
+        return max(map(len, self.iter_codes()))
+
     def keys(self):
         return self._codes.keys()
 
-    def codes(self):
+    def iter_codes(self):
         for code in self._codes.index:
             yield code
 
     def to_cdl(self, file=None, length=0):
         codes = self._codes.copy()
         codes.index = codes.index.str.rjust(length)
         result = codes.to_csv(file, header=False)
```

## piargus/hierarchy.py

```diff
@@ -1,148 +1,36 @@
-import io
-import os
-import re
-from pathlib import Path
+from typing import Sequence
 
-import pandas as pd
+DEFAULT_TOTAL_CODE = "Total"
 
 
 class Hierarchy:
-    """Describe a hierarchy for use with TauArgus"""
+    __slots__ = ()
 
-    @classmethod
-    def from_hrc(cls, file, indent='@'):
-        if isinstance(file, (str, Path)):
-            with open(file) as reader:
-                hierarchy = cls.from_hrc(reader)
-                hierarchy.filepath = Path(file)
-                return hierarchy
-
-        pattern = re.compile(rf"^(?P<prefix>({re.escape(indent)})*)(?P<code>.*)")
-
-        last_prefix = ''
-        last_hierarchy = Hierarchy()
-        stack = [last_hierarchy]
-
-        for line in file:
-            prefix_code = pattern.match(line)
-            prefix = prefix_code['prefix']
-            code = prefix_code['code']
-
-            if len(prefix) > len(last_prefix):
-                stack.append(last_hierarchy)
-            elif len(prefix) < len(last_prefix):
-                stack.pop(-1)
-
-            last_hierarchy = Hierarchy()
-            stack[-1][code] = last_hierarchy
-            last_prefix = prefix
-
-        return stack[0]
-
-    @classmethod
-    def from_dataframe(cls, df: pd.DataFrame):
-        hierarchy = Hierarchy()
-        mi = pd.MultiIndex.from_frame(df)
-
-        for row in mi:
-            nested_hierarchy = hierarchy
-            for col in row:
-                nested_hierarchy[col] = True
-                nested_hierarchy = nested_hierarchy[col]
-
-        return hierarchy
-
-    def __init__(self, data=None):
-        self._data = {}
-        if data is None:
-            pass
-        elif hasattr(data, 'keys'):
-            for key in data.keys():
-                self._data[key] = Hierarchy(data[key])
-        else:
-            for key in data:
-                self._data[key] = Hierarchy(dict())
+    total_code: str
 
-        self.filepath = None
-
-    def __repr__(self):
-        return f"{self.__class__.__name__}({self.to_dict()})"
-
-    def __str__(self):
-        return self.to_hrc()
-
-    def __getitem__(self, key):
-        return self._data[key]
-
-    def __setitem__(self, key, value):
-        if isinstance(value, bool):
-            if value is True and key not in self._data:
-                self._data[key] = Hierarchy()
-            elif value is False and key in self._data:
-                del self._data[key]
+    def __new__(cls, *args, **kwargs):
+        if cls is Hierarchy:
+            return cls._create_child_object(*args, **kwargs)
         else:
-            if not isinstance(value, Hierarchy):
-                value = Hierarchy(value)
-
-            self._data[key] = value
+            return super().__new__(cls)
 
-    def __eq__(self, other):
-        if hasattr(other, 'to_dict'):
-            other = other.to_dict()
-
-        return self.to_dict() == other
-
-    def __delitem__(self, key):
-        del self._data[key]
-
-    def __iter__(self):
-        return iter(self.keys())
-
-    def keys(self):
-        return self._data.keys()
-
-    def codes(self, totals=True):
-        for key in self.keys():
-            if totals or not self[key].keys():
-                yield key
-            yield from self[key].codes(totals=totals)
-
-    def to_dict(self):
-        return {key: value.to_dict() for key, value in self._data.items()}
-
-    def to_hrc(self, file=None, indent='@', length=0):
-        if file is None:
-            file = io.StringIO(newline=os.linesep)
-            self.to_hrc(file)
-            return file.getvalue()
-        elif hasattr(file, 'write'):
-            self._to_hrc(file, indent, length)
+    @classmethod
+    def _create_child_object(cls, hierarchy, total_code=DEFAULT_TOTAL_CODE):
+        """
+        Create either CodeHierarchy or ThreeHierarchy.
+
+        It's usually better to create one of those directly.
+        """
+        # Prevent circular imports
+        from .codehierarchy import CodeHierarchy
+        from .treehierarchy import TreeHierarchy
+
+        if isinstance(hierarchy, Hierarchy):
+            return hierarchy
+        elif isinstance(hierarchy, Sequence) and all(isinstance(x, int) for x in hierarchy):
+            return CodeHierarchy(hierarchy, total_code=total_code)
         else:
-            self.filepath = Path(file)
-            with open(file, 'w', newline='\n') as writer:
-                self._to_hrc(writer, indent, length)
-
-    def _to_hrc(self, file, indent, length, _level=0):
-        for key in self.keys():
-            file.write(indent * _level + str(key).rjust(length) + '\n')
-            self[key]._to_hrc(file, indent, length, _level=_level + 1)
-
-    def to_dataframe(self, names) -> pd.DataFrame:
-        if not self._data:
-            return pd.DataFrame()
-
-        names = list(names)
-        name = names.pop(0)
-
-        df_parts = []
-        for key, value in self._data.items():
-            df_part = value.to_dataframe(names)
-
-            if df_part.empty:
-                df_part = pd.DataFrame([{name: key}])
-            else:
-                df_part.insert(0, column=name, value=key)
-
-            df_parts.append(df_part)
+            return TreeHierarchy(hierarchy, total_code=total_code)
 
-        return pd.concat(df_parts)
+    def column_length(self) -> int:
+        raise NotImplementedError
```

## piargus/inputdata.py

```diff
@@ -1,15 +1,15 @@
 import abc
 import warnings
 from typing import Dict
 
 from pandas.core.dtypes.common import is_string_dtype, is_categorical_dtype, is_bool_dtype
 
 from .codelist import CodeList
-from .hierarchy import Hierarchy
+from .hierarchy import Hierarchy, DEFAULT_TOTAL_CODE
 from .metadata import MetaData, Column
 
 DEFAULT_COLUMN_LENGTH = 20
 
 
 class InputData(metaclass=abc.ABCMeta):
     def __init__(
@@ -48,33 +48,37 @@
         if total_codes is None:
             total_codes = dict()
         elif isinstance(total_codes, str):
             # This is allowed on TableData, but not in general
             raise TypeError("Total codes must be a dict.")
 
         self.dataset = dataset
-        self.hierarchies = hierarchies
         self.codelists = codelists
         self.column_lengths = column_lengths
+        self.hierarchies = hierarchies
         self.total_codes = total_codes
-
         self.filepath = None
 
     @abc.abstractmethod
     def generate_metadata(self) -> MetaData:
         """Generate metadata corresponding to the input data."""
         self.resolve_column_lengths()
 
         metadata = MetaData()
         for col in self.dataset.columns:
             metacol = metadata[col] = Column(col, length=self.column_lengths[col])
 
-            total_code = self.total_codes.get(col)
-            if total_code:
-                metacol['TOTCODE'] = total_code
+            if col in self.total_codes:  # Normal way
+                total_code = metacol['TOTCODE'] = self.total_codes[col]
+            elif col in self.hierarchies:  # Use hierarchy as alternative
+                total_code = self.hierarchies[col].total_code
+            else:  # Reasonable default
+                total_code = DEFAULT_TOTAL_CODE
+
+            metacol['TOTCODE'] = total_code
 
         return metadata
 
     @abc.abstractmethod
     def to_csv(self, target):
         raise NotImplementedError
 
@@ -88,18 +92,18 @@
 
         :param default: The length to use for numbers and other datatypes.
         """
         dataset = self.dataset
 
         for col in dataset.columns:
             if col not in self.column_lengths:
-                if col in self.codelists:
-                    column_length = max(map(len, self.codelists[col].codes()))
-                elif col in self.hierarchies:
-                    column_length = max(map(len, self.hierarchies[col].codes()))
+                if col in self.hierarchies:
+                    column_length = self.hierarchies[col].column_length()
+                elif col in self.codelists:
+                    column_length = self.codelists[col].column_length()
                 elif is_categorical_dtype(dataset[col].dtype):
                     column_length = dataset[col].cat.categories.str.len().max()
                 elif is_string_dtype(dataset[col].dtype):
                     column_length = dataset[col].str.len().max()
                 elif is_bool_dtype(dataset[col].dtype):
                     column_length = 1
                 else:
@@ -109,17 +113,16 @@
 
     @property
     def hierarchies(self):
         return self._hierarchies
 
     @hierarchies.setter
     def hierarchies(self, value):
-        self._hierarchies = {col: hierarchy
-                             if isinstance(hierarchy, Hierarchy) else Hierarchy(hierarchy)
-                             for col, hierarchy in value.items()}
+        self._hierarchies = {col: hrc if isinstance(hrc, Hierarchy) else Hierarchy(hrc)
+                             for col, hrc in value.items()}
 
     @property
     def codelists(self):
         return self._codelists
 
     @codelists.setter
     def codelists(self, value):
```

## piargus/job.py

```diff
@@ -1,18 +1,18 @@
 from pathlib import Path
 from tempfile import TemporaryDirectory
 from typing import Optional, Union, Mapping, Hashable, Iterable
 
 from .batchwriter import BatchWriter
-from .graphrecode import GraphRecode
 from .inputdata import InputData
 from .metadata import MetaData
 from .table import Table
 from .tabledata import TableData
 from .tableset import TableSet
+from .treerecode import TreeRecode
 from .utils import slugify
 
 
 class Job:
     def __init__(
         self,
         input_data: InputData,
@@ -161,15 +161,15 @@
         default = self.directory / 'input' / f"{name}.rda"
         if not self.metadata.filepath:
             self.metadata.to_rda(default)
 
     def _setup_hierarchies(self):
         self.input_data.resolve_column_lengths()
         for col, hierarchy in self.input_data.hierarchies.items():
-            if not hierarchy.filepath:
+            if hasattr(hierarchy, 'filepath') and not hierarchy.filepath:
                 default = self.directory / 'input' / f'{col}_hierarchy.hrc'
                 hierarchy.to_hrc(default, length=self.input_data.column_lengths[col])
 
     def _setup_codelists(self):
         self.input_data.resolve_column_lengths()
         for col, codelist in self.input_data.codelists.items():
             if not codelist.filepath:
@@ -184,15 +184,15 @@
 
             if table.apriori and table.apriori.filepath is None:
                 tablename = f'{self.name}_{slugify(t_name)}'
                 default = self.directory / 'input' / f'{tablename}_apriori.hst'
                 table.apriori.to_hst(default)
 
             for col, recode in table.recodes.items():
-                if isinstance(recode, GraphRecode) and recode.filepath is None:
+                if isinstance(recode, TreeRecode) and recode.filepath is None:
                     tablename = f'{self.name}_{slugify(t_name)}'
                     default = self.directory / 'input' / f"{tablename}_{col}_recode.grc"
                     recode.to_grc(default, length=self.input_data.column_lengths[col])
 
     def _setup_batch(self):
         with open(self.batch_filepath, 'w') as batch:
             writer = BatchWriter(batch)
```

## piargus/metadata.py

```diff
@@ -1,15 +1,17 @@
 import io
 import re
 import shlex
 from pathlib import Path
 from typing import Optional
 
+from .codehierarchy import CodeHierarchy
 from .codelist import CodeList
-from .hierarchy import Hierarchy
+from .hierarchy import Hierarchy, DEFAULT_TOTAL_CODE
+from .treehierarchy import TreeHierarchy
 
 PROPERTY_PATTERN = re.compile(r"\<(.*)\>")
 
 
 class MetaData:
     """
     Metadata describing InputData.
@@ -130,30 +132,48 @@
             elif value is True:
                 out.append(f"    <{key}>")
             else:
                 out.append(f"    <{key}> {value}")
 
         return "\n".join(out)
 
-    def set_hierarchy(self, hierarchy: Optional[Hierarchy], indent='@'):
-        if hierarchy is not None:
-            if hierarchy.filepath is None:
-                raise TypeError("hierarchy.to_hrc needs to be called first.")
-
-            self['HIERARCHICAL'] = True
-            self['HIERCODELIST'] = hierarchy.filepath
-            self['HIERLEADSTRING'] = indent
+    def set_hierarchy(self, hierarchy: Optional[Hierarchy]):
+        if hasattr(hierarchy, "filepath") and hierarchy.filepath is None:
+            raise TypeError("hierarchy.to_hrc needs to be called first.")
+        elif hierarchy is not None and not isinstance(hierarchy, Hierarchy):
+            raise TypeError(f"{hierarchy} should be a hierarchy")
+
+        is_hierarchical = bool(hierarchy)
+
+        # Handle ThreeHierarchy
+        codelist = getattr(hierarchy, "filepath", None)
+        leadstring = getattr(hierarchy, "indent", None)
+
+        # Handle CodeHierarchy
+        levels = getattr(hierarchy, "levels", None)
+
+        self["HIERARCHICAL"] = is_hierarchical
+        self['HIERCODELIST'] = codelist
+        self['HIERLEADSTRING'] = leadstring
+
+        if levels:
+            self['HIERLEVELS'] = " ".join(map(str, levels))
         else:
-            self['HIERARCHICAL'] = False
-            self['HIERCODELIST'] = None
-            self['HIERLEADSTRING'] = None
+            self['HIERLEVELS'] = None
 
     def get_hierarchy(self) -> Optional[Hierarchy]:
+        total_code = self['TOTCODE'] or DEFAULT_TOTAL_CODE
+
         if self["HIERCODELIST"]:
-            return Hierarchy.from_hrc(self["HIERCODELIST"], self["HIERLEADSTRING"])
+            return TreeHierarchy.from_hrc(self["HIERCODELIST"],
+                                          indent=self["HIERLEADSTRING"],
+                                          total_code=total_code)
+        elif self["HIERLEVELS"]:
+            levels = map(int, self['HIERLEVELS'].split())
+            return CodeHierarchy(levels, total_code=total_code)
         else:
             return None
 
     def set_codelist(self, codelist: Optional[CodeList]):
         if codelist:
             if codelist.filepath is None:
                 raise TypeError("codelist.to_cdl needs to be called first.")
```

## piargus/table.py

```diff
@@ -1,15 +1,15 @@
 import warnings
 from typing import Union, Optional, Sequence, Collection, Iterable, Any, Mapping
 
 import pandas as pd
 
 from .apriori import Apriori
 from .constants import FREQUENCY_RESPONSE, OPTIMAL
-from .graphrecode import GraphRecode
+from .treerecode import TreeRecode
 from .safetyrule import make_safety_rule, SafetyRuleDict
 from .tableresult import TableResult
 
 
 class Table:
     def __init__(
         self,
@@ -17,15 +17,15 @@
         response: Union[str, int] = FREQUENCY_RESPONSE,
         shadow: Optional[str] = None,
         cost: Optional[Union[int, str]] = None,
         labda: int = None,
         name: str = None,  # Deprecated
         safety_rule: Union[str, Collection[str], SafetyRuleDict] = (),
         apriori: Union[Apriori, Iterable[Sequence[Any]]] = (),
-        recodes: Mapping[str, Union[int, GraphRecode]] = None,
+        recodes: Mapping[str, Union[int, TreeRecode]] = None,
         suppress_method: Optional[str] = OPTIMAL,
         suppress_method_args: Sequence = (),
     ):
         """
         A Table instance describes the output of the table.
 
         A simple table can be created from MicroData.
@@ -70,16 +70,16 @@
         :param suppress_method_args: Parameters to pass to suppress_method.
         """
 
         if name is not None:
             warnings.warn("name is deprecated, pass a dict to Job instead")
 
         if recodes:
-            recodes = {col: (recode if isinstance(recode, (int, GraphRecode))
-                             else GraphRecode(recode))
+            recodes = {col: (recode if isinstance(recode, (int, TreeRecode))
+                             else TreeRecode(recode))
                        for col, recode in recodes.items()}
         else:
             recodes = dict()
 
         self.explanatory = explanatory
         self.response = response
         self.shadow = shadow
```

## piargus/tabledata.py

```diff
@@ -1,13 +1,14 @@
 from pathlib import Path
 from typing import Dict, Collection
 from typing import Optional, Sequence, Iterable, Union, Any
 
 from .apriori import Apriori
 from .constants import SAFE, UNSAFE, PROTECTED, OPTIMAL
+from .hierarchy import DEFAULT_TOTAL_CODE
 from .inputdata import InputData
 from .metadata import MetaData
 from .table import Table
 
 DEFAULT_STATUS_MARKERS = {
     "SAFE": SAFE,
     "UNSAFE": UNSAFE,
@@ -20,15 +21,15 @@
         self,
         dataset,
         explanatory: Sequence[str],
         response: str,
         shadow: Optional[str] = None,
         cost: Optional[str] = None,
         labda: Optional[int] = None,
-        total_codes: Union[str, Dict[str, str]] = 'Total',
+        total_codes: Union[str, Dict[str, str]] = DEFAULT_TOTAL_CODE,
         frequency: Optional[str] = None,
         top_contributors: Sequence[str] = (),
         lower_protection_level: Optional[str] = None,
         upper_protection_level: Optional[str] = None,
         status_indicator: Optional[str] = None,
         status_markers: Optional[Dict[str, str]] = None,
         safety_rule: Union[str, Collection[str]] = (),
```

## Comparing `piargus-0.2.0.dist-info/LICENSE` & `piargus-0.3.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `piargus-0.2.0.dist-info/METADATA` & `piargus-0.3.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: piargus
-Version: 0.2.0
+Version: 0.3.0
 Summary: Python wrapper around TauArgus
 Home-page: https://github.com/lverweijen/piargus
 Author: lverweijen
 Author-email: lauwerund@gmail.com
 License: Apache License 2.0
 Keywords: statistical-disclosure-control tau-argus
 Classifier: License :: OSI Approved :: Apache Software License
@@ -17,14 +17,15 @@
 Classifier: Intended Audience :: Science/Research
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Typing :: Typed
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: pandas (>=1.5.0)
+Requires-Dist: anytree (>=2.7.0)
 
 # PiArgus
 
 This package provides a python wrapper around [τ-ARGUS](https://research.cbs.nl/casc/tau.htm), a program to protect statistical tables.
 This package takes care of generating all the required metadata and runs τ-ARGUS in the background to do the heavy work.
 
 For this package to work, it is required to install τ-ARGUS locally first.
```

## Comparing `piargus-0.2.0.dist-info/RECORD` & `piargus-0.3.0.dist-info/RECORD`

 * *Files 24% similar despite different names*

```diff
@@ -1,24 +1,30 @@
-piargus/__init__.py,sha256=COJ0qitu9ldqdYePX0i5TUqFYZHtavwEX8LPw6hmCWo,823
+piargus/__init__.py,sha256=wxsxENBw_ABXXmu-f9N8SWsMHUISclQ_s0z4VXrKZgA,940
+piargus/anytree_utils.py,sha256=nLPUflpM_DTUG9UfHLrtLA9MxsNKx2GYwjK1edwu2kc,1917
 piargus/apriori.py,sha256=y8_AdvoOvFxrCw2IQfp2kRIXgGsgxcxJwGyF7rPlffI,4108
 piargus/argusreport.py,sha256=C9v6s0GUcB0Yr-nTKwXnAxj7nGjaNUBnQrbxmC0CJSI,2933
-piargus/batchwriter.py,sha256=2DLNty8sujtJp_GFmwyrm5yeBrqXVGVoIKiwnTXA9Qw,3784
-piargus/codelist.py,sha256=kSqHbVVvohMThrvtro22Lblh6E4mr04HGSX1HBFmJq4,1673
+piargus/batchwriter.py,sha256=9j_U4Zx7FW5-LlCnDS-rDhIV6k2f3k-WGpO_jflsXUQ,3796
+piargus/codehierarchy.py,sha256=5qb-6n0Cdwi3sIY4UtXX4tNHKzMyuLKoC5nKxsinA5I,628
+piargus/codelist.py,sha256=d8elIwcd_1mvZJe3IEFKC_wmn8Gdkkg-4gGtviVUnhg,1766
 piargus/constants.py,sha256=kqLB7aSsrvbOdfVvdSBW1fJuAtrqEbUJLGFksePuaUI,379
 piargus/graphrecode.py,sha256=HyQrxGNxSYVDEEfidhHpn6F4SRwigMmuRyKDOGpkNN8,1251
-piargus/hierarchy.py,sha256=XQfVnMCa3kblSPz3ugrDwpV4F3HsJdbEfaMwauwjmTA,4353
-piargus/inputdata.py,sha256=BV9-k6lXEcE8JfoFbpXeYXiRwSiP-LoAQQuA3psYhIQ,4550
-piargus/job.py,sha256=2DnNeoFg54g_-UcBeCkn1FjrS2yE42ahk926qOEaYLI,10671
-piargus/metadata.py,sha256=Lz8w5Ez3_cT6iLkWp1bZCfs2dRpLg3e3cePVHCju6ao,5310
+piargus/hierarchy.py,sha256=dtYE8bpv3eQon9imSnBl1t00GvwwFd43i9VW3pBo5w4,1093
+piargus/hierarchycode.py,sha256=6H6M93Ik1GQsaqlJiJHJbE07TbQgVVeevIyNP1QnNU8,408
+piargus/hiercode.py,sha256=ViZkIb49y6jQWRTpLhwii_6qdI7bw41-y6FK6Gdtrmg,403
+piargus/inputdata.py,sha256=IwVKtYUms3_PqEAONpW6s0_eySoBWosx1jxzXohSDgU,4774
+piargus/job.py,sha256=uNrIHkzgsJtUOsifi3r4fes54FRGVj_RG2Tu9LvGDYM,10703
+piargus/metadata.py,sha256=vtwbgM8Pc8yeF7Wkd8hvUwLw53pW7VSjuVHWt_6f8d0,6149
 piargus/microdata.py,sha256=C1mPk0lP8DkWr11M5c0p9oGzdEY-Mb3UpeVMDirRbDA,3000
 piargus/safetyrule.py,sha256=iL3kpZVQ9DJz2wP2xiVa2NiG8zq1g8Ps1OLR3lGOI4s,5046
-piargus/table.py,sha256=obk7PXTmn8cfDXK15hGudOCK_5qteiWXKRtwGeCF6BA,5107
-piargus/tabledata.py,sha256=P7ljXNrYPw-H1S-njCxHonhZb20XOY-DI3C4ofCtbNE,5606
+piargus/table.py,sha256=6KgyJuzQN5aMVtHzkbavpeVDNVA2C_y7mRBYsPUaNLQ,5102
+piargus/tabledata.py,sha256=yAhucwl3n8wa9OhAdl6B0JGYI6-2zFPECd3k3x2xn2E,5660
 piargus/tableresult.py,sha256=ILH5LGqXxn1pnC4IePosrbsKjUaF7CcCYrvEheMiWG8,2180
 piargus/tableset.py,sha256=03iE9iCbDbkSaxerWvIW_2TNUK0Ahlr-O2ZqYkAJkek,2581
 piargus/tauargus.py,sha256=QnuCROADHwfZluyMlVDpQhq8oI7Os2ybtXNVqNLRnEE,4311
+piargus/treehierarchy.py,sha256=l-i6TmQq46dewWvpmp3N_Rbsnov_ZriirD29PYd6djo,4101
+piargus/treerecode.py,sha256=63KcV_gZ2EWw7jUlL1ZsJSp5ApgyWs9e6-PGUeRPO00,1205
 piargus/utils.py,sha256=XIlWCY1NIucuG3Rl6pe8xtpn1s-tDBUYRdS1l1ubT4c,1368
-piargus-0.2.0.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-piargus-0.2.0.dist-info/METADATA,sha256=YTwd0bjDa264SklpT_8TnklER_5a3cZx-yoB2MNP3Gk,3070
-piargus-0.2.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-piargus-0.2.0.dist-info/top_level.txt,sha256=E-TXcwPPYg39KldgrN17YMMoQspcgu1UFq10wgjMNB8,8
-piargus-0.2.0.dist-info/RECORD,,
+piargus-0.3.0.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+piargus-0.3.0.dist-info/METADATA,sha256=Jaj1LG098601KbPae6SGtURp3aFUVXsOrmstT0iGaq8,3104
+piargus-0.3.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+piargus-0.3.0.dist-info/top_level.txt,sha256=E-TXcwPPYg39KldgrN17YMMoQspcgu1UFq10wgjMNB8,8
+piargus-0.3.0.dist-info/RECORD,,
```

