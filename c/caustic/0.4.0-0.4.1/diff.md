# Comparing `tmp/caustic-0.4.0-py2.py3-none-any.whl.zip` & `tmp/caustic-0.4.1-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,38 +1,39 @@
-Zip file size: 44602 bytes, number of entries: 36
--rw-rw-r--  2.0 unx      246 b- defN 23-Jun-09 14:54 caustic/__init__.py
--rw-rw-r--  2.0 unx      598 b- defN 23-Jun-09 14:53 caustic/constants.py
--rw-rw-r--  2.0 unx     8952 b- defN 23-Jun-09 14:53 caustic/cosmology.py
--rw-rw-r--  2.0 unx     3685 b- defN 23-Jun-09 14:53 caustic/forward_raytrace.py
--rw-rw-r--  2.0 unx      155 b- defN 23-Jun-09 14:53 caustic/packed.py
--rw-rw-r--  2.0 unx     3380 b- defN 23-Jun-09 14:53 caustic/parameter.py
--rw-rw-r--  2.0 unx    21171 b- defN 23-Jun-09 14:53 caustic/parametrized.py
--rw-rw-r--  2.0 unx      619 b- defN 23-Jun-09 14:53 caustic/simulator.py
--rw-rw-r--  2.0 unx    11725 b- defN 23-Jun-09 14:53 caustic/utils.py
--rw-rw-r--  2.0 unx       80 b- defN 23-Jun-09 14:53 caustic/data/__init__.py
--rw-rw-r--  2.0 unx     1563 b- defN 23-Jun-09 14:53 caustic/data/hdf5dataset.py
--rw-rw-r--  2.0 unx      683 b- defN 23-Jun-09 14:53 caustic/data/illustris_kappa.py
--rw-rw-r--  2.0 unx      675 b- defN 23-Jun-09 14:53 caustic/data/probes.py
--rw-rw-r--  2.0 unx      259 b- defN 23-Jun-09 14:53 caustic/lenses/__init__.py
--rw-rw-r--  2.0 unx    16265 b- defN 23-Jun-09 14:53 caustic/lenses/base.py
--rw-rw-r--  2.0 unx     7239 b- defN 23-Jun-09 14:53 caustic/lenses/epl.py
--rw-rw-r--  2.0 unx     3617 b- defN 23-Jun-09 14:53 caustic/lenses/external_shear.py
--rw-rw-r--  2.0 unx     5481 b- defN 23-Jun-09 14:53 caustic/lenses/multiplane.py
--rw-rw-r--  2.0 unx    10539 b- defN 23-Jun-09 14:53 caustic/lenses/nfw.py
--rw-rw-r--  2.0 unx    14235 b- defN 23-Jun-09 14:53 caustic/lenses/pixelated_convergence.py
--rw-rw-r--  2.0 unx     3951 b- defN 23-Jun-09 14:53 caustic/lenses/point.py
--rw-rw-r--  2.0 unx     7521 b- defN 23-Jun-09 14:53 caustic/lenses/pseudo_jaffe.py
--rw-rw-r--  2.0 unx     4488 b- defN 23-Jun-09 14:53 caustic/lenses/sie.py
--rw-rw-r--  2.0 unx     3365 b- defN 23-Jun-09 14:53 caustic/lenses/singleplane.py
--rw-rw-r--  2.0 unx     3434 b- defN 23-Jun-09 14:53 caustic/lenses/sis.py
--rw-rw-r--  2.0 unx     2458 b- defN 23-Jun-09 14:53 caustic/lenses/utils.py
--rw-rw-r--  2.0 unx       89 b- defN 23-Jun-09 14:53 caustic/sources/__init__.py
--rw-rw-r--  2.0 unx     2000 b- defN 23-Jun-09 14:53 caustic/sources/base.py
--rw-rw-r--  2.0 unx     3253 b- defN 23-Jun-09 14:53 caustic/sources/pixelated.py
--rw-rw-r--  2.0 unx      792 b- defN 23-Jun-09 14:53 caustic/sources/probes.py
--rw-rw-r--  2.0 unx     4876 b- defN 23-Jun-09 14:53 caustic/sources/sersic.py
--rw-rw-r--  2.0 unx     1076 b- defN 23-Jun-09 14:55 caustic-0.4.0.dist-info/LICENSE
--rw-rw-r--  2.0 unx     3393 b- defN 23-Jun-09 14:55 caustic-0.4.0.dist-info/METADATA
--rw-rw-r--  2.0 unx      110 b- defN 23-Jun-09 14:55 caustic-0.4.0.dist-info/WHEEL
--rw-rw-r--  2.0 unx        8 b- defN 23-Jun-09 14:55 caustic-0.4.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2896 b- defN 23-Jun-09 14:55 caustic-0.4.0.dist-info/RECORD
-36 files, 154877 bytes uncompressed, 40026 bytes compressed:  74.2%
+Zip file size: 46817 bytes, number of entries: 37
+-rw-rw-r--  2.0 unx      246 b- defN 23-Jul-13 15:14 caustic/__init__.py
+-rw-rw-r--  2.0 unx      598 b- defN 23-Jul-11 16:51 caustic/constants.py
+-rw-rw-r--  2.0 unx     9172 b- defN 23-Jul-12 17:48 caustic/cosmology.py
+-rw-rw-r--  2.0 unx     3685 b- defN 23-Jul-11 16:51 caustic/forward_raytrace.py
+-rw-rw-r--  2.0 unx     5899 b- defN 23-Jul-11 16:51 caustic/namespace_dict.py
+-rw-rw-r--  2.0 unx      155 b- defN 23-Jul-11 16:51 caustic/packed.py
+-rw-rw-r--  2.0 unx     2936 b- defN 23-Jul-13 15:13 caustic/parameter.py
+-rw-rw-r--  2.0 unx    19075 b- defN 23-Jul-13 15:13 caustic/parametrized.py
+-rw-rw-r--  2.0 unx      654 b- defN 23-Jul-13 15:13 caustic/simulator.py
+-rw-rw-r--  2.0 unx    11725 b- defN 23-Jul-13 15:13 caustic/utils.py
+-rw-rw-r--  2.0 unx       80 b- defN 23-Jul-11 16:51 caustic/data/__init__.py
+-rw-rw-r--  2.0 unx     1563 b- defN 23-Jul-11 16:51 caustic/data/hdf5dataset.py
+-rw-rw-r--  2.0 unx      683 b- defN 23-Jul-11 16:51 caustic/data/illustris_kappa.py
+-rw-rw-r--  2.0 unx      675 b- defN 23-Jul-11 16:51 caustic/data/probes.py
+-rw-rw-r--  2.0 unx      259 b- defN 23-Jul-11 16:51 caustic/lenses/__init__.py
+-rw-rw-r--  2.0 unx    16300 b- defN 23-Jul-11 16:51 caustic/lenses/base.py
+-rw-rw-r--  2.0 unx     7457 b- defN 23-Jul-12 17:48 caustic/lenses/epl.py
+-rw-rw-r--  2.0 unx     3823 b- defN 23-Jul-12 17:48 caustic/lenses/external_shear.py
+-rw-rw-r--  2.0 unx     5623 b- defN 23-Jul-12 17:48 caustic/lenses/multiplane.py
+-rw-rw-r--  2.0 unx    10748 b- defN 23-Jul-12 17:48 caustic/lenses/nfw.py
+-rw-rw-r--  2.0 unx    14158 b- defN 23-Jul-13 15:13 caustic/lenses/pixelated_convergence.py
+-rw-rw-r--  2.0 unx     4096 b- defN 23-Jul-12 17:48 caustic/lenses/point.py
+-rw-rw-r--  2.0 unx     7740 b- defN 23-Jul-13 15:13 caustic/lenses/pseudo_jaffe.py
+-rw-rw-r--  2.0 unx     4637 b- defN 23-Jul-12 17:48 caustic/lenses/sie.py
+-rw-rw-r--  2.0 unx     3489 b- defN 23-Jul-12 17:48 caustic/lenses/singleplane.py
+-rw-rw-r--  2.0 unx     3578 b- defN 23-Jul-12 17:48 caustic/lenses/sis.py
+-rw-rw-r--  2.0 unx     2458 b- defN 23-Jul-11 16:51 caustic/lenses/utils.py
+-rw-rw-r--  2.0 unx       89 b- defN 23-Jul-11 16:51 caustic/sources/__init__.py
+-rw-rw-r--  2.0 unx     2000 b- defN 23-Jul-11 16:51 caustic/sources/base.py
+-rw-rw-r--  2.0 unx     3728 b- defN 23-Jul-13 15:13 caustic/sources/pixelated.py
+-rw-rw-r--  2.0 unx      792 b- defN 23-Jul-11 16:51 caustic/sources/probes.py
+-rw-rw-r--  2.0 unx     5002 b- defN 23-Jul-13 15:13 caustic/sources/sersic.py
+-rw-rw-r--  2.0 unx     1076 b- defN 23-Jul-13 15:15 caustic-0.4.1.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     3393 b- defN 23-Jul-13 15:15 caustic-0.4.1.dist-info/METADATA
+-rw-rw-r--  2.0 unx      110 b- defN 23-Jul-13 15:15 caustic-0.4.1.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        8 b- defN 23-Jul-13 15:15 caustic-0.4.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2978 b- defN 23-Jul-13 15:15 caustic-0.4.1.dist-info/RECORD
+37 files, 160688 bytes uncompressed, 42115 bytes compressed:  73.8%
```

## zipnote {}

```diff
@@ -6,14 +6,17 @@
 
 Filename: caustic/cosmology.py
 Comment: 
 
 Filename: caustic/forward_raytrace.py
 Comment: 
 
+Filename: caustic/namespace_dict.py
+Comment: 
+
 Filename: caustic/packed.py
 Comment: 
 
 Filename: caustic/parameter.py
 Comment: 
 
 Filename: caustic/parametrized.py
@@ -87,23 +90,23 @@
 
 Filename: caustic/sources/probes.py
 Comment: 
 
 Filename: caustic/sources/sersic.py
 Comment: 
 
-Filename: caustic-0.4.0.dist-info/LICENSE
+Filename: caustic-0.4.1.dist-info/LICENSE
 Comment: 
 
-Filename: caustic-0.4.0.dist-info/METADATA
+Filename: caustic-0.4.1.dist-info/METADATA
 Comment: 
 
-Filename: caustic-0.4.0.dist-info/WHEEL
+Filename: caustic-0.4.1.dist-info/WHEEL
 Comment: 
 
-Filename: caustic-0.4.0.dist-info/top_level.txt
+Filename: caustic-0.4.1.dist-info/top_level.txt
 Comment: 
 
-Filename: caustic-0.4.0.dist-info/RECORD
+Filename: caustic-0.4.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## caustic/__init__.py

```diff
@@ -1,8 +1,8 @@
-__version__ = '0.4.0'
+__version__ = '0.4.1'
 
 from .constants import *
 from .lenses import *
 from .cosmology import *
 from .forward_raytrace import *
 from .packed import *
 from .parametrized import *
```

## caustic/cosmology.py

```diff
@@ -5,15 +5,15 @@
 import torch
 from astropy.cosmology import default_cosmology
 from scipy.special import hyp2f1
 from torch import Tensor
 
 from .utils import interp1d
 from .constants import G_over_c2, c_Mpc_s, km_to_Mpc
-from .parametrized import Parametrized
+from .parametrized import Parametrized, unpack
 
 __all__ = (
     "h0_default",
     "critical_density_0_default",
     "Om0_default",
     "Cosmology",
     "FlatLambdaCDM",
@@ -46,15 +46,15 @@
         - Distance: Mpc
         - Mass: solar mass
 
     Attributes:
         name (str): Name of the cosmological model.
     """
 
-    def __init__(self, name: str):
+    def __init__(self, name: str = None):
         """
         Initialize the Cosmology.
 
         Args:
             name (str): Name of the cosmological model.
         """
         super().__init__(name)
@@ -70,74 +70,79 @@
 
         Returns:
             Tensor: The critical density at each redshift.
         """
         ...
 
     @abstractmethod
-    def comoving_distance(self, z: Tensor, params: Optional["Packed"] = None) -> Tensor:
+    @unpack(1)
+    def comoving_distance(self, z: Tensor, *args, params: Optional["Packed"] = None) -> Tensor:
         """
         Compute the comoving distance to redshift z.
 
         Args:
             z (Tensor): The redshifts.
             params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: The comoving distance to each redshift.
         """
         ...
 
+    @unpack(2)
     def comoving_distance_z1z2(
-        self, z1: Tensor, z2: Tensor, params: Optional["Packed"] = None
+            self, z1: Tensor, z2: Tensor, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the comoving distance between two redshifts.
 
         Args:
             z1 (Tensor): The starting redshifts.
             z2 (Tensor): The ending redshifts.
             params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: The comoving distance between each pair of redshifts.
         """
         return self.comoving_distance(z2, params) - self.comoving_distance(z1, params)
 
-    def angular_diameter_distance(self, z: Tensor, params: Optional["Packed"] = None) -> Tensor:
+    @unpack(1)
+    def angular_diameter_distance(self, z: Tensor, *args, params: Optional["Packed"] = None) -> Tensor:
         """
         Compute the angular diameter distance to redshift z.
 
         Args:
             z (Tensor): The redshifts.
             params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: The angular diameter distance to each redshift.
         """
         return self.comoving_distance(z, params) / (1 + z)
 
+    @unpack(2)
     def angular_diameter_distance_z1z2(
-        self, z1: Tensor, z2: Tensor, params: Optional["Packed"] = None
+            self, z1: Tensor, z2: Tensor, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the angular diameter distance between two redshifts.
 
         Args:
             z1 (Tensor): The starting redshifts.
             z2 (Tensor): The ending redshifts.
             params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: The angular diameter distance between each pair of redshifts.
         """
         return self.comoving_distance_z1z2(z1, z2, params) / (1 + z2)
 
+    @unpack(2)
     def time_delay_distance(
-        self, z_l: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, z_l: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the time delay distance between lens and source planes.
 
         Args:
             z_l (Tensor): The lens redshifts.
             z_s (Tensor): The source redshifts.
@@ -147,16 +152,17 @@
             Tensor: The time delay distance for each pair of lens and source redshifts.
         """
         d_l = self.angular_diameter_distance(z_l, params)
         d_s = self.angular_diameter_distance(z_s, params)
         d_ls = self.angular_diameter_distance_z1z2(z_l, z_s, params)
         return (1 + z_l) * d_l * d_s / d_ls
 
+    @unpack(2)
     def critical_surface_density(
-        self, z_l: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, z_l: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the critical surface density between lens and source planes.
 
         Args:
             z_l (Tensor): The lens redshifts.
             z_s (Tensor): The source redshifts.
@@ -174,18 +180,18 @@
 class FlatLambdaCDM(Cosmology):
     """
     Subclass of Cosmology representing a Flat Lambda Cold Dark Matter (LCDM) cosmology with no radiation.
     """
 
     def __init__(
         self,
-        name: str,
         h0: Optional[Tensor] = torch.tensor(h0_default),
         critical_density_0: Optional[Tensor] = torch.tensor(critical_density_0_default),
         Om0: Optional[Tensor] = torch.tensor(Om0_default),
+        name: str = None,
     ):
         """
         Initialize a new instance of the FlatLambdaCDM class.
 
         Args:
             name (str): Name of the cosmology.
             h0 (Optional[Tensor]): Hubble constant over 100. Default is h0_default.
@@ -213,30 +219,31 @@
             h0 (Tensor): Hubble constant.
 
         Returns:
             Tensor: Hubble distance.
         """
         return c_Mpc_s / (100 * km_to_Mpc) / h0
 
-    def critical_density(self, z: Tensor, params: Optional["Packed"] = None) -> torch.Tensor:
+    @unpack(1)
+    def critical_density(self, z: Tensor, h0, central_critical_density, Om0, *args, params: Optional["Packed"] = None) -> torch.Tensor:
         """
         Calculate the critical density at redshift z.
 
         Args:
             z (Tensor): Redshift.
             params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             torch.Tensor: Critical density at redshift z.
         """
-        _, critical_density_0, Om0 = self.unpack(params)
         Ode0 = 1 - Om0
-        return critical_density_0 * (Om0 * (1 + z) ** 3 + Ode0)
+        return central_critical_density * (Om0 * (1 + z) ** 3 + Ode0)
 
-    def _comoving_distance_helper(self, x: Tensor, params: Optional["Packed"]) -> Tensor:
+    @unpack(1)
+    def _comoving_distance_helper(self, x: Tensor, *args, params: Optional["Packed"] = None) -> Tensor:
         """
         Helper method for computing comoving distances.
 
         Args:
             x (Tensor): Input tensor.
 
         Returns:
@@ -244,27 +251,26 @@
         """
         return interp1d(
             self._comoving_distance_helper_x_grid,
             self._comoving_distance_helper_y_grid,
             torch.atleast_1d(x),
         ).reshape(x.shape)
 
-    def comoving_distance(self, z: Tensor, params: Optional["Packed"] = None) -> Tensor:
+    @unpack(1)
+    def comoving_distance(self, z: Tensor, h0, central_critical_density, Om0, *args, params: Optional["Packed"] = None) -> Tensor:
         """
         Calculate the comoving distance to redshift z.
 
         Args:
             z (Tensor): Redshift.
             params (Packed, optional): Dynamic parameter container for the computation.
 
         Returns:
             Tensor: Comoving distance to redshift z.
         """
-        h0, _, Om0 = self.unpack(params)
-
         Ode0 = 1 - Om0
         ratio = (Om0 / Ode0) ** (1 / 3)
         return (
             self.hubble_distance(h0)
             * (
                 self._comoving_distance_helper((1 + z) * ratio, params)
                 - self._comoving_distance_helper(ratio, params)
```

## caustic/parameter.py

```diff
@@ -1,11 +1,12 @@
-from typing import Optional
+from typing import Optional, Union
 
 import torch
 from torch import Tensor
+from caustic.namespace_dict import NamespaceDict
 
 __all__ = ("Parameter",)
 
 
 class Parameter:
     """
     Represents a static or dynamic parameter used for strong gravitational lensing simulations in the caustic codebase.
@@ -14,97 +15,75 @@
 
     Attributes:
         value (Optional[Tensor]): The value of the parameter.
         shape (tuple[int, ...]): The shape of the parameter.
     """
 
     def __init__(
-        self, value: Optional[Tensor] = None, shape: Optional[tuple[int, ...]] = ()
+        self, value: Optional[Union[Tensor, float]] = None, shape: Optional[tuple[int, ...]] = ()
     ):
-        """
-        Initializes an instance of the Parameter class.
-
-        Args:
-            value (Optional[Tensor], optional): The value of the parameter. Defaults to None.
-            shape (Optional[tuple[int, ...]], optional): The shape of the parameter. Defaults to an empty tuple.
-
-        Raises:
-            ValueError: If both value and shape are None, or if shape is provided and doesn't match the shape of the value.
-        """
         # Must assign one of value or shape
-        self._value = value
         if value is None:
             if shape is None:
-                raise ValueError("if value is None, a shape must be provided")
+                raise ValueError("If value is None, a shape must be provided")
+            if not isinstance(shape, tuple):
+                raise TypeError("The shape of a parameter must be a tuple")
             self._shape = shape
         else:
-            if shape is not None and shape != value.shape:
+            value = torch.as_tensor(value)
+            if shape != value.shape:
                 raise ValueError(
                     f"value's shape {value.shape} does not match provided shape {shape}"
                 )
-            self._value = value
             self._shape = value.shape
+        self._value = value
+        self._dtype = None if value is None else value.dtype
 
     @property
     def static(self) -> bool:
-        """
-        Checks if the parameter is static.
-
-        Returns:
-            bool: True if the parameter is static, False otherwise.
-        """
         return not self.dynamic
 
     @property
     def dynamic(self) -> bool:
-        """
-        Checks if the parameter is dynamic.
-
-        Returns:
-            bool: True if the parameter is dynamic, False otherwise.
-        """
         return self._value is None
 
     @property
     def value(self) -> Optional[Tensor]:
-        """
-        Returns the value of the parameter.
-
-        Returns:
-            Optional[Tensor]: The value of the parameter, or None if the parameter is dynamic.
-        """
         return self._value
+    
+    @value.setter
+    def value(self, value: Union[None, Tensor, float]):
+        if value is not None:
+            value = torch.as_tensor(value)
+            if value.shape != self.shape:
+                raise ValueError(f"Cannot set Parameter value with a different shape. Received {value.shape}, expected {self.shape}")
+        self._value = value
+        self._dtype = None if value is None else value.dtype
+    
+    @property
+    def dtype(self):
+        return self._dtype
 
     @property
     def shape(self) -> tuple[int, ...]:
-        """
-        Returns the shape of the parameter.
-
-        Returns:
-            tuple[int, ...]: The shape of the parameter.
-        """
         return self._shape
+    
+    def set_static(self):
+        self.value = None
 
-    def to(
-        self, device: Optional[torch.device] = None, dtype: Optional[torch.dtype] = None
-    ):
+    def to(self, device: Optional[torch.device] = None, dtype: Optional[torch.dtype] = None):
         """
         Moves and/or casts the values of the parameter.
 
         Args:
             device (Optional[torch.device], optional): The device to move the values to. Defaults to None.
             dtype (Optional[torch.dtype], optional): The desired data type. Defaults to None.
         """
-        if self._value is not None:
-            self._value = self._value.to(device=device, dtype=dtype)
+        if self.static:
+            self.value = self._value.to(device=device, dtype=dtype)
+        return self
 
     def __repr__(self) -> str:
-        """
-        Returns a string representation of the Parameter object.
-
-        Returns:
-            str: A string representation of the Parameter object.
-        """
         if self.static:
-            return f"Param(value={self.value})"
+            return f"Param(value={self.value}, dtype={str(self.dtype)[-1]})"
         else:
             return f"Param(shape={self.shape})"
```

## caustic/parametrized.py

```diff
@@ -1,17 +1,19 @@
 from collections import OrderedDict, defaultdict
-from itertools import chain
 from math import prod
-from operator import itemgetter
 from typing import Optional, Union
+import functools
+import inspect
 
 import torch
+import re
 from torch import Tensor
 
 from .packed import Packed
+from .namespace_dict import NamespaceDict, NestedNamespaceDict
 from .parameter import Parameter
 
 __all__ = ("Parametrized",)
 
 class Parametrized:
     """
     Represents a class with Param and Parametrized attributes, typically used to construct parts of a simulator
@@ -20,485 +22,346 @@
     This class can contain Params, Parametrized, tensor buffers or normal attributes as its attributes.
     It provides functionalities to manage these attributes, ensuring that an attribute of one type isn't rebound
     to be of a different type.
 
     TODO
     - Attributes can be Params, Parametrized, tensor buffers or just normal attributes.
     - Need to make sure an attribute of one of those types isn't rebound to be of a different type.
-    - params: generator returning all the params, with names of parent Parametrized concatenated as key.
 
     Attributes:
-        name (str): The name of the Parametrized object.
-        parents (list[Parametrized]): List of parent Parametrized objects.
+        name (str): The name of the Parametrized object. Default to class name.
+        parents (NestedNamespaceDict): Nested dictionary of parent Parametrized objects (higher level, more abstract modules).
         params (OrderedDict[str, Parameter]): Dictionary of parameters.
-        descendants (OrderedDict[str, Parametrized]): Dictionary of descendant Parametrized objects.
+        childs NestedNamespaceDict: Nested dictionary of childs Parametrized objects (lower level, more specialized modules).
         dynamic_size (int): Size of dynamic parameters.
         n_dynamic (int): Number of dynamic parameters.
         n_static (int): Number of static parameters.
     """
 
-    def __init__(self, name: str):
-        """
-        Initializes an instance of the Parametrized class.
-
-        Args:
-            name (str): The name of the Parametrized object.
-
-        Raises:
-            ValueError: If the provided name is not a string.
-        """
+    def __init__(self, name: str = None):
+        if name is None:
+            name = self._default_name()
         if not isinstance(name, str):
             raise ValueError(f"name must be a string (received {name})")
         self._name = name
-        self._parents: list[Parametrized] = []
-        self._params: OrderedDict[str, Parameter] = OrderedDict()
-        self._descendants: OrderedDict[str, Parametrized] = OrderedDict()
+        self._parents: OrderedDict[str, Parametrized] = NamespaceDict()
+        self._params: OrderedDict[str, Parameter] = NamespaceDict()
+        self._childs: OrderedDict[str, Parametrized] = NamespaceDict()
         self._dynamic_size = 0
         self._n_dynamic = 0
         self._n_static = 0
+        self._module_key_map = {}
+   
+    def _default_name(self):
+        return re.search("([A-Z])\w+", str(self.__class__)).group()
+    
+    def __getattribute__(self, key):
+        try:
+            return super().__getattribute__(key)
+        except AttributeError as e:
+            # Check if key refers to a parametrized module name (different from its attribute key)
+            _map = super().__getattribute__("_module_key_map") # use super to avoid recursion error
+            if key in _map.keys():
+                return super().__getattribute__(_map[key])
+            else:
+                raise e
+
+    def __setattr__(self, key, value):
+        try:
+            if key in self._params.keys():
+                # Redefine parameter value instead of making a new attribute
+                self._params[key].value = value
+            elif isinstance(value, Parameter):
+                # Create new parameter and attach it as an attribute
+                self.add_param(key, value.value, value.shape)
+            elif isinstance(value, Parametrized):
+                # Update map from attribute key to module name for __getattribute__ method
+                self._module_key_map[value.name] = key
+                self.add_parametrized(value, set_attr=False) 
+                # set attr only to user defined key, not module name (self.{module.name} is still accessible, see __getattribute__ method)
+                super().__setattr__(key, value)
+            else:
+                super().__setattr__(key, value)
+        except AttributeError: # _params or another attribute in here do not exist yet
+                super().__setattr__(key, value)
 
     @property
     def name(self) -> str:
-        """
-        Returns the name of the Parametrized object.
-
-        Returns:
-            str: The name of the Parametrized object.
-        """
         return self._name
-
+    
     @name.setter
-    def name(self, newname: str):
-        """
-        Prevents the reassignment of the name attribute.
-
-        Raises:
-            NotImplementedError: Always, as reassigning the name attribute is not supported.
-        """
-        raise NotImplementedError()
-
-    def to(
-        self, device: Optional[torch.device] = None, dtype: Optional[torch.dtype] = None
-    ):
-        """
-        Moves static Params for this component and its descendants to the specified device and casts them to the specified data type.
-
-        Args:
-            device (Optional[torch.device], optional): The device to move the values to. Defaults to None.
-            dtype (Optional[torch.dtype], optional): The desired data type. Defaults to None.
-
-        Returns:
-            Parametrized: The Parametrized object itself after moving and casting.
-        """
-        for name in self._params:
-            param = self._params[name]
-            if isinstance(param, torch.Tensor):
-                self._params[name] = param.to(device, dtype)
-
-        for desc in self._descendants.values():
-            desc.to(device, dtype)
-
+    def name(self, new_name: str):
+        old_name = self.name
+        for parent in self._parents.values():
+            del parent._childs[old_name]
+            parent._childs[new_name] = self
+        for child in self._childs.values():
+            del child._parents[old_name]
+            child._parents[new_name] = self
+        self._name = new_name
+
+    def to(self, device: Optional[torch.device] = None, dtype: Optional[torch.dtype] = None):
+        """
+        Moves static Params for this component and its childs to the specified device and casts them to the specified data type.
+        """
+        for name, p in self._params.items():
+            self._params[name] = p.to(device, dtype)
+        for child in self._childs.values():
+            child.to(device, dtype)
         return self
 
-    def _can_add(self, p: "Parametrized") -> bool:
-        """
-        Checks if a different model component with the same name is already in the DAG (Directed Acyclic Graph).
-
-        Args:
-            p (Parametrized): The Parametrized object to check.
-
-        Returns:
-            bool: False if a different model component with the same name is already in the DAG, True otherwise.
-        """
-        if self.name == p.name and self is not p:
-            return False
-
-        if p.name in self._descendants and self._descendants[p.name] is not p:
-            return False
-
-        # Propagate up through all parents
-        for parent in self._parents:
-            if not parent._can_add(p):
-                return False
-
-        return True
-
-    def _merge_descendants_up(self, p: "Parametrized"):
-        """
-        Merges the descendants of the given Parametrized object into this object's descendants,
-        and does the same for all parent objects.
-
-        Args:
-            p (Parametrized): The Parametrized object to merge descendants from.
-        """
-        self._descendants[p.name] = p
-        for desc in p._descendants.values():
-            self._descendants[desc.name] = desc
-
-        # Recur up into parents
-        for parent in self._parents:
-            parent._merge_descendants_up(p)
+    @staticmethod
+    def _generate_unique_name(name, module_names):
+        i = 1
+        while f"{name}_{i}" in module_names:
+            i += 1
+        return f"{name}_{i}"
+                
+    def add_parametrized(self, p: "Parametrized", set_attr=True):
+        """
+        Add a child to this module, and create edges for the DAG
+        """
+        # If self.name is already in the module parents, we need to update self.name
+        if self.name in p._parents.keys():
+            new_name = self._generate_unique_name(self.name, p._parents.keys())
+            self.name = new_name # from name.setter, this updates the DAG edges as well
+        p._parents[self.name] = self
+        # If the module name is already in self._childs, we need to update module name
+        if p.name is self._childs.keys():
+            new_name = self._generate_unique_name(p.name, self._childs.keys())
+            p.name = new_name
+        self._childs[p.name] = p
+        if set_attr:
+            super().__setattr__(p.name, p)
 
     def add_param(
         self,
         name: str,
-        value: Optional[Tensor] = None,
+        value: Optional[Union[Tensor, float]] = None,
         shape: Optional[tuple[int, ...]] = (),
     ):
         """
         Stores a parameter in the _params dictionary and records its size.
 
         Args:
             name (str): The name of the parameter.
             value (Optional[Tensor], optional): The value of the parameter. Defaults to None.
             shape (Optional[tuple[int, ...]], optional): The shape of the parameter. Defaults to an empty tuple.
         """
         self._params[name] = Parameter(value, shape)
-        if value is None:
-            assert isinstance(shape, tuple)  # quiet pyright error
+        # __setattr__ inside add_param to catch all uses of this method
+        super().__setattr__(name, self._params[name]) 
+        if getattr(self, name).dynamic:
             size = prod(shape)
             self._dynamic_size += size
             self._n_dynamic += 1
         else:
             self._n_static += 1
 
-    def add_parametrized(self, p: "Parametrized"):
-        """
-        Adds a Parametrized object to the current Parametrized object's descendants.
-
-        Args:
-            p (Parametrized): The Parametrized object to be added.
-
-        Raises:
-            KeyError: If a component with the same name already exists in the model DAG.
-        """
-        # Check if new component can be added
-        if not self._can_add(p):
-            val_str = (
-                str(p)
-                .replace("(\n    ", "(")
-                .replace("\n)", ")")
-                .replace("\n    ", " ")
-            )
-            raise KeyError(
-                f"cannot add {val_str}: a component with the name '{p.name}' "
-                "already exists in the model DAG"
-            )
-
-        # Check if its descendants can be added
-        for name, desc in p._descendants.items():
-            if not self._can_add(desc):
-                val_str = (
-                    str(p)
-                    .replace("(\n", "(")
-                    .replace("\n)", ")")
-                    .replace("\n    ", " ")
-                )
-                raise KeyError(
-                    f"cannot add {val_str}: its descendant '{name}' already exists "
-                    "in the model DAG"
-                )
-
-        # Add new component and its descendants to this component's descendants,
-        # as well as those of its parents
-        self._merge_descendants_up(p)
-
-        # Add this component as a parent for the new one
-        p._parents.append(self)
-
-    def __setattr__(self, key, val):
-        """
-        Overrides the __setattr__ method to add custom behavior for Parametrized and Parameter objects.
-
-        Args:
-            key (str): The attribute name.
-            val (any): The attribute value.
-
-        Raises:
-            ValueError: If the value is a Parameter object (these should be added using add_param() instead).
-        """
-        if isinstance(val, Parameter):
-            raise ValueError(
-                "cannot add Params directly as attributes: use add_param instead"
-            )
-        elif isinstance(val, Parametrized):
-            self.add_parametrized(val)
-            super().__setattr__(key, val)
-        else:
-            super().__setattr__(key, val)
-
     @property
     def n_dynamic(self) -> int:
-        """
-        Returns the number of dynamic arguments in this Parametrized object.
-
-        Returns:
-            int: The number of dynamic arguments.
-        """
         return self._n_dynamic
 
     @property
     def n_static(self) -> int:
-        """
-        Returns the number of static arguments in this Parametrized object.
-
-        Returns:
-            int: The number of static arguments.
-        """
         return self._n_static
 
     @property
     def dynamic_size(self) -> int:
-        """
-        Returns the total number of dynamic values in this Parametrized object.
-
-        Returns:
-            int: The total number of dynamic values.
-        """
         return self._dynamic_size
 
     def pack(
         self,
         x: Union[
             list[Tensor],
             dict[str, Union[list[Tensor], Tensor, dict[str, Tensor]]],
             Tensor,
-        ],
+        ] = Packed(),
     ) -> Packed:
         """
         Converts a list or tensor into a dict that can subsequently be unpacked
-        into arguments to this component and its descendants.
+        into arguments to this component and its childs. Also, add a batch dimension 
+        to each Tensor without such a dimension.
 
         Args:
             x (Union[list[Tensor], dict[str, Union[list[Tensor], Tensor, dict[str, Tensor]]], Tensor):
                 The input to be packed. Can be a list of tensors, a dictionary of tensors, or a single tensor.
 
         Returns:
-            Packed: The packed input.
+            Packed: The packed input, and whether or not the input was batched.
 
         Raises:
             ValueError: If the input is not a list, dictionary, or tensor.
             ValueError: If the input is a dictionary and some keys are missing.
             ValueError: If the number of dynamic arguments does not match the expected number.
             ValueError: If the input is a tensor and the shape does not match the expected shape.
         """
         if isinstance(x, (dict, Packed)):
-            missing_names = [
-                name for name in chain([self.name], self._descendants) if name not in x
-            ]
+            missing_names = [name for name in self.params.dynamic.keys() if name not in x]
             if len(missing_names) > 0:
                 raise ValueError(f"missing x keys for {missing_names}")
 
             # TODO: check structure!
-
             return Packed(x)
-        elif isinstance(x, list) or isinstance(x, tuple):
+        
+        
+        elif isinstance(x, (list, tuple)):
             n_passed = len(x)
-            n_expected = (
-                sum([desc.n_dynamic for desc in self._descendants.values()])
-                + self.n_dynamic
-            )
-            if n_passed != n_expected:
-                # TODO: give component and arg names
+            n_dynamic_params = len(self.params.dynamic.flatten())
+            n_dynamic_modules = len(self.dynamic_modules)
+            x_repacked = {}
+            if n_passed == n_dynamic_params:
+                cur_offset = 0
+                for name, module in self.dynamic_modules.items():
+                    x_repacked[name] = x[cur_offset : cur_offset + module.n_dynamic]
+                    cur_offset += module.n_dynamic
+            elif n_passed == n_dynamic_modules:
+                for i, name in enumerate(self.dynamic_modules.keys()):
+                    x_repacked[name] = x[i] 
+            else:
                 raise ValueError(
-                    f"{n_passed} dynamic args were passed, but {n_expected} are "
-                    "required."
+                    f"{n_passed} dynamic args were passed, but {n_dynamic_params} parameters or "
+                    f"{n_dynamic_modules} Tensor (1 per dynamic module) are required"
                 )
-
-            cur_offset = self.n_dynamic
-            x_repacked = {self.name: x[:cur_offset]}
-            for desc in self._descendants.values():
-                x_repacked[desc.name] = x[cur_offset : cur_offset + desc.n_dynamic]
-                cur_offset += desc.n_dynamic
-
             return Packed(x_repacked)
+        
         elif isinstance(x, Tensor):
             n_passed = x.shape[-1]
-            n_expected = (
-                sum([desc.dynamic_size for desc in self._descendants.values()])
-                + self.dynamic_size
-            )
+            n_expected = sum([module.dynamic_size for module in self.dynamic_modules.values()]) 
             if n_passed != n_expected:
                 # TODO: give component and arg names
                 raise ValueError(
-                    f"{n_passed} flattened dynamic args were passed, but {n_expected}"
-                    " are required"
+                    f"{n_passed} flattened dynamic args were passed, but {n_expected} "
+                    f"are required"
                 )
 
-            cur_offset = self.dynamic_size
-            x_repacked = {self.name: x[..., :cur_offset]}
-            for desc in self._descendants.values():
-                x_repacked[desc.name] = x[
-                    ..., cur_offset : cur_offset + desc.dynamic_size
-                ]
-                cur_offset += desc.dynamic_size
-
+            cur_offset = 0
+            x_repacked = {}
+            for name, module in self.dynamic_modules.items():
+                x_repacked[name] = x[..., cur_offset : cur_offset + module.dynamic_size]
+                cur_offset += module.dynamic_size
             return Packed(x_repacked)
+
         else:
-            raise ValueError("can only repack a list or 1D tensor")
+            raise ValueError("Data structure not supported")
 
     def unpack(
         self, x: Optional[dict[str, Union[list[Tensor], dict[str, Tensor], Tensor]]]
     ) -> list[Tensor]:
         """
         Unpacks a dict of kwargs, list of args or flattened vector of args to retrieve
-        this object's static and dynamic parameters.
+        this object's static and dynamic parameters. 
 
         Args:
             x (Optional[dict[str, Union[list[Tensor], dict[str, Tensor], Tensor]]]):
                 The packed object to be unpacked.
 
         Returns:
-            list[Tensor]: Unpacked static and dynamic parameters of the object.
+            list[Tensor]: Unpacked static and dynamic parameters of the object. Note that
+            parameters will have an added batch dimension from the pack method.
 
         Raises:
             ValueError: If the input is not a dict, list, tuple or tensor.
-            ValueError: If a static parameter is passed dynamically.
             ValueError: If the argument type is invalid. It must be a dict containing key {self.name}
                 and value containing args as list or flattened tensor, or kwargs.
         """
-        my_x = defaultdict(list) if x is None else x[self.name]
-        if isinstance(my_x, dict):
-            # Parse dynamic kwargs
-            args = []
-            for name, p in self._params.items():
-                if p.value is None:
-                    # Dynamic Param
-                    args.append(my_x[name])
-                else:
-                    if name in my_x:
-                        raise ValueError(
-                            f"{name} was passed dynamically as a kwarg for {self.name}, "
-                            "but it is a static parameter"
-                        )
-
-                    args.append(p.value)
-
-            return args
-        elif isinstance(my_x, list) or isinstance(x, tuple):
-            # Parse dynamic args
-            vals = []
-            offset = 0
-            for param in self._params.values():
-                if not param.dynamic:
-                    vals.append(param.value)
-                else:
-                    vals.append(my_x[offset])
+        # Check if module has dynamic parameters
+        if self.module_params.dynamic:
+            dynamic_x = x[self.name]
+        else: # all parameters are static and module is not present in x
+            dynamic_x = []
+            if isinstance(x, dict):
+                if self.name in x.keys() and x.get(self.name, {}):
+                    print(f"Module {self.name} is static, the parameters {' '.join(x[self.name].keys())} passed dynamically will be ignored ignored")
+        unpacked_x = []
+        offset = 0
+        for name, param in self._params.items():
+            if param.dynamic:
+                if isinstance(dynamic_x, dict):
+                    param_value = dynamic_x[name]
+                elif isinstance(dynamic_x, (list, tuple)):
+                    param_value = dynamic_x[offset]
                     offset += 1
-
-            return vals
-        elif isinstance(my_x, Tensor):
-            # Parse dynamic parameter vector
-            vals = []
-            offset = 0
-            for param in self._params.values():
-                if not param.dynamic:
-                    vals.append(param.value)
-                else:
+                elif isinstance(dynamic_x, Tensor):
                     size = prod(param.shape)
-                    vals.append(my_x[..., offset : offset + size].reshape(param.shape))
+                    param_value = dynamic_x[..., offset: offset + size].reshape(param.shape)
                     offset += size
-
-            return vals
+                else:
+                    raise ValueError(f"Invalid data type found when unpacking parameters for {self.name}."
+                                     f"Expected argument of unpack to be a list/tuple/dict of Tensor, or simply a flattened tensor"
+                                     f"but found {type(dynamic_x)}.")
+            else: # param is static
+                param_value = param.value
+            if not isinstance(param_value, Tensor):
+                raise ValueError(f"Invalid data type found when unpacking parameters for {self.name}."
+                                 f"Argument of unpack must contain Tensor, but found {type(param_value)}")
+            unpacked_x.append(param_value)
+        if len(unpacked_x) == 1:
+            return unpacked_x[0]
         else:
-            raise ValueError(
-                f"invalid argument type: must be a dict containing key {self.name} "
-                "and value containing args as list or flattened tensor, or kwargs"
-            )
-
-    def __getattribute__(self, key):
-        """
-        Enables accessing static params as attributes.
-
-        Args:
-            key (str): Name of the attribute.
-
-        Returns:
-            Any: The attribute value if found.
-
-        Raises:
-            AttributeError: If the attribute is not found and it's not a static parameter.
-        """
-        try:
-            return super().__getattribute__(key)
-        except AttributeError as e:
-            try:
-                param = self._params[key]
-                if not param.dynamic:
-                    return param
-            except:
-                raise e
+            return unpacked_x
 
     @property
-    def params(self) -> dict[str, OrderedDict[str, Parameter]]:
-        """
-        Gets all of the static and dynamic Params for this component and its descendants
-        in the correct order.
-
-        Returns:
-            dict[str, OrderedDict[str, Parameter]]: Dictionary containing all static and dynamic parameters.
-        """
-        static = OrderedDict()
-        dynamic = OrderedDict()
+    def module_params(self) -> NestedNamespaceDict:
+        static = NestedNamespaceDict()
+        dynamic = NestedNamespaceDict()
         for name, param in self._params.items():
             if param.static:
                 static[name] = param
             else:
                 dynamic[name] = param
-
-        return {"static": static, "dynamic": dynamic}
-
+        return NestedNamespaceDict([("static", static), ("dynamic", dynamic)])
+    
     @property
-    def static_params(self) -> OrderedDict[str, Parameter]:
-        """
-        Returns all the static parameters of the object.
-
-        Returns:
-            OrderedDict[str, Parameter]: An ordered dictionary of static parameters.
-        """
-        return self.params["static"]
+    def params(self) -> NestedNamespaceDict:
+        # todo make this an ordinary dict and reorder at the end.
+        static = NestedNamespaceDict()
+        dynamic = NestedNamespaceDict()
+        def _get_params(module):
+            if module.module_params.static:
+                static[module.name] = module.module_params.static
+            if module.module_params.dynamic:
+                dynamic[module.name] = module.module_params.dynamic
+            for child in module._childs.values():
+                _get_params(child)
+        _get_params(self)
+        # TODO reorder
+        return NestedNamespaceDict([("static", static), ("dynamic", dynamic)])
 
     @property
-    def dynamic_params(self) -> OrderedDict[str, Parameter]:
-        """
-        Returns all the dynamic parameters of the object.
-
-        Returns:
-            OrderedDict[str, Parameter]: An ordered dictionary of dynamic parameters.
-        """
-        return self.params["dynamic"]
+    def dynamic_modules(self) -> NamespaceDict[str, "Parametrized"]:
+        # Only catch modules with dynamic parameters
+        modules = NamespaceDict() # todo make this an ordinary dict and reorder at the end.
+        def _get_childs(module):
+            # Start from root, and move down the DAG
+            if module.module_params.dynamic:
+                modules[module.name] = module
+            if module._childs != {}:
+                for child in module._childs.values():
+                    _get_childs(child)
+        _get_childs(self)
+        # TODO reorder
+        return modules
 
     def __repr__(self) -> str:
-        """
-        Returns a string representation of the object.
-
-        Returns:
-            str: A string representation of the object.
-        """
         # TODO: change
         return str(self)
 
     def __str__(self) -> str:
-        """
-        Returns a string description of the object.
-
-        Returns:
-            str: A string description of the object.
-        """
-        static, dynamic = itemgetter("static", "dynamic")(self.params)
+        static = self.module_params.static
+        dynamic = self.module_params.dynamic
         static_str = ", ".join(list(static.keys()))
         dynamic_str = ", ".join(list(dynamic.keys()))
-
         desc_dynamic_strs = []
         if self.n_dynamic > 0:
             desc_dynamic_strs.append(f"('{self.name}': {list(dynamic.keys())})")
 
-        for n, d in self._descendants.items():
+        for n, d in self._childs.items():
             if d.n_dynamic > 0:
-                desc_dynamic_strs.append(f"('{n}': {list(d.params['dynamic'].keys())})")
+                desc_dynamic_strs.append(f"('{n}': {list(d.module_params.dynamic.keys())})")
 
         desc_dynamic_str = ", ".join(desc_dynamic_strs)
 
         return (
             f"{self.__class__.__name__}(\n"
             f"    name='{self.name}',\n"
             f"    static=[{static_str}],\n"
@@ -516,24 +379,23 @@
         Args:
             show_dynamic_params (bool, optional): If true, the dynamic parameters are shown in the graph. Defaults to False.
             show_static_params (bool, optional): If true, the static parameters are shown in the graph. Defaults to False.
 
         Returns:
             graphviz.Digraph: The graph representation of the object.
         """
-        from operator import itemgetter
-
         import graphviz
 
         def add_component(p: Parametrized, dot):
             dot.attr("node", style="solid", color="black", shape="ellipse")
             dot.node(p.name, f"{p.__class__.__name__}('{p.name}')")
 
         def add_params(p: Parametrized, dot):
-            static, dynamic = itemgetter("static", "dynamic")(p.params)
+            static = p.module_params.static
+            dynamic = p.module_params.dynamic
 
             dot.attr("node", style="solid", color="black", shape="box")
             for n in dynamic:
                 if show_dynamic_params:
                     dot.node(f"{p.name}/{n}", n)
                     dot.edge(p.name, f"{p.name}/{n}")
 
@@ -543,69 +405,63 @@
                     dot.node(f"{p.name}/{n}", n)
                     dot.edge(p.name, f"{p.name}/{n}")
 
         dot = graphviz.Digraph(strict=True)
         add_component(self, dot)
         add_params(self, dot)
 
-        for desc in self._descendants.values():
-            add_component(desc, dot)
+        for child in self._childs.values():
+            add_component(child, dot)
 
-            for parent in desc._parents:
-                if parent.name not in self._descendants and parent.name != self.name:
+            for parent in child._parents.values():
+                if parent.name not in self._childs and parent.name != self.name:
                     continue
                 add_component(parent, dot)
-                dot.edge(parent.name, desc.name)
-                add_params(desc, dot)
+                dot.edge(parent.name, child.name)
+                add_params(child, dot)
 
         return dot
 
+def unpack(n_leading_args=0):
+    def decorator(method):
+        sig = inspect.signature(method)
+        method_params = list(sig.parameters.keys())[1:]  # exclude 'self'
+        n_params = len(method_params)
+
+        @functools.wraps(method)
+        def wrapped(self, *args, **kwargs):
+            args = list(args)
+            leading_args = []
+            
+            # Handle leading args given as kwargs
+            for i in range(n_leading_args):
+                param = method_params[i]
+                if param in kwargs:
+                    leading_args.append(kwargs.pop(param))
+                elif args:
+                    leading_args.append(args.pop(0))
+                                
+            if args and isinstance(args[0], Packed):
+                x = args.pop(0)
+            elif "params" in kwargs:
+                x = kwargs["params"]
+            else:
+                # Handle args given as kwargs
+                trailing_args = []
+                for i in range(n_leading_args, n_params):
+                    param = method_params[i]
+                    if param in kwargs:
+                        trailing_args.append(kwargs.pop(param))
+                    elif args:
+                        trailing_args.append(args.pop(0))
+                if len(trailing_args) == 1 and trailing_args[0] is None:
+                    x = Packed()
+                else:
+                    x = self.pack(trailing_args)
+            unpacked_args = self.unpack(x)
+            kwargs['params'] = x
+
+            return method(self, *leading_args, *unpacked_args, **kwargs)
+
+        return wrapped
 
-# class ParametrizedList(Parametrized):
-#     """
-#     TODO
-#         - Many operations require being able to remove descendants from the DAG.
-#     """
-#
-#     def __init__(self, name: str, items: Iterable[Parametrized] = []):
-#         super().__init__(name)
-#         self._children = []
-#         self.extend(items)
-#
-#     def __getitem__(self, idx: int) -> Parametrized:
-#         return self._children[idx]
-#
-#     def __iter__(self) -> Iterator[Parametrized]:
-#         return iter(self._children)
-#
-#     def __iadd__(self, items: Iterable[Parametrized]) -> "ParametrizedList":
-#         self.extend(items)
-#         return self
-#
-#     def extend(self, items: Iterable[Parametrized]) -> "ParametrizedList":
-#         self._children.extend(items)
-#         for p in items:
-#             self.add_parametrized(p)
-#         return self
-#
-#     def append(self, item: Parametrized) -> "ParametrizedList":
-#         self._children.append(item)
-#         self.add_parametrized(item)
-#         return self
-#
-#     def __len__(self) -> int:
-#         return len(self._children)
-#
-#     def __add__(self, other: Iterable[Parametrized]) -> "ParametrizedList":
-#         raise NotImplementedError()
-#
-#     def insert(self, idx: int, item: Parametrized):
-#         raise NotImplementedError()
-#
-#     def __setitem__(self, idx: int, item: Parametrized):
-#         raise NotImplementedError()
-#
-#     def __delitem__(self, idx: Union[int, slice]):
-#         raise NotImplementedError()
-#
-#     def pop(self, idx: Union[int, slice]) -> Parametrized:
-#         raise NotImplementedError()
+    return decorator
```

## caustic/simulator.py

```diff
@@ -13,8 +13,10 @@
     method.
 
     See `Parametrized` for details on how to add/access parameters.
 
     """
 
     def __call__(self, *args, **kwargs):
-        return self.forward(self.pack(args[0]), *args[1:], **kwargs)
+        packed_args = self.pack(args[0])
+        return self.forward(packed_args, *args[1:], **kwargs)
+
```

## caustic/utils.py

```diff
@@ -1,14 +1,13 @@
 from math import pi
 from typing import Callable, Optional, Tuple, Union
 
 import torch
 from torch import Tensor
 
-
 def flip_axis_ratio(q, phi):
     """
     Makes the value of 'q' positive, then swaps x and y axes if 'q' is larger than 1.
 
     Args:
         q (Tensor): Tensor containing values to be processed.
         phi (Tensor): Tensor containing the phi values for the orientation of the axes.
@@ -272,15 +271,15 @@
         wd = (x - x0) * (y - y0)
 
         result = fa * wa + fb * wb + fc * wc + fd * wd
     else:
         raise ValueError(f"{method} is not a valid interpolation method")
 
     if padding_mode == "zeros":  # else padding_mode == "extrapolate"
-        result[idxs_out_of_bounds] = torch.zeros_like(result[idxs_out_of_bounds])
+        result = torch.where(idxs_out_of_bounds, torch.zeros_like(result), result)
 
     return result
 
 
 def vmap_n(
     func: Callable,
     depth: int = 1,
```

## caustic/lenses/base.py

```diff
@@ -1,9 +1,9 @@
 from abc import abstractmethod
-from typing import Any, Optional
+from typing import Any, Optional, Union
 from functools import partial
 import warnings
 
 import torch
 from torch import Tensor
 
 from ..constants import arcsec_to_rad, c_Mpc_s
@@ -18,15 +18,15 @@
     Base class for modeling gravitational lenses that cannot be treated using the thin lens approximation.
     It is an abstract class and should be subclassed for different types of lens models.
 
     Attributes:
         cosmology (Cosmology): An instance of a Cosmology class that describes the cosmological parameters of the model.
     """
 
-    def __init__(self, name: str, cosmology: Cosmology):
+    def __init__(self, cosmology: Cosmology, name: str = None):
         """
         Initializes a new instance of the ThickLens class.
 
         Args:
             name (str): The name of the lens model.
             cosmology (Cosmology): An instance of a Cosmology class that describes the cosmological parameters of the model.
         """
@@ -174,15 +174,15 @@
     Args:
         name (str): Name of the lens model.
         cosmology (Cosmology): Cosmology object that encapsulates cosmological parameters and distances.
         z_l (Optional[Tensor], optional): Redshift of the lens. Defaults to None.
 
     """
 
-    def __init__(self, name: str, cosmology: Cosmology, z_l: Optional[Tensor] = None):
+    def __init__(self, cosmology: Cosmology, z_l: Optional[Union[Tensor, float]] = None, name: str = None):
         super().__init__(name)
         self.cosmology = cosmology
         self.add_param("z_l", z_l)
 
     @abstractmethod
     def reduced_deflection_angle(
         self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
```

## caustic/lenses/epl.py

```diff
@@ -1,15 +1,16 @@
-from typing import Any, Optional
+from typing import Any, Optional, Union
 
 import torch
 from torch import Tensor
 
 from ..cosmology import Cosmology
 from ..utils import derotate, translate_rotate
 from .base import ThinLens
+from ..parametrized import unpack
 
 __all__ = ("EPL",)
 
 
 class EPL(ThinLens):
     """
     Elliptical power law (EPL, aka singular power-law ellipsoid) profile.
@@ -18,36 +19,36 @@
     iteratively using an approach based on Tessore et al. 2015.
 
     Attributes:
         n_iter (int): Number of iterations for the iterative solver.
         s (float): Softening length for the elliptical power-law profile.
     
     Parameters:
-        z_l (Tensor, optional): This is the redshift of the lens. In the context of gravitational lensing, the lens is the galaxy or other mass distribution that is bending the light from a more distant source.
-        x0 and y0 (Tensors, optional): These are the coordinates of the lens center in the lens plane. The lens plane is the plane perpendicular to the line of sight in which the deflection of light by the lens is considered.
-        q (Tensor, optional): This is the axis ratio of the lens, i.e., the ratio of the minor axis to the major axis of the elliptical lens.
-        phi (Tensor, optional): This is the orientation of the lens on the sky, typically given as an angle measured counter-clockwise from some reference direction.
-        b (Tensor, optional): This is the scale length of the lens, which sets the overall scale of the lensing effect. In some contexts, this is referred to as the Einstein radius.
-        t (Tensor, optional): This is the power-law slope parameter of the lens model. In the context of the EPL model, t is equivalent to the gamma parameter minus one, where gamma is the power-law index of the radial mass distribution of the lens.
+        z_l (Optional[Union[Tensor, float]]): This is the redshift of the lens. In the context of gravitational lensing, the lens is the galaxy or other mass distribution that is bending the light from a more distant source.
+        x0 and y0 (Optional[Union[Tensor, float]]): These are the coordinates of the lens center in the lens plane. The lens plane is the plane perpendicular to the line of sight in which the deflection of light by the lens is considered.
+        q (Optional[Union[Tensor, float]]): This is the axis ratio of the lens, i.e., the ratio of the minor axis to the major axis of the elliptical lens.
+        phi (Optional[Union[Tensor, float]]): This is the orientation of the lens on the sky, typically given as an angle measured counter-clockwise from some reference direction.
+        b (Optional[Union[Tensor, float]]): This is the scale length of the lens, which sets the overall scale of the lensing effect. In some contexts, this is referred to as the Einstein radius.
+        t (Optional[Union[Tensor, float]]): This is the power-law slope parameter of the lens model. In the context of the EPL model, t is equivalent to the gamma parameter minus one, where gamma is the power-law index of the radial mass distribution of the lens.
 
     """
 
     def __init__(
         self,
-        name: str,
         cosmology: Cosmology,
-        z_l: Optional[Tensor] = None,
-        x0: Optional[Tensor] = None,
-        y0: Optional[Tensor] = None,
-        q: Optional[Tensor] = None,
-        phi: Optional[Tensor] = None,
-        b: Optional[Tensor] = None,
-        t: Optional[Tensor] = None,
+        z_l: Optional[Union[Tensor, float]] = None,
+        x0: Optional[Union[Tensor, float]] = None,
+        y0: Optional[Union[Tensor, float]] = None,
+        q: Optional[Union[Tensor, float]] = None,
+        phi: Optional[Union[Tensor, float]] = None,
+        b: Optional[Union[Tensor, float]] = None,
+        t: Optional[Union[Tensor, float]] = None,
         s: float = 0.0,
         n_iter: int = 18,
+        name: str = None,
     ):
         """
         Initialize an EPL lens model.
 
         Args:
             name (str): Name of the lens model.
             cosmology (Cosmology): Cosmology object that provides cosmological distance calculations.
@@ -57,43 +58,42 @@
             q (Optional[Tensor]): Axis ratio of the lens. If not provided, it is considered as a free parameter.
             phi (Optional[Tensor]): Position angle of the lens. If not provided, it is considered as a free parameter.
             b (Optional[Tensor]): Scale length of the lens. If not provided, it is considered as a free parameter.
             t (Optional[Tensor]): Power law slope (`gamma-1`) of the lens. If not provided, it is considered as a free parameter.
             s (float): Softening length for the elliptical power-law profile.
             n_iter (int): Number of iterations for the iterative solver.
         """
-        super().__init__(name, cosmology, z_l)
+        super().__init__(cosmology, z_l, name=name)
 
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("q", q)
         self.add_param("phi", phi)
         self.add_param("b", b)
         self.add_param("t", t)
         self.s = s
 
         self.n_iter = n_iter
 
+    @unpack(3)
     def reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, t, *args, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Compute the reduced deflection angles of the lens.
 
         Args:
             x (Tensor): X coordinates in the lens plane.
             y (Tensor): Y coordinates in the lens plane.
             z_s (Tensor): Source redshifts.
             params (Packed, optional): Dynamic parameter container for the lens model.
 
         Returns:
             tuple[Tensor, Tensor]: Reduced deflection angles in the x and y directions.
         """
-        z_l, x0, y0, q, phi, b, t = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0, phi)
 
         # follow Tessore et al 2015 (eq. 5)
         z = q * x + y * 1j
         r = torch.abs(z)
 
         # Tessore et al 2015 (eq. 23)
@@ -127,49 +127,47 @@
         for i in range(1, self.n_iter):
             factor = (2.0 * i - (2.0 - t)) / (2.0 * i + (2.0 - t))
             omega_i = -f * factor * phi * omega_i
             part_sum = part_sum + omega_i
 
         return part_sum
 
+    @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, t, *args, params: Optional["Packed"] = None
     ):
         """
         Compute the lensing potential of the lens.
 
         Args:
             x (Tensor): X coordinates in the lens plane.
             y (Tensor): Y coordinates in the lens plane.
             z_s (Tensor): Source redshifts.
             params (Packed, optional): Dynamic parameter container for the lens model.
 
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, x0, y0, q, phi, b, t = self.unpack(params)
-
         ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
         ax, ay = derotate(ax, ay, -phi)
         x, y = translate_rotate(x, y, x0, y0, phi)
         return (x * ax + y * ay) / (2 - t)
 
+    @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, t, *args, params: Optional["Packed"] = None
     ):
         """
         Compute the convergence of the lens, which describes the local density of the lens.
 
         Args:
             x (Tensor): X coordinates in the lens plane.
             y (Tensor): Y coordinates in the lens plane.
             z_s (Tensor): Source redshifts.
             params (Packed, optional): Dynamic parameter container for the lens model.
 
         Returns:
             Tensor: The convergence of the lens.
         """
-        z_l, x0, y0, q, phi, b, t = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0, phi)
         psi = (q**2 * (x**2 + self.s**2) + y**2).sqrt()
         return (2 - t) / 2 * (b / psi) ** t
```

## caustic/lenses/external_shear.py

```diff
@@ -1,96 +1,96 @@
-from typing import Any, Optional
+from typing import Any, Optional, Union
 
 from torch import Tensor
 
 from ..cosmology import Cosmology
 from ..utils import translate_rotate
 from .base import ThinLens
+from ..parametrized import unpack
 
 __all__ = ("ExternalShear",)
 
 
 class ExternalShear(ThinLens):
     """
     Represents an external shear effect in a gravitational lensing system.
 
     Attributes:
         name (str): Identifier for the lens instance.
         cosmology (Cosmology): The cosmological model used for lensing calculations.
-        z_l (Optional[Tensor]): The redshift of the lens.
-        x0, y0 (Optional[Tensor]): Coordinates of the shear center in the lens plane.
-        gamma_1, gamma_2 (Optional[Tensor]): Shear components.
+        z_l (Optional[Union[Tensor, float]]): The redshift of the lens.
+        x0, y0 (Optional[Union[Tensor, float]]): Coordinates of the shear center in the lens plane.
+        gamma_1, gamma_2 (Optional[Union[Tensor, float]]): Shear components.
 
     Note: The shear components gamma_1 and gamma_2 represent an external shear, a gravitational 
     distortion that can be caused by nearby structures outside of the main lens galaxy. 
     """
     def __init__(
         self,
-        name: str,
         cosmology: Cosmology,
-        z_l: Optional[Tensor] = None,
-        x0: Optional[Tensor] = None,
-        y0: Optional[Tensor] = None,
-        gamma_1: Optional[Tensor] = None,
-        gamma_2: Optional[Tensor] = None,
+        z_l: Optional[Union[Tensor, float]] = None,
+        x0: Optional[Union[Tensor, float]] = None,
+        y0: Optional[Union[Tensor, float]] = None,
+        gamma_1: Optional[Union[Tensor, float]] = None,
+        gamma_2: Optional[Union[Tensor, float]] = None,
+        name: str = None,
     ):
         
-        super().__init__(name, cosmology, z_l)
+        super().__init__(cosmology, z_l, name=name)
 
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("gamma_1", gamma_1)
         self.add_param("gamma_2", gamma_2)
 
+    @unpack(3)
     def reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, gamma_1, gamma_2, *args, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Calculates the reduced deflection angle.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             tuple[Tensor, Tensor]: The reduced deflection angles in the x and y directions.
         """
-        z_l, x0, y0, gamma_1, gamma_2 = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0)
         # Meneghetti eq 3.83
         a1 = x * gamma_1 + y * gamma_2
         a2 = x * gamma_2 - y * gamma_1
         return a1, a2  # I'm not sure but I think no derotation necessary
 
+    @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, gamma_1, gamma_2, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Calculates the lensing potential.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, x0, y0, gamma_1, gamma_2 = self.unpack(params)
-
         ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
         x, y = translate_rotate(x, y, x0, y0)
         return 0.5 * (x * ax + y * ay)
 
+    @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, gamma_1, gamma_2, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         The convergence is undefined for an external shear.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
```

## caustic/lenses/multiplane.py

```diff
@@ -2,14 +2,15 @@
 from typing import Any, Optional
 
 import torch
 from torch import Tensor
 
 from ..cosmology import Cosmology
 from .base import ThickLens, ThinLens
+from ..parametrized import unpack
 
 __all__ = ("Multiplane",)
 
 
 class Multiplane(ThickLens):
     """
     Class for handling gravitational lensing with multiple lens planes.
@@ -18,16 +19,16 @@
         lenses (list[ThinLens]): List of thin lenses.
 
     Args:
         name (str): Name of the lens.
         cosmology (Cosmology): Cosmological parameters used for calculations.
         lenses (list[ThinLens]): List of thin lenses.
     """
-    def __init__(self, name: str, cosmology: Cosmology, lenses: list[ThinLens]):
-        super().__init__(name, cosmology)
+    def __init__(self, cosmology: Cosmology, lenses: list[ThinLens], name: str = None):
+        super().__init__(cosmology, name=name)
         self.lenses = lenses
         for lens in lenses:
             self.add_parametrized(lens)
 
     def get_z_ls(self, params: Optional["Packed"]) -> list[Tensor]:
         """
         Get the redshifts of each lens in the multiplane.
@@ -38,16 +39,17 @@
         Returns:
             List[Tensor]: Redshifts of the lenses.
         """
         # Relies on z_l being the first element to be unpacked, which should always
         # be the case for a ThinLens
         return [lens.unpack(params)[0] for lens in self.lenses]
 
+    @unpack(3)
     def raytrace(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """Calculate the angular source positions corresponding to the
         observer positions x,y. See Margarita et al. 2013 for the
         formalism from the GLAMER -II code:
         https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.1954P/abstract
 
         Args:
@@ -103,23 +105,25 @@
             Y_i = Y_ip1
 
         # Handle edge case of lenses = []
         if X_ip1 is None or Y_ip1 is None:
             return x, y
         else:
             return X_ip1 / D_0_s, Y_ip1 / D_0_s
-        
+
+    @unpack(3)
     def effective_reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         bx, by = self.raytrace(x, y, z_s, params)
         return x - bx, y - by
 
+    @unpack(3)
     def surface_density(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Calculate the projected mass density.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
@@ -131,16 +135,17 @@
 
         Raises:
             NotImplementedError: This method is not yet implemented.
         """
         # TODO: rescale mass densities of each lens and sum
         raise NotImplementedError()
 
+    @unpack(3)
     def time_delay(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the time delay of light caused by the lensing.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
```

## caustic/lenses/nfw.py

```diff
@@ -1,23 +1,23 @@
 from math import pi
-from typing import Any, Optional
+from typing import Any, Optional, Union
 
 import torch
 from torch import Tensor
 
 from ..constants import G_over_c2, arcsec_to_rad, rad_to_arcsec
 from ..cosmology import Cosmology
 from ..utils import translate_rotate
 from .base import ThinLens
+from ..parametrized import unpack
 
 DELTA = 200.0
 
 __all__ = ("NFW",)
 
-
 class NFW(ThinLens):
     """
     NFW lens class. This class models a lens using the Navarro-Frenk-White (NFW) profile.
     The NFW profile is a spatial density profile of dark matter halo that arises in 
     cosmological simulations.
 
     Attributes:
@@ -41,49 +41,50 @@
         deflection_angle_hat: Computes the reduced deflection angle.
         deflection_angle: Computes the deflection angle.
         convergence: Computes the convergence (dimensionless surface mass density).
         potential: Computes the lensing potential.
     """
     def __init__(
         self,
-        name: str,
         cosmology: Cosmology,
-        z_l: Optional[Tensor] = None,
-        x0: Optional[Tensor] = None,
-        y0: Optional[Tensor] = None,
-        m: Optional[Tensor] = None,
-        c: Optional[Tensor] = None,
+        z_l: Optional[Union[Tensor, float]] = None,
+        x0: Optional[Union[Tensor, float]] = None,
+        y0: Optional[Union[Tensor, float]] = None,
+        m: Optional[Union[Tensor, float]] = None,
+        c: Optional[Union[Tensor, float]] = None,
         s: float = 0.0,
+        name: str = None,
     ):
         """
         Initialize an instance of the NFW lens class.
 
         Args:
             name (str): Name of the lens instance.
             cosmology (Cosmology): An instance of the Cosmology class which contains 
                 information about the cosmological model and parameters.
-            z_l (Optional[Tensor]): Redshift of the lens. Default is None.
-            x0 (Optional[Tensor]): x-coordinate of the lens center in the lens plane. 
+            z_l (Optional[Union[Tensor, float]]): Redshift of the lens. Default is None.
+            x0 (Optional[Union[Tensor, float]]): x-coordinate of the lens center in the lens plane. 
                 Default is None.
-            y0 (Optional[Tensor]): y-coordinate of the lens center in the lens plane. 
+            y0 (Optional[Union[Tensor, float]]): y-coordinate of the lens center in the lens plane. 
                 Default is None.
-            m (Optional[Tensor]): Mass of the lens. Default is None.
-            c (Optional[Tensor]): Concentration parameter of the lens. Default is None.
+            m (Optional[Union[Tensor, float]]): Mass of the lens. Default is None.
+            c (Optional[Union[Tensor, float]]): Concentration parameter of the lens. Default is None.
             s (float): Softening parameter to avoid singularities at the center of the lens. 
                 Default is 0.0.
         """
-        super().__init__(name, cosmology, z_l)
+        super().__init__(cosmology, z_l, name=name)
 
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("m", m)
         self.add_param("c", c)
         self.s = s
 
-    def get_scale_radius(self, z_l, m, c, params: Optional["Packed"]) -> Tensor:
+    @unpack(0)
+    def get_scale_radius(self, z_l, x0, y0, m, c, *args, params: Optional["Packed"]) -> Tensor:
         """
         Calculate the scale radius of the lens.
 
         Args:
             z_l (Tensor): Redshift of the lens.
             m (Tensor): Mass of the lens.
             c (Tensor): Concentration parameter of the lens.
@@ -92,15 +93,16 @@
         Returns:
             Tensor: The scale radius of the lens in Mpc.
         """
         critical_density = self.cosmology.critical_density(z_l, params)
         r_delta = (3 * m / (4 * pi * DELTA * critical_density)) ** (1 / 3)
         return 1 / c * r_delta
 
-    def get_scale_density(self, z_l, c, params: Optional["Packed"]) -> Tensor:
+    @unpack(0)
+    def get_scale_density(self, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None) -> Tensor:
         """
         Calculate the scale density of the lens.
 
         Args:
             z_l (Tensor): Redshift of the lens.
             c (Tensor): Concentration parameter of the lens.
             params (Packed, optional): Dynamic parameter container.
@@ -112,30 +114,31 @@
             DELTA
             / 3
             * self.cosmology.critical_density(z_l, params)
             * c**3
             / ((1 + c).log() - c / (1 + c))
         )
 
-    def get_convergence_s(self, z_l, z_s, m, c, params) -> Tensor:
+    @unpack(1)
+    def get_convergence_s(self, z_s, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None) -> Tensor:
         """
         Calculate the dimensionless surface mass density of the lens.
 
         Args:
             z_l (Tensor): Redshift of the lens.
             z_s (Tensor): Redshift of the source.
             m (Tensor): Mass of the lens.
             c (Tensor): Concentration parameter of the lens.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The dimensionless surface mass density of the lens.
         """
         critical_surface_density = self.cosmology.critical_surface_density(z_l, z_s, params)
-        return self.get_scale_density(z_l, c, params) * self.get_scale_radius(z_l, m, c, params) / critical_surface_density
+        return self.get_scale_density(params) * self.get_scale_radius(params) / critical_surface_density
 
     @staticmethod
     def _f(x: Tensor) -> Tensor:
         """
         Helper method for computing deflection angles.
 
         Args:
@@ -194,99 +197,96 @@
                 x < 1,
                 term_1 + (1 / x).arccosh() * 1 / (1 - x**2).sqrt(),
                 1.0 + torch.tensor(1 / 2).log(),
             ),
         )
         return term_2
 
+    @unpack(3)
     def reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Compute the reduced deflection angle.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             tuple[Tensor, Tensor]: The reduced deflection angles in the x and y directions.
         """
-        z_l, x0, y0, m, c = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0)
         th = (x**2 + y**2).sqrt() + self.s
         d_l = self.cosmology.angular_diameter_distance(z_l, params)
-        scale_radius = self.get_scale_radius(z_l, m, c, params)
+        scale_radius = self.get_scale_radius(params)
         xi = d_l * th * arcsec_to_rad
         r = xi / scale_radius
 
         deflection_angle = (
             16
             * pi
             * G_over_c2
-            * self.get_scale_density(z_l, c, params)
+            * self.get_scale_density(params)
             * scale_radius**3
             * self._h(r)
             * rad_to_arcsec
             / xi
         )
 
         ax = deflection_angle * x / th
         ay = deflection_angle * y / th
         d_s = self.cosmology.angular_diameter_distance(z_s, params)
         d_ls = self.cosmology.angular_diameter_distance_z1z2(z_l, z_s, params)
         return ax * d_ls / d_s, ay * d_ls / d_s
 
+    @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the convergence (dimensionless surface mass density).
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The convergence (dimensionless surface mass density).
         """
-        z_l, x0, y0, m, c = self.unpack(params)
-        
         x, y = translate_rotate(x, y, x0, y0)
         th = (x**2 + y**2).sqrt() + self.s
         d_l = self.cosmology.angular_diameter_distance(z_l, params)
-        scale_radius = self.get_scale_radius(z_l, m, c, params)
+        scale_radius = self.get_scale_radius(params)
         xi = d_l * th * arcsec_to_rad
         r = xi / scale_radius  # xi / xi_0
-        convergence_s = self.get_convergence_s(z_l, z_s, m, c, params)
+        convergence_s = self.get_convergence_s(z_s, params)
         return 2 * convergence_s * self._f(r) / (r**2 - 1)
 
+    @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the lensing potential.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, x0, y0, m, c = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0)
         th = (x**2 + y**2).sqrt() + self.s
         d_l = self.cosmology.angular_diameter_distance(z_l, params)
-        scale_radius = self.get_scale_radius(z_l, m, c, params)
+        scale_radius = self.get_scale_radius(params)
         xi = d_l * th * arcsec_to_rad
         r = xi / scale_radius  # xi / xi_0
-        convergence_s = self.get_convergence_s(z_l, z_s, m, c, params)
+        convergence_s = self.get_convergence_s(z_s, params)
         return 2 * convergence_s * self._g(r) * scale_radius**2 / (d_l**2 * arcsec_to_rad**2)
```

## caustic/lenses/pixelated_convergence.py

```diff
@@ -5,31 +5,32 @@
 import torch.nn.functional as F
 from scipy.fft import next_fast_len
 from torch import Tensor
 
 from ..cosmology import Cosmology
 from ..utils import get_meshgrid, interp2d, safe_divide, safe_log
 from .base import ThinLens
+from ..parametrized import unpack
 
 __all__ = ("PixelatedConvergence",)
 
 class PixelatedConvergence(ThinLens):
     def __init__(
         self,
-        name: str,
         fov: float,
         n_pix: int,
         cosmology: Cosmology,
         z_l: Optional[Tensor] = None,
         x0: Optional[Tensor] = torch.tensor(0.0),
         y0: Optional[Tensor] = torch.tensor(0.0),
         convergence_map: Optional[Tensor] = None,
-        convergence_map_shape: Optional[tuple[int, ...]] = None,
+        shape: Optional[tuple[int, ...]] = None,
         convolution_mode: str = "fft",
         use_next_fast_len: bool = True,
+        name: str = None,
     ):
         """Strong lensing with user provided kappa map
 
         PixelatedConvergence is a class for strong gravitational lensing with a
         user-provided kappa map. It inherits from the ThinLens class.
         This class enables the computation of deflection angles and
         lensing potential by applying the user-provided kappa map to a
@@ -41,37 +42,37 @@
             fov (float): The field of view in arcseconds.
             n_pix (int): The number of pixels on each side of the grid.
             cosmology (Cosmology): An instance of the cosmological parameters.
             z_l (Optional[Tensor]): The redshift of the lens.
             x0 (Optional[Tensor]): The x-coordinate of the center of the grid.
             y0 (Optional[Tensor]): The y-coordinate of the center of the grid.
             convergence_map (Optional[Tensor]): A 2D tensor representing the convergence map.
-            convergence_map_shape (Optional[tuple[int, ...]]): The shape of the convergence map.
+            shape (Optional[tuple[int, ...]]): The shape of the convergence map.
             convolution_mode (str, optional): The convolution mode for calculating deflection angles and lensing potential.
                 It can be either "fft" (Fast Fourier Transform) or "conv2d" (2D convolution). Default is "fft".
             use_next_fast_len (bool, optional): If True, adds additional padding to speed up the FFT by calling
                 `scipy.fft.next_fast_len`. The speed boost can be substantial when `n_pix` is a multiple of a
                 small prime number. Default is True.
 
         """
         
-        super().__init__(name, cosmology, z_l)
+        super().__init__(cosmology, z_l, name=name)
 
         if convergence_map is not None and convergence_map.ndim != 2:
             raise ValueError(
-                f"convergence_map must be 2D (received {convergence_map.ndim}D tensor)"
+                f"convergence_map must be 2D. Received a {convergence_map.ndim}D tensor)"
             )
-        elif convergence_map_shape is not None and len(convergence_map_shape) != 2:
+        elif shape is not None and len(shape) != 2:
             raise ValueError(
-                f"convergence_map_shape must be 2D (received {len(convergence_map_shape)}D)"
+                f"shape must specify a 2D tensor. Received shape={shape}"
             )
 
         self.add_param("x0", x0)
         self.add_param("y0", y0)
-        self.add_param("convergence_map", convergence_map, convergence_map_shape)
+        self.add_param("convergence_map", convergence_map, shape)
 
         self.n_pix = n_pix
         self.fov = fov
         self.res = fov / n_pix
         self.use_next_fast_len = use_next_fast_len
 
         # Construct kernels
@@ -186,31 +187,30 @@
             self.ax_kernel_tilde = None
             self.ay_kernel_tilde = None
         else:
             raise ValueError("invalid convolution convolution_mode")
 
         self._convolution_mode = convolution_mode
 
+    @unpack(3)
     def reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_map, *args, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Compute the deflection angles at the specified positions using the given convergence map.
 
         Args:
             x (Tensor): The x-coordinates of the positions to compute the deflection angles for.
             y (Tensor): The y-coordinates of the positions to compute the deflection angles for.
             z_s (Tensor): The source redshift.
             params (Packed, optional): A dictionary containing additional parameters.
 
         Returns:
             tuple[Tensor, Tensor]: The x and y components of the deflection angles at the specified positions.
         """
-        z_l, x0, y0, convergence_map = self.unpack(params)
-
         if self.convolution_mode == "fft":
             deflection_angle_x_map, deflection_angle_y_map = self._deflection_angle_fft(convergence_map)
         else:
             deflection_angle_x_map, deflection_angle_y_map = self._deflection_angle_conv2d(convergence_map)
 
         # Scale is distance from center of image to center of pixel on the edge
         scale = self.fov / 2
@@ -258,31 +258,30 @@
             self.res**2 / pi
         )
         deflection_angle_y = F.conv2d(self.ay_kernel[None, None], convergence_map_flipped)[0, 0] * (
             self.res**2 / pi
         )
         return self._unpad_conv2d(deflection_angle_x), self._unpad_conv2d(deflection_angle_y)
 
+    @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_map, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the lensing potential at the specified positions using the given convergence map.
 
         Args:
         x (Tensor): The x-coordinates of the positions to compute the lensing potential for.
         y (Tensor): The y-coordinates of the positions to compute the lensing potential for.
         z_s (Tensor): The source redshift.
         params (Packed, optional): A dictionary containing additional parameters.
 
         Returns:
             Tensor: The lensing potential at the specified positions.
         """
-        z_l, x0, y0, convergence_map = self.unpack(params)
-
         if self.convolution_mode == "fft":
             potential_map = self._potential_fft(convergence_map)
         else:
             potential_map = self._potential_conv2d(convergence_map)
 
         # Scale is distance from center of image to center of pixel on the edge
         scale = self.fov / 2
@@ -320,16 +319,17 @@
         # we actually want the cross-correlation.
         convergence_map_flipped = convergence_map.flip((-1, -2))[None, None]
         potential = F.conv2d(self.potential_kernel[None, None], convergence_map_flipped)[0, 0] * (
             self.res**2 / pi
         )
         return self._unpad_conv2d(potential)
 
+    @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_map, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the convergence at the specified positions. This method is not implemented.
     
         Args:
             x (Tensor): The x-coordinates of the positions to compute the convergence for.
             y (Tensor): The y-coordinates of the positions to compute the convergence for.
@@ -338,11 +338,10 @@
     
         Returns:
             Tensor: The convergence at the specified positions.
     
         Raises:
             NotImplementedError: This method is not implemented.
         """
-        x0, y0, convergence_map, pixelscale = self.unpack(params)
         return interp2d(
             convergence_map, (x - x0).view(-1) / pixelscale, (y - y0).view(-1) / pixelscale
         ).reshape(x.shape)
```

## caustic/lenses/point.py

```diff
@@ -1,116 +1,114 @@
-from typing import Any, Optional
+from typing import Any, Optional, Union
 
 import torch
 from torch import Tensor
 
 from ..cosmology import Cosmology
 from ..utils import translate_rotate
 from .base import ThinLens
+from ..parametrized import unpack
 
 __all__ = ("Point",)
 
 class Point(ThinLens):
     """
     Class representing a point mass lens in strong gravitational lensing.
 
     Attributes:
         name (str): The name of the point lens.
         cosmology (Cosmology): The cosmology used for calculations.
-        z_l (Optional[Tensor]): Redshift of the lens.
-        x0 (Optional[Tensor]): x-coordinate of the center of the lens.
-        y0 (Optional[Tensor]): y-coordinate of the center of the lens.
-        th_ein (Optional[Tensor]): Einstein radius of the lens.
+        z_l (Optional[Union[Tensor, float]]): Redshift of the lens.
+        x0 (Optional[Union[Tensor, float]]): x-coordinate of the center of the lens.
+        y0 (Optional[Union[Tensor, float]]): y-coordinate of the center of the lens.
+        th_ein (Optional[Union[Tensor, float]]): Einstein radius of the lens.
         s (float): Softening parameter to prevent numerical instabilities.
     """
     def __init__(
         self,
-        name: str,
         cosmology: Cosmology,
-        z_l: Optional[Tensor] = None,
-        x0: Optional[Tensor] = None,
-        y0: Optional[Tensor] = None,
-        th_ein: Optional[Tensor] = None,
+        z_l: Optional[Union[Tensor, float]] = None,
+        x0: Optional[Union[Tensor, float]] = None,
+        y0: Optional[Union[Tensor, float]] = None,
+        th_ein: Optional[Union[Tensor, float]] = None,
         s: float = 0.0,
+        name: str = None,
     ):
         """
         Initialize the Point class.
 
         Args:
             name (str): The name of the point lens.
             cosmology (Cosmology): The cosmology used for calculations.
             z_l (Optional[Tensor]): Redshift of the lens.
             x0 (Optional[Tensor]): x-coordinate of the center of the lens.
             y0 (Optional[Tensor]): y-coordinate of the center of the lens.
             th_ein (Optional[Tensor]): Einstein radius of the lens.
             s (float): Softening parameter to prevent numerical instabilities.
         """
-        super().__init__(name, cosmology, z_l)
+        super().__init__(cosmology, z_l, name=name)
 
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("th_ein", th_ein)
         self.s = s
 
+    @unpack(3)
     def reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Compute the deflection angles.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             tuple[Tensor, Tensor]: The deflection angles in the x and y directions.
         """
-        z_l, x0, y0, th_ein = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0)
         th = (x**2 + y**2).sqrt() + self.s
         ax = x / th**2 * th_ein**2
         ay = y / th**2 * th_ein**2
         return ax, ay
 
+    @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the lensing potential.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, x0, y0, th_ein = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0)
         th = (x**2 + y**2).sqrt() + self.s
         return th_ein**2 * th.log()
 
+    @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the convergence (dimensionless surface mass density).
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
             z_s (Tensor): Redshifts of the sources.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The convergence (dimensionless surface mass density).
         """
-        z_l, x0, y0, th_ein = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0)
         return torch.where((x == 0) & (y == 0), torch.inf, 0.0)
```

## caustic/lenses/pseudo_jaffe.py

```diff
@@ -1,49 +1,50 @@
 from math import pi
-from typing import Any, Optional
+from typing import Any, Optional, Union
 
 import torch
 from torch import Tensor
 
 from ..cosmology import Cosmology
 from ..utils import translate_rotate
 from .base import ThinLens
+from ..parametrized import unpack
 
 __all__ = ("PseudoJaffe",)
 
 
 class PseudoJaffe(ThinLens):
     """
     Class representing a Pseudo Jaffe lens in strong gravitational lensing, 
     based on `Eliasdottir et al 2007 <https://arxiv.org/abs/0710.5636>`_ and 
     the `lenstronomy` source code.
 
     Attributes:
         name (str): The name of the Pseudo Jaffe lens.
         cosmology (Cosmology): The cosmology used for calculations.
-        z_l (Optional[Tensor]): Redshift of the lens.
-        x0 (Optional[Tensor]): x-coordinate of the center of the lens.
-        y0 (Optional[Tensor]): y-coordinate of the center of the lens.
-        convergence_0 (Optional[Tensor]): Central convergence of the lens.
-        core_radius (Optional[Tensor]): Core radius of the lens.
-        scale_radius (Optional[Tensor]): Scaling radius of the lens.
+        z_l (Optional[Union[Tensor, float]]): Redshift of the lens.
+        x0 (Optional[Union[Tensor, float]]): x-coordinate of the center of the lens.
+        y0 (Optional[Union[Tensor, float]]): y-coordinate of the center of the lens.
+        convergence_0 (Optional[Union[Tensor, float]]): Central convergence of the lens.
+        core_radius (Optional[Union[Tensor, float]]): Core radius of the lens.
+        scale_radius (Optional[Union[Tensor, float]]): Scaling radius of the lens.
         s (float): Softening parameter to prevent numerical instabilities.
     """
 
     def __init__(
         self,
-        name: str,
         cosmology: Cosmology,
-        z_l: Optional[Tensor] = None,
-        x0: Optional[Tensor] = None,
-        y0: Optional[Tensor] = None,
-        convergence_0: Optional[Tensor] = None,
-        core_radius: Optional[Tensor] = None,
-        scale_radius: Optional[Tensor] = None,
+        z_l: Optional[Union[Tensor, float]] = None,
+        x0: Optional[Union[Tensor, float]] = None,
+        y0: Optional[Union[Tensor, float]] = None,
+        convergence_0: Optional[Union[Tensor, float]] = None,
+        core_radius: Optional[Union[Tensor, float]] = None,
+        scale_radius: Optional[Union[Tensor, float]] = None,
         s: float = 0.0,
+        name: str = None,
     ):
         """
         Initialize the PseudoJaffe class.
 
         Args:
             name (str): The name of the Pseudo Jaffe lens.
             cosmology (Cosmology): The cosmology used for calculations.
@@ -51,37 +52,36 @@
             x0 (Optional[Tensor]): x-coordinate of the center of the lens.
             y0 (Optional[Tensor]): y-coordinate of the center of the lens.
             convergence_0 (Optional[Tensor]): Central convergence of the lens.
             core_radius (Optional[Tensor]): Core radius of the lens.
             scale_radius (Optional[Tensor]): Scaling radius of the lens.
             s (float): Softening parameter to prevent numerical instabilities.
         """
-        super().__init__(name, cosmology, z_l)
+        super().__init__(cosmology, z_l, name=name)
 
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("convergence_0", convergence_0)
         self.add_param("core_radius", core_radius)
         self.add_param("scale_radius", scale_radius)
         self.s = s
 
-    def mass_enclosed_2d(self, theta, z_s, params: Optional["Packed"] = None):
+    @unpack(2)
+    def mass_enclosed_2d(self, theta, z_s, z_l, x0, y0, convergence_0, core_radius, scale_radius, *args, params: Optional["Packed"] = None):
         """
         Calculate the mass enclosed within a two-dimensional radius.
 
         Args:
             theta (Tensor): Radius at which to calculate enclosed mass.
             z_s (Tensor): Source redshift.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The mass enclosed within the given radius.
         """
-        z_l, x0, y0, convergence_0, core_radius, scale_radius = self.unpack(params)
-
         theta = theta + self.s
         surface_density_0 = convergence_0 * self.cosmology.critical_surface_density(z_l, z_s, params)
         return (
             2
             * pi
             * surface_density_0
             * core_radius
@@ -92,21 +92,22 @@
                 - core_radius
                 - (scale_radius**2 + theta**2).sqrt()
                 + scale_radius
             )
         )
 
     @staticmethod
-    def convergence_0(
+    def central_convergence(
         z_l,
         z_s,
         rho_0,
         core_radius,
         scale_radius,
         cosmology: Cosmology,
+        *args,
         params: Optional["Packed"] = None,
     ):
         """
         Compute the central convergence.
 
         Args:
             z_l (Tensor): Lens redshift.
@@ -122,86 +123,83 @@
         """
         return (
             pi
             * rho_0
             * core_radius
             * scale_radius
             / (core_radius + scale_radius)
-            / cosmology.critical_surface_density(z_l, z_s, params)
+            / cosmology.critical_surface_density(z_l, z_s, params = params)
         )
 
+    @unpack(3)
     def reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_0, core_radius, scale_radius, *args, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """ Calculate the deflection angle.
 
         Args:
             x (Tensor): x-coordinate of the lens.
             y (Tensor): y-coordinate of the lens.
             z_s (Tensor): Source redshift.
             params (Packed, optional): Dynamic parameter container.
     
         Returns:
             Tuple[Tensor, Tensor]: The deflection angle in the x and y directions.
         """
-        z_l, x0, y0, convergence_0, core_radius, scale_radius = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0)
         R = (x**2 + y**2).sqrt() + self.s
         f = R / core_radius / (1 + (1 + (R / core_radius) ** 2).sqrt()) - R / scale_radius / (
             1 + (1 + (R / scale_radius) ** 2).sqrt()
         )
         alpha = 2 * convergence_0 * core_radius * scale_radius / (scale_radius - core_radius) * f
         ax = alpha * x / R
         ay = alpha * y / R
         return ax, ay
 
+    @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_0, core_radius, scale_radius, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the lensing potential. This calculation is based on equation A18.
     
         Args:
             x (Tensor): x-coordinate of the lens.
             y (Tensor): y-coordinate of the lens.
             z_s (Tensor): Source redshift.
             params (Packed, optional): Dynamic parameter container.
     
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, x0, y0, convergence_0, core_radius, scale_radius = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0)
         R_squared = x**2 + y**2 + self.s
         coeff = -2 * convergence_0 * core_radius * scale_radius / (scale_radius - core_radius)
         return coeff * (
             (scale_radius**2 + R_squared).sqrt()
             - (core_radius**2 + R_squared).sqrt()
             + core_radius * (core_radius + (core_radius**2 + R_squared).sqrt()).log()
             - scale_radius * (scale_radius + (scale_radius**2 + R_squared).sqrt()).log()
         )
 
+    @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_0, core_radius, scale_radius, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Calculate the projected mass density, based on equation A6.
     
         Args:
             x (Tensor): x-coordinate of the lens.
             y (Tensor): y-coordinate of the lens.
             z_s (Tensor): Source redshift.
             params (Packed, optional): Dynamic parameter container.
     
         Returns:
             Tensor: The projected mass density.
         """
-        z_l, x0, y0, convergence_0, core_radius, scale_radius = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0)
         R_squared = x**2 + y**2 + self.s
         coeff = convergence_0 * core_radius * scale_radius / (scale_radius - core_radius)
         return coeff * (
             1 / (core_radius**2 + R_squared).sqrt() - 1 / (scale_radius**2 + R_squared).sqrt()
         )
```

## caustic/lenses/sie.py

```diff
@@ -1,51 +1,52 @@
-from typing import Any, Optional
+from typing import Any, Optional, Union
 
 from torch import Tensor
 
 from ..cosmology import Cosmology
 from ..utils import derotate, translate_rotate
 from .base import ThinLens
+from ..parametrized import unpack
 
 __all__ = ("SIE",)
 
 
 class SIE(ThinLens):
     """
     A class representing a Singular Isothermal Ellipsoid (SIE) strong gravitational lens model. 
     This model is based on Keeton 2001, which can be found at https://arxiv.org/abs/astro-ph/0102341.
     
     Attributes:
         name (str): The name of the lens.
         cosmology (Cosmology): An instance of the Cosmology class.
-        z_l (Tensor, optional): The redshift of the lens.
-        x0 (Tensor, optional): The x-coordinate of the lens center.
-        y0 (Tensor, optional): The y-coordinate of the lens center.
-        q (Tensor, optional): The axis ratio of the lens.
-        phi (Tensor, optional): The orientation angle of the lens (position angle).
-        b (Tensor, optional): The Einstein radius of the lens.
+        z_l (Optional[Union[Tensor, float]]): The redshift of the lens.
+        x0 (Optional[Union[Tensor, float]]): The x-coordinate of the lens center.
+        y0 (Optional[Union[Tensor, float]]): The y-coordinate of the lens center.
+        q (Optional[Union[Tensor, float]]): The axis ratio of the lens.
+        phi (Optional[Union[Tensor, float]]): The orientation angle of the lens (position angle).
+        b (Optional[Union[Tensor, float]]): The Einstein radius of the lens.
         s (float): The core radius of the lens (defaults to 0.0).
     """
 
     def __init__(
         self,
-        name: str,
         cosmology: Cosmology,
-        z_l: Optional[Tensor] = None,
-        x0: Optional[Tensor] = None,
-        y0: Optional[Tensor] = None,
-        q: Optional[Tensor] = None,# TODO change to true axis ratio
-        phi: Optional[Tensor] = None,
-        b: Optional[Tensor] = None,
+        z_l: Optional[Union[Tensor, float]] = None,
+        x0: Optional[Union[Tensor, float]] = None,
+        y0: Optional[Union[Tensor, float]] = None,
+        q: Optional[Union[Tensor, float]] = None,# TODO change to true axis ratio
+        phi: Optional[Union[Tensor, float]] = None,
+        b: Optional[Union[Tensor, float]] = None,
         s: float = 0.0,
+        name: str = None,
     ):
         """
         Initialize the SIE lens model.
         """
-        super().__init__(name, cosmology, z_l)
+        super().__init__(cosmology, z_l, name=name)
 
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("q", q)
         self.add_param("phi", phi)
         self.add_param("b", b)
         self.s = s
@@ -60,78 +61,71 @@
             q (Tensor): The axis ratio of the lens.
 
         Returns:
             Tensor: The radial coordinate in the lens plane.
         """
         return (q**2 * (x**2 + self.s**2) + y**2).sqrt()
 
+    @unpack(3)
     def reduced_deflection_angle(
-        self,
-            x: Tensor,
-            y: Tensor,
-            z_s: Tensor,
-            params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, *args, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Calculate the physical deflection angle.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tuple[Tensor, Tensor]: The deflection angle in the x and y directions.
         """
-        z_l, x0, y0, q, phi, b = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0, phi)
         psi = self._get_potential(x, y, q)
         f = (1 - q**2).sqrt()
         ax = b * q.sqrt() / f * (f * x / (psi + self.s)).atan()
         ay = b * q.sqrt() / f * (f * y / (psi + q**2 * self.s)).atanh()
 
         return derotate(ax, ay, phi)
 
+    @unpack(3)
     def potential( 
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the lensing potential.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, x0, y0, q, phi, b = self.unpack(params)
-
         ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
         ax, ay = derotate(ax, ay, -phi)
         x, y = translate_rotate(x, y, x0, y0, phi)
         return x * ax + y * ay
 
+    @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Calculate the projected mass density.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The projected mass.
         """
-        z_l, x0, y0, q, phi, b = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0, phi)
         psi = self._get_potential(x, y, q)
         return 0.5 * q.sqrt() * b / psi
```

## caustic/lenses/singleplane.py

```diff
@@ -1,14 +1,15 @@
 from typing import Any, Optional
 
 import torch
 from torch import Tensor
 
 from ..cosmology import Cosmology
 from .base import ThinLens
+from ..parametrized import unpack
 
 __all__ = ("SinglePlane",)
 
 
 class SinglePlane(ThinLens):
     """
     A class for combining multiple thin lenses into a single lensing plane. 
@@ -16,26 +17,27 @@
     
     Attributes:
         name (str): The name of the single plane lens.
         cosmology (Cosmology): An instance of the Cosmology class.
         lenses (List[ThinLens]): A list of ThinLens objects that are being combined into a single lensing plane.
     """
 
-    def __init__(self, name: str, cosmology: Cosmology, lenses: list[ThinLens]):
+    def __init__(self, cosmology: Cosmology, lenses: list[ThinLens], name: str = None):
         """
         Initialize the SinglePlane lens model.
         """
-        super().__init__(name, cosmology)
+        super().__init__(cosmology, name=name)
         self.lenses = lenses
         for lens in lenses:
             self.add_parametrized(lens)
         # TODO: assert all z_l are the same?
 
+    @unpack(3)
     def reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Calculate the total deflection angle by summing the deflection angles of all individual lenses.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
@@ -49,16 +51,17 @@
         ay = torch.zeros_like(x)
         for lens in self.lenses:
             ax_cur, ay_cur = lens.reduced_deflection_angle(x, y, z_s, params)
             ax = ax + ax_cur
             ay = ay + ay_cur
         return ax, ay
 
+    @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Calculate the total projected mass density by summing the mass densities of all individual lenses.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
@@ -70,16 +73,17 @@
         """
         convergence = torch.zeros_like(x)
         for lens in self.lenses:
             convergence_cur = lens.convergence(x, y, z_s, params)
             convergence = convergence + convergence_cur
         return convergence
 
+    @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the total lensing potential by summing the lensing potentials of all individual lenses.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
```

## caustic/lenses/sis.py

```diff
@@ -1,110 +1,108 @@
-from typing import Any, Optional
+from typing import Any, Optional, Union
 
 import torch
 from torch import Tensor
 
 from ..cosmology import Cosmology
 from ..utils import translate_rotate
 from .base import ThinLens
+from ..parametrized import unpack
 
 __all__ = ("SIS",)
 
 
 class SIS(ThinLens):
     """
     A class representing the Singular Isothermal Sphere (SIS) model. 
     This model inherits from the base `ThinLens` class.
 
     Attributes:
         name (str): The name of the SIS lens.
         cosmology (Cosmology): An instance of the Cosmology class.
-        z_l (Optional[Tensor]): The lens redshift.
-        x0 (Optional[Tensor]): The x-coordinate of the lens center.
-        y0 (Optional[Tensor]): The y-coordinate of the lens center.
-        th_ein (Optional[Tensor]): The Einstein radius of the lens.
+        z_l (Optional[Union[Tensor, float]]): The lens redshift.
+        x0 (Optional[Union[Tensor, float]]): The x-coordinate of the lens center.
+        y0 (Optional[Union[Tensor, float]]): The y-coordinate of the lens center.
+        th_ein (Optional[Union[Tensor, float]]): The Einstein radius of the lens.
         s (float): A smoothing factor, default is 0.0.
     """
     def __init__(
         self,
-        name: str,
         cosmology: Cosmology,
-        z_l: Optional[Tensor] = None,
-        x0: Optional[Tensor] = None,
-        y0: Optional[Tensor] = None,
-        th_ein: Optional[Tensor] = None,
+        z_l: Optional[Union[Tensor, float]] = None,
+        x0: Optional[Union[Tensor, float]] = None,
+        y0: Optional[Union[Tensor, float]] = None,
+        th_ein: Optional[Union[Tensor, float]] = None,
         s: float = 0.0,
+        name: str = None
     ):
         """
         Initialize the SIS lens model.
         """
-        super().__init__(name, cosmology, z_l)
+        super().__init__(cosmology, z_l, name=name)
 
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("th_ein", th_ein)
         self.s = s
 
+    @unpack(3)
     def reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None
     ) -> tuple[Tensor, Tensor]:
         """
         Calculate the deflection angle of the SIS lens.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tuple[Tensor, Tensor]: The deflection angle in the x and y directions.
         """
-        z_l, x0, y0, th_ein = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0)
         R = (x**2 + y**2).sqrt() + self.s
         ax = th_ein * x / R
         ay = th_ein * y / R
         return ax, ay
 
+    @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Compute the lensing potential of the SIS lens.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The lensing potential.
         """
-        z_l, x0, y0, th_ein = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0)
         th = (x**2 + y**2).sqrt() + self.s
         return th_ein * th
 
+    @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None
     ) -> Tensor:
         """
         Calculate the projected mass density of the SIS lens.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
             z_s (Tensor): The source redshift.
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
             Tensor: The projected mass density.
         """
-        z_l, x0, y0, th_ein = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0)
         th = (x**2 + y**2).sqrt() + self.s
         return 0.5 * th_ein / th
```

## caustic/sources/pixelated.py

```diff
@@ -1,73 +1,83 @@
-from typing import Optional
+from typing import Optional, Union
 
 from torch import Tensor
+from torch import vmap
 
 from ..utils import interp2d
 from .base import Source
+from ..parametrized import unpack
 
 __all__ = ("Pixelated",)
 
 
 class Pixelated(Source):
     """
-    `Pixelated` is a subclass of the abstract class `Source`. It represents a source in a strong 
-    gravitational lensing system where the source is an image.
+    `Pixelated` is a subclass of the abstract class `Source`. It representes the brightness profile of 
+    source with a pixelated grid of intensity values.
     
     This class provides a concrete implementation of the `brightness` method required by the `Source` 
     superclass. In this implementation, brightness is determined by interpolating values from the 
     provided source image.
 
     Attributes:
         x0 (Optional[Tensor]): The x-coordinate of the source image's center. 
         y0 (Optional[Tensor]): The y-coordinate of the source image's center.
         image (Optional[Tensor]): The source image from which brightness values will be interpolated.
         pixelscale (Optional[Tensor]): The pixelscale of the source image in the lens plane in units of arcsec/pixel.
-        image_shape (Optional[tuple[int, ...]]): The shape of the source image.
+        shape (Optional[tuple[int, ...]]): The shape of the source image.
     """
     def __init__(
         self,
-        name: str,
-        x0: Optional[Tensor] = None,
-        y0: Optional[Tensor] = None,
         image: Optional[Tensor] = None, 
-        pixelscale: Optional[Tensor] = None,
-        image_shape: Optional[tuple[int, ...]] = None,
+        x0: Optional[Union[Tensor, float]] = None,
+        y0: Optional[Union[Tensor, float]] = None,
+        pixelscale: Optional[Union[Tensor, float]] = None,
+        shape: Optional[tuple[int, ...]] = None,
+        name: str = None,
     ):
         """
         Constructs the `Pixelated` object with the given parameters. 
 
         Args:
             name (str): The name of the source.
             x0 (Optional[Tensor]): The x-coordinate of the source image's center.
             y0 (Optional[Tensor]): The y-coordinate of the source image's center.
             image (Optional[Tensor]): The source image from which brightness values will be interpolated.
             pixelscale (Optional[Tensor]): The pixelscale of the source image in the lens plane in units of arcsec/pixel.
-            image_shape (Optional[tuple[int, ...]]): The shape of the source image.
+            shape (Optional[tuple[int, ...]]): The shape of the source image.
         """
-        super().__init__(name)
+        if image is not None and image.ndim not in [2, 3]:
+            raise ValueError(
+                f"image must be 2D or 3D (channels first). Received a {image.ndim}D tensor)"
+            )
+        elif shape is None and len(shape) not in [2, 3]:
+            raise ValueError(
+                f"shape must be specify 2D or 3D tensors. Received shape={shape}"
+            )
+        super().__init__(name=name)
         self.add_param("x0", x0)
         self.add_param("y0", y0)
-        self.add_param("image", image, image_shape)
+        self.add_param("image", image, shape)
         self.add_param("pixelscale", pixelscale)
 
-    def brightness(self, x, y, params: Optional["Packed"]):
+    @unpack(2)
+    def brightness(self, x, y, x0, y0, image, pixelscale, *args, params: Optional["Packed"] = None):
         """
         Implements the `brightness` method for `Pixelated`. The brightness at a given point is 
         determined by interpolating values from the source image.
 
         Args:
             x (Tensor): The x-coordinate(s) at which to calculate the source brightness. 
                 This could be a single value or a tensor of values.
             y (Tensor): The y-coordinate(s) at which to calculate the source brightness. 
                 This could be a single value or a tensor of values.
-            P (Optional[Packed]): A dictionary containing additional parameters that might be required to 
+            params (Optional[Packed]): A dictionary containing additional parameters that might be required to 
                 calculate the brightness. 
 
         Returns:
             Tensor: The brightness of the source at the given coordinate(s). The brightness is 
             determined by interpolating values from the source image.
         """
-        x0, y0, image, pixelscale = self.unpack(params)
         return interp2d(
             image, (x - x0).view(-1) / pixelscale, (y - y0).view(-1) / pixelscale
         ).reshape(x.shape)
```

## caustic/sources/sersic.py

```diff
@@ -1,14 +1,14 @@
-from typing import Optional
+from typing import Optional, Union
 
-import torch
 from torch import Tensor
 
 from ..utils import to_elliptical, translate_rotate
 from .base import Source
+from ..parametrized import unpack
 
 __all__ = ("Sersic",)
 
 
 class Sersic(Source):
     """
     `Sersic` is a subclass of the abstract class `Source`. It represents a source in a strong 
@@ -18,32 +18,32 @@
     The Sersic profile is often used to describe elliptical galaxies and spiral galaxies' bulges.
 
     Attributes:
         x0 (Optional[Tensor]): The x-coordinate of the Sersic source's center. 
         y0 (Optional[Tensor]): The y-coordinate of the Sersic source's center.
         q (Optional[Tensor]): The axis ratio of the Sersic source.
         phi (Optional[Tensor]): The orientation of the Sersic source (position angle).
-        index (Optional[Tensor]): The Sersic index, which describes the degree of concentration of the source.
+        n (Optional[Tensor]): The Sersic index, which describes the degree of concentration of the source.
         Re (Optional[Tensor]): The scale length of the Sersic source.
         Ie (Optional[Tensor]): The intensity at the effective radius.
         s (float): A small constant for numerical stability.
         lenstronomy_k_mode (bool): A flag indicating whether to use lenstronomy to compute the value of k.
     """
     def __init__(
         self,
-        name: str,
-        x0: Optional[Tensor] = None,
-        y0: Optional[Tensor] = None,
-        q: Optional[Tensor] = None,
-        phi: Optional[Tensor] = None,
-        n: Optional[Tensor] = None,
-        Re: Optional[Tensor] = None,
-        Ie: Optional[Tensor] = None,
+        x0: Optional[Union[Tensor, float]] = None,
+        y0: Optional[Union[Tensor, float]] = None,
+        q: Optional[Union[Tensor, float]] = None,
+        phi: Optional[Union[Tensor, float]] = None,
+        n: Optional[Union[Tensor, float]] = None,
+        Re: Optional[Union[Tensor, float]] = None,
+        Ie: Optional[Union[Tensor, float]] = None,
         s: float = 0.0,
         use_lenstronomy_k=False,
+        name: str = None,
     ):
         """
         Constructs the `Sersic` object with the given parameters. 
 
         Args:
             name (str): The name of the source.
             x0 (Optional[Tensor]): The x-coordinate of the Sersic source's center.
@@ -52,27 +52,28 @@
             phi (Optional[Tensor]): The orientation of the Sersic source.
             n (Optional[Tensor]): The Sersic index, which describes the degree of concentration of the source.
             Re (Optional[Tensor]): The scale length of the Sersic source.
             Ie (Optional[Tensor]): The intensity at the effective radius.
             s (float): A small constant for numerical stability.
             use_lenstronomy_k (bool): A flag indicating whether to use lenstronomy to compute the value of k.
         """
-        super().__init__(name)
+        super().__init__(name=name)
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("q", q)
         self.add_param("phi", phi)
         self.add_param("n", n)
         self.add_param("Re", Re)
         self.add_param("Ie", Ie)
         self.s = s
 
         self.lenstronomy_k_mode = use_lenstronomy_k
 
-    def brightness(self, x, y, params: Optional["Packed"] = None):
+    @unpack(2)
+    def brightness(self, x, y, x0, y0, q, phi, n, Re, Ie, *args, params: Optional["Packed"] = None):
         """
         Implements the `brightness` method for `Sersic`. The brightness at a given point is 
         determined by the Sersic profile formula.
 
         Args:
             x (Tensor): The x-coordinate(s) at which to calculate the source brightness. 
                 This could be a single value or a tensor of values.
@@ -89,16 +90,14 @@
             that describes the concentration of the source, and k is a parameter that 
             depends on n. In this implementation, we use elliptical coordinates ex and ey, 
             and the transformation from Cartesian coordinates is handled by `to_elliptical`.
             The value of k can be calculated in two ways, controlled by `lenstronomy_k_mode`. 
             If `lenstronomy_k_mode` is True, we use the approximation from Lenstronomy, 
             otherwise, we use the approximation from Ciotti & Bertin (1999).
         """
-        x0, y0, q, phi, n, Re, Ie = self.unpack(params)
-
         x, y = translate_rotate(x, y, x0, y0, phi)
         ex, ey = to_elliptical(x, y, q)
         e = (ex**2 + ey**2).sqrt() + self.s
 
         if self.lenstronomy_k_mode:
             k = 1.9992 * n - 0.3271
         else:
```

## Comparing `caustic-0.4.0.dist-info/LICENSE` & `caustic-0.4.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `caustic-0.4.0.dist-info/METADATA` & `caustic-0.4.1.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: caustic
-Version: 0.4.0
+Version: 0.4.1
 Summary: The lensing pipeline of the future.
 Author-email: Connor Stone <connorstone628@gmail.com>, Adam Coogan <dr.adam.coogan@gmail.com>
 License: MIT License
         
         Copyright (c) [2023] [caustic authors]
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
```

## Comparing `caustic-0.4.0.dist-info/RECORD` & `caustic-0.4.1.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,36 +1,37 @@
-caustic/__init__.py,sha256=f6pMQ_pIAcFJqyZT34HK4vLZKYFBDQRfMjXRhsFTH0c,246
+caustic/__init__.py,sha256=2Jkg-g2fIuwHs-_6P6EBzM-BlFyd80_bOyKloRfxJbo,246
 caustic/constants.py,sha256=DDuzUgDSeOGtqhEuhkmJIYmV4FkmqZfVm_AzvjDSIYc,598
-caustic/cosmology.py,sha256=Fpz3ud1mmeu01luVg9voPjMxrc2ooZ7fOePtWtJBdPE,8952
+caustic/cosmology.py,sha256=lp4KuhoyQPCO5bg5Jkr30NENWoXvqTm1CYuaOSUEzwI,9172
 caustic/forward_raytrace.py,sha256=K5_WUaFyfWtLgL1AgDXotxFjrsOVPBHJdNQYDnagwkc,3685
+caustic/namespace_dict.py,sha256=Py-_zjFVn_T3E_B6u12zdjJjhoR2LeamT9x7CTLn9Mc,5899
 caustic/packed.py,sha256=hSgey6KbDgfNOoxVY4pFBtp4kt_2w48nBm5wUz52nuY,155
-caustic/parameter.py,sha256=w2_ewXOPk803BwFDnRY3IYzvHBoUVnl1BiEDrhvW_-U,3380
-caustic/parametrized.py,sha256=dR55WIy3pxS5tEHv6n0UmeEzNuP2MiYY4zb5utbagWc,21171
-caustic/simulator.py,sha256=g5mnw3KOgaYsioS7gs6_gaZqVTnRRLCm9sScz5P2Ilw,619
-caustic/utils.py,sha256=yjd97KbZPsYWsPyRHbb50WWVgdl8kwUc0FfoBarK4tg,11725
+caustic/parameter.py,sha256=9MMd_okt6Gue8epOQFEI7pYRTygi5lp4-inxCbY34wY,2936
+caustic/parametrized.py,sha256=wPk0n9D-yPGVikN8NSSppf9EePhJomSw7MsIc1W7RRA,19075
+caustic/simulator.py,sha256=CnhrEfKBEu9lAou0BQPs9QxiGJ-JWlsDeINe3j3WYgg,654
+caustic/utils.py,sha256=WBSgT9NCVyM-XKxazyisj101Yi2L7IouKq19woPmknI,11725
 caustic/data/__init__.py,sha256=RPbwqLtzDvhoxLIgofTDfwNJ6qxdqObF2wgqiF86dfs,80
 caustic/data/hdf5dataset.py,sha256=yf_qEhaAE_fQTgZXhV5JfPILXrvizjH_NlVzW-GVRtM,1563
 caustic/data/illustris_kappa.py,sha256=OTBtyWAbBID9qkgtaymvpNHSAGh0KeMDiPMXcdP8C5Y,683
 caustic/data/probes.py,sha256=DyOKkkBZ34gcrIG7exm2Cu-HpjsrZv5bczQQas4xiRA,675
 caustic/lenses/__init__.py,sha256=S5Y9lAan0vdfiuVpcElcYt8EasaGB8erMCBsTeruT5M,259
-caustic/lenses/base.py,sha256=ekhX5EhfFy1aMCq91ErON2qtKRyx1LtSQECNWBNTqZ0,16265
-caustic/lenses/epl.py,sha256=qS1PNZGLNYUsREjmyXhWe9tQCy_YWHgqbVZQDZ2tWjY,7239
-caustic/lenses/external_shear.py,sha256=xGAZJjW9QsV8ixZVb7mVlG78py1K1sVO7vd7-FafkH8,3617
-caustic/lenses/multiplane.py,sha256=fw9NzCVtBDC8_9p3T7Y--Owgv3zIkjmN9mB7ifTiU3c,5481
-caustic/lenses/nfw.py,sha256=-Jm1ztAPMTrm9wMCCaxJ2v3TBOMbE-B0lZannvi75N0,10539
-caustic/lenses/pixelated_convergence.py,sha256=7HTwsqujtiR9syTesNMdawz3XPdFmIvHIGf75NjFIiw,14235
-caustic/lenses/point.py,sha256=e177dOqLilgWCk4PDuW-Snnx6bGNE9CMX9lmB1e-QZc,3951
-caustic/lenses/pseudo_jaffe.py,sha256=uyBGoErBqG2YYcWInEn0Yk0RpYxEs_73EzJRuNS8kRA,7521
-caustic/lenses/sie.py,sha256=5ca2oB8xAS3ZbHSFmi4LOcbakTkehBeXkMW6YlbsqFI,4488
-caustic/lenses/singleplane.py,sha256=8tP0hX4Rc3Jl3UpWhJnUKL4ba4rhsFWI6CZ_r9di0tI,3365
-caustic/lenses/sis.py,sha256=Bs91Y3xx5jhGYP9uZzApp-i4DKQgqbBMWyb25TU-2cU,3434
+caustic/lenses/base.py,sha256=SaadVbh9zlxZqbLd2Xdk5WxepgLJ6MN1gsLO_UbW6rA,16300
+caustic/lenses/epl.py,sha256=Pew6RTszdlYuvXTHvwoHe-2BIURu476X5xa5XtovIJg,7457
+caustic/lenses/external_shear.py,sha256=-yhn0gd3KDZOXgfacutFPKQD_4xIQSLwXcrt_vC-vx8,3823
+caustic/lenses/multiplane.py,sha256=5YCyo2pHTF5WmB6x5lla4LewQnSwSZ9WxkphmGAuzp0,5623
+caustic/lenses/nfw.py,sha256=bk05Sf6yBXRf7FK_OzAbaveIIV_U7jXf1o9dsA8tb1Y,10748
+caustic/lenses/pixelated_convergence.py,sha256=kc8kV7UWYTXjvG-LnTacB8HdAoXKe9C01Fd05pPsAgY,14158
+caustic/lenses/point.py,sha256=AwkD4Ex1KTNZPQS2b4Lhq8mka689849IIigA_XpR1Z4,4096
+caustic/lenses/pseudo_jaffe.py,sha256=fzRuSpUAqWjDMfR53F-KtjSi4mKaAFjy6jUoQiImPwI,7740
+caustic/lenses/sie.py,sha256=ZSMZgvEounNqVCiGjRXmE0PrgCF6pCuHd2bMvxSTrJw,4637
+caustic/lenses/singleplane.py,sha256=G4pQyy5KROIHMwgaeyaUr3aILIGU5kcP71uPrgGnNbU,3489
+caustic/lenses/sis.py,sha256=06StBQYIY0QwPERRnL64yZxolaMQshS2XfJF-LJgvrc,3578
 caustic/lenses/utils.py,sha256=-AT-NexgGsmGRcsmElpPmtxd0xkFgELCd70G-bvPf78,2458
 caustic/sources/__init__.py,sha256=_CK3BYNbk-S3yKBGmcbPeKpCe4QHlh6iEwT9UCJuWbU,89
 caustic/sources/base.py,sha256=mHJRfsDS1M0WJLThDCJaZJpT77rW3VqgFLgqDKyEDXI,2000
-caustic/sources/pixelated.py,sha256=PzITfYJI2HefvLPbbiFWDlY6SVsMysV8eOEww9ny40A,3253
+caustic/sources/pixelated.py,sha256=b1tB92Y6FtBWJUVmwSH10mNkyn6vHmIUZWrvIx6S5pE,3728
 caustic/sources/probes.py,sha256=aNUclNlFTsdGxdwu_dclpRza7scQBHN4AX5hP67oXtc,792
-caustic/sources/sersic.py,sha256=7UK8HJrhmVz9L1HV033rLYvh4Gk6SE2xnkZhBzcuug4,4876
-caustic-0.4.0.dist-info/LICENSE,sha256=cllh7ggKgLVBj8dXi9pC1mZkHLZlf3xxeLCSJoJIctg,1076
-caustic-0.4.0.dist-info/METADATA,sha256=A5L0MtEx8D4ER-E8nGh6aCW-J-tiGIu_DaiiHBLhpq0,3393
-caustic-0.4.0.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
-caustic-0.4.0.dist-info/top_level.txt,sha256=LQoSbW8clrogX400rPniIRZwXwEUKH2gPpPFEhl7ATs,8
-caustic-0.4.0.dist-info/RECORD,,
+caustic/sources/sersic.py,sha256=iC_sEz5czUu-Zh5NavjooTot_Lqz1-X5oYx6H3QHhfw,5002
+caustic-0.4.1.dist-info/LICENSE,sha256=cllh7ggKgLVBj8dXi9pC1mZkHLZlf3xxeLCSJoJIctg,1076
+caustic-0.4.1.dist-info/METADATA,sha256=BgiJkBu9__mBarBFuyHby2CZd8P9_X-VxTdY4s6HrSs,3393
+caustic-0.4.1.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+caustic-0.4.1.dist-info/top_level.txt,sha256=LQoSbW8clrogX400rPniIRZwXwEUKH2gPpPFEhl7ATs,8
+caustic-0.4.1.dist-info/RECORD,,
```

