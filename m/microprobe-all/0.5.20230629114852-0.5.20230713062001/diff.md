# Comparing `tmp/microprobe_all-0.5.20230629114852-py2.py3-none-any.whl.zip` & `tmp/microprobe_all-0.5.20230713062001-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,59 +1,59 @@
-Zip file size: 254909 bytes, number of entries: 74
+Zip file size: 256539 bytes, number of entries: 74
 -rw-r--r--  2.0 unx     9236 b- defN 23-Jun-21 21:07 microprobe/__init__.py
 -rw-r--r--  2.0 unx     6504 b- defN 23-Jun-21 21:07 microprobe/exceptions.py
 -rw-r--r--  2.0 unx    10213 b- defN 23-Jun-21 21:07 microprobe/property.py
--rw-r--r--  2.0 unx    25912 b- defN 23-Jun-21 21:07 microprobe/code/__init__.py
--rw-r--r--  2.0 unx    14640 b- defN 23-Jun-21 21:07 microprobe/code/address.py
--rw-r--r--  2.0 unx    11088 b- defN 23-Jun-21 21:07 microprobe/code/bbl.py
--rw-r--r--  2.0 unx    14023 b- defN 23-Jun-21 21:07 microprobe/code/benchmark.py
--rw-r--r--  2.0 unx     3379 b- defN 23-Jun-21 21:07 microprobe/code/cfg.py
--rw-r--r--  2.0 unx    18207 b- defN 23-Jun-21 22:19 microprobe/code/context.py
--rw-r--r--  2.0 unx    74582 b- defN 23-Jun-21 21:07 microprobe/code/ins.py
--rw-r--r--  2.0 unx    11674 b- defN 23-Jun-21 21:07 microprobe/code/var.py
--rw-r--r--  2.0 unx     5909 b- defN 23-Jun-21 21:07 microprobe/code/wrapper.py
+-rw-r--r--  2.0 unx    26105 b- defN 23-Jul-13 09:54 microprobe/code/__init__.py
+-rw-r--r--  2.0 unx    15338 b- defN 23-Jul-13 09:54 microprobe/code/address.py
+-rw-r--r--  2.0 unx    11440 b- defN 23-Jul-13 09:54 microprobe/code/bbl.py
+-rw-r--r--  2.0 unx    14465 b- defN 23-Jul-13 09:54 microprobe/code/benchmark.py
+-rw-r--r--  2.0 unx     3570 b- defN 23-Jul-13 09:54 microprobe/code/cfg.py
+-rw-r--r--  2.0 unx    18014 b- defN 23-Jul-13 09:54 microprobe/code/context.py
+-rw-r--r--  2.0 unx    75466 b- defN 23-Jul-13 09:54 microprobe/code/ins.py
+-rw-r--r--  2.0 unx    12069 b- defN 23-Jul-13 09:54 microprobe/code/var.py
+-rw-r--r--  2.0 unx     6514 b- defN 23-Jul-13 09:54 microprobe/code/wrapper.py
 -rw-r--r--  2.0 unx      671 b- defN 23-Jun-21 21:07 microprobe/driver/__init__.py
 -rw-r--r--  2.0 unx    10949 b- defN 23-Jun-21 21:07 microprobe/driver/genetic.py
 -rw-r--r--  2.0 unx      677 b- defN 23-Jun-21 21:07 microprobe/driver/guided.py
 -rw-r--r--  2.0 unx     1642 b- defN 23-Jun-21 21:07 microprobe/model/__init__.py
 -rw-r--r--  2.0 unx    13892 b- defN 23-Jun-21 21:07 microprobe/model/memory.py
 -rw-r--r--  2.0 unx     2180 b- defN 23-Jun-21 21:07 microprobe/passes/__init__.py
 -rw-r--r--  2.0 unx     7684 b- defN 23-Jun-21 21:07 microprobe/passes/address/__init__.py
 -rw-r--r--  2.0 unx    58027 b- defN 23-Jun-21 21:07 microprobe/passes/branch/__init__.py
 -rw-r--r--  2.0 unx     2527 b- defN 23-Jun-21 21:07 microprobe/passes/dat/__init__.py
 -rw-r--r--  2.0 unx     3028 b- defN 23-Jun-21 21:07 microprobe/passes/decimal/__init__.py
 -rw-r--r--  2.0 unx     6533 b- defN 23-Jun-21 21:07 microprobe/passes/float/__init__.py
--rw-r--r--  2.0 unx     3129 b- defN 23-Jun-21 21:07 microprobe/passes/ilp/__init__.py
+-rw-r--r--  2.0 unx     3209 b- defN 23-Jul-13 09:54 microprobe/passes/ilp/__init__.py
 -rw-r--r--  2.0 unx    17532 b- defN 23-Jun-21 22:53 microprobe/passes/initialization/__init__.py
--rw-r--r--  2.0 unx    45784 b- defN 23-Jun-21 21:07 microprobe/passes/instruction/__init__.py
+-rw-r--r--  2.0 unx    45879 b- defN 23-Jul-13 09:54 microprobe/passes/instruction/__init__.py
 -rw-r--r--  2.0 unx   106225 b- defN 23-Jun-21 21:07 microprobe/passes/memory/__init__.py
 -rw-r--r--  2.0 unx    39864 b- defN 23-Jun-21 21:07 microprobe/passes/register/__init__.py
 -rw-r--r--  2.0 unx     7658 b- defN 23-Jun-21 21:07 microprobe/passes/structure/__init__.py
 -rw-r--r--  2.0 unx    28125 b- defN 23-Jun-21 21:07 microprobe/passes/switch/__init__.py
 -rw-r--r--  2.0 unx    11544 b- defN 23-Jun-21 21:07 microprobe/passes/symbol/__init__.py
 -rw-r--r--  2.0 unx     7484 b- defN 23-Jun-21 21:07 microprobe/passes/variable/__init__.py
 -rw-r--r--  2.0 unx      710 b- defN 23-Jun-21 21:07 microprobe/schemas/__init__.py
--rw-r--r--  2.0 unx    19638 b- defN 23-Jun-21 21:07 microprobe/target/__init__.py
--rw-r--r--  2.0 unx    13404 b- defN 23-Jun-21 22:53 microprobe/target/env/__init__.py
--rw-r--r--  2.0 unx    26085 b- defN 23-Jun-21 21:07 microprobe/target/isa/__init__.py
--rw-r--r--  2.0 unx     4486 b- defN 23-Jun-21 21:07 microprobe/target/isa/comparator.py
--rw-r--r--  2.0 unx     6482 b- defN 23-Jun-21 21:07 microprobe/target/isa/dat.py
--rw-r--r--  2.0 unx     3506 b- defN 23-Jun-21 21:07 microprobe/target/isa/generator.py
--rw-r--r--  2.0 unx    66656 b- defN 23-Jun-21 21:07 microprobe/target/isa/instruction.py
--rw-r--r--  2.0 unx     5783 b- defN 23-Jun-21 21:07 microprobe/target/isa/instruction_field.py
--rw-r--r--  2.0 unx    12051 b- defN 23-Jun-21 21:07 microprobe/target/isa/instruction_format.py
--rw-r--r--  2.0 unx    42994 b- defN 23-Jun-21 21:07 microprobe/target/isa/operand.py
--rw-r--r--  2.0 unx     9736 b- defN 23-Jun-21 21:07 microprobe/target/isa/register.py
--rw-r--r--  2.0 unx     8284 b- defN 23-Jun-21 21:07 microprobe/target/isa/register_type.py
--rw-r--r--  2.0 unx      710 b- defN 23-Jun-21 21:07 microprobe/target/isa/schemas/__init__.py
--rw-r--r--  2.0 unx    11307 b- defN 23-Jun-21 21:07 microprobe/target/uarch/__init__.py
--rw-r--r--  2.0 unx    14318 b- defN 23-Jun-21 21:07 microprobe/target/uarch/cache.py
--rw-r--r--  2.0 unx    13221 b- defN 23-Jun-21 21:07 microprobe/target/uarch/element.py
--rw-r--r--  2.0 unx     4498 b- defN 23-Jun-21 21:07 microprobe/target/uarch/element_type.py
--rw-r--r--  2.0 unx      710 b- defN 23-Jun-21 21:07 microprobe/target/uarch/schemas/__init__.py
+-rw-r--r--  2.0 unx    19806 b- defN 23-Jul-13 09:54 microprobe/target/__init__.py
+-rw-r--r--  2.0 unx    13449 b- defN 23-Jul-13 09:54 microprobe/target/env/__init__.py
+-rw-r--r--  2.0 unx    27147 b- defN 23-Jul-13 09:54 microprobe/target/isa/__init__.py
+-rw-r--r--  2.0 unx     4459 b- defN 23-Jul-13 09:54 microprobe/target/isa/comparator.py
+-rw-r--r--  2.0 unx     6049 b- defN 23-Jul-13 09:54 microprobe/target/isa/dat.py
+-rw-r--r--  2.0 unx     3680 b- defN 23-Jul-13 09:54 microprobe/target/isa/generator.py
+-rw-r--r--  2.0 unx    66061 b- defN 23-Jul-13 09:54 microprobe/target/isa/instruction.py
+-rw-r--r--  2.0 unx     5792 b- defN 23-Jul-13 09:54 microprobe/target/isa/instruction_field.py
+-rw-r--r--  2.0 unx    12112 b- defN 23-Jul-13 09:54 microprobe/target/isa/instruction_format.py
+-rw-r--r--  2.0 unx    42153 b- defN 23-Jul-13 09:54 microprobe/target/isa/operand.py
+-rw-r--r--  2.0 unx     9777 b- defN 23-Jul-13 09:54 microprobe/target/isa/register.py
+-rw-r--r--  2.0 unx     8338 b- defN 23-Jul-13 09:54 microprobe/target/isa/register_type.py
+-rw-r--r--  2.0 unx      709 b- defN 23-Jul-13 09:54 microprobe/target/isa/schemas/__init__.py
+-rw-r--r--  2.0 unx    11271 b- defN 23-Jul-13 09:54 microprobe/target/uarch/__init__.py
+-rw-r--r--  2.0 unx    14770 b- defN 23-Jul-13 09:54 microprobe/target/uarch/cache.py
+-rw-r--r--  2.0 unx    12934 b- defN 23-Jul-13 09:54 microprobe/target/uarch/element.py
+-rw-r--r--  2.0 unx     4558 b- defN 23-Jul-13 09:54 microprobe/target/uarch/element_type.py
+-rw-r--r--  2.0 unx      709 b- defN 23-Jul-13 09:54 microprobe/target/uarch/schemas/__init__.py
 -rw-r--r--  2.0 unx      670 b- defN 23-Jun-21 21:07 microprobe/utils/__init__.py
 -rw-r--r--  2.0 unx    46408 b- defN 23-Jun-21 21:07 microprobe/utils/asm.py
 -rw-r--r--  2.0 unx    33575 b- defN 23-Jun-21 21:07 microprobe/utils/bin.py
 -rw-r--r--  2.0 unx     6526 b- defN 23-Jun-21 21:07 microprobe/utils/cache.py
 -rw-r--r--  2.0 unx    56510 b- defN 23-Jun-21 21:07 microprobe/utils/cmdline.py
 -rw-r--r--  2.0 unx    18127 b- defN 23-Jun-21 21:07 microprobe/utils/config.py
 -rw-r--r--  2.0 unx    10924 b- defN 23-Jun-21 21:07 microprobe/utils/distrib.py
@@ -64,13 +64,13 @@
 -rw-r--r--  2.0 unx    14194 b- defN 23-Jun-21 21:07 microprobe/utils/misc.py
 -rw-r--r--  2.0 unx    72494 b- defN 23-Jun-21 21:07 microprobe/utils/mpt.py
 -rw-r--r--  2.0 unx    11342 b- defN 23-Jun-21 21:07 microprobe/utils/objdump.py
 -rw-r--r--  2.0 unx     2718 b- defN 23-Jun-21 21:07 microprobe/utils/policy.py
 -rw-r--r--  2.0 unx     1169 b- defN 23-Jun-21 21:07 microprobe/utils/profile.py
 -rw-r--r--  2.0 unx     2869 b- defN 23-Jun-21 21:07 microprobe/utils/run.py
 -rw-r--r--  2.0 unx     5319 b- defN 23-Jun-21 21:07 microprobe/utils/yaml.py
--rw-rw-r--  2.0 unx    11356 b- defN 23-Jun-29 15:48 microprobe_all-0.5.20230629114852.dist-info/LICENSE
--rw-r--r--  2.0 unx     1875 b- defN 23-Jun-29 15:48 microprobe_all-0.5.20230629114852.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 23-Jun-29 15:48 microprobe_all-0.5.20230629114852.dist-info/WHEEL
--rw-r--r--  2.0 unx       11 b- defN 23-Jun-29 15:48 microprobe_all-0.5.20230629114852.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6545 b- defN 23-Jun-29 15:48 microprobe_all-0.5.20230629114852.dist-info/RECORD
-74 files, 1165071 bytes uncompressed, 244555 bytes compressed:  79.0%
+-rw-rw-r--  2.0 unx    11356 b- defN 23-Jul-13 10:20 microprobe_all-0.5.20230713062001.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1875 b- defN 23-Jul-13 10:20 microprobe_all-0.5.20230713062001.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 23-Jul-13 10:20 microprobe_all-0.5.20230713062001.dist-info/WHEEL
+-rw-r--r--  2.0 unx       11 b- defN 23-Jul-13 10:20 microprobe_all-0.5.20230713062001.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6545 b- defN 23-Jul-13 10:20 microprobe_all-0.5.20230713062001.dist-info/RECORD
+74 files, 1168718 bytes uncompressed, 246185 bytes compressed:  78.9%
```

## zipnote {}

```diff
@@ -201,23 +201,23 @@
 
 Filename: microprobe/utils/run.py
 Comment: 
 
 Filename: microprobe/utils/yaml.py
 Comment: 
 
-Filename: microprobe_all-0.5.20230629114852.dist-info/LICENSE
+Filename: microprobe_all-0.5.20230713062001.dist-info/LICENSE
 Comment: 
 
-Filename: microprobe_all-0.5.20230629114852.dist-info/METADATA
+Filename: microprobe_all-0.5.20230713062001.dist-info/METADATA
 Comment: 
 
-Filename: microprobe_all-0.5.20230629114852.dist-info/WHEEL
+Filename: microprobe_all-0.5.20230713062001.dist-info/WHEEL
 Comment: 
 
-Filename: microprobe_all-0.5.20230629114852.dist-info/top_level.txt
+Filename: microprobe_all-0.5.20230713062001.dist-info/top_level.txt
 Comment: 
 
-Filename: microprobe_all-0.5.20230629114852.dist-info/RECORD
+Filename: microprobe_all-0.5.20230713062001.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## microprobe/code/__init__.py

```diff
@@ -34,56 +34,63 @@
 which is the main object driving the code generation process in the
 microprobe framework. This object provides a simple interface to define
 the set of passes (:class:`~.Pass`) to apply to generate a benchmark
 (:class:`~.Benchmark`).
 """
 
 # Futures
-from __future__ import absolute_import
+from __future__ import absolute_import, annotations
 
 # Built-in modules
 import copy
 import datetime
 import os
-import warnings
 from time import time
+from typing import TYPE_CHECKING, Dict, List, Type
 
 # Third party modules
 import six
 
 # Own modules
 import microprobe.code.wrapper
 import microprobe.target
 import microprobe.utils as cmd
 from microprobe import MICROPROBE_RC
 from microprobe.code.address import InstructionAddress
 from microprobe.code.benchmark import benchmark_factory
-from microprobe.code.context import Context
-from microprobe.code.ins import Instruction
 from microprobe.exceptions import MicroprobeCodeGenerationError, \
     MicroprobeError, MicroprobeValueError
 from microprobe.utils.imp import get_all_subclasses, load_source
 from microprobe.utils.logger import DEBUG, get_logger, set_log_level
-from microprobe.utils.misc import OrderedDict, findfiles, Progress, \
-    open_generic_fd
-
-# Local modules
+from microprobe.utils.misc import Progress, findfiles, open_generic_fd
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.code.address import Address
+    from microprobe.code.benchmark import Benchmark
+    from microprobe.code.ins import Instruction
+    from microprobe.code.wrapper import Wrapper
+    from microprobe.passes import Pass
+    from microprobe.target import Target
 
 # Constants
 
 #: Package logger (:class:`~.logging.Logger`).
 LOG = get_logger(__name__)
 
 _INIT = True
 __all__ = ['get_wrapper', 'Synthesizer']
 
 
+def _wrapper_subclasses() -> List[Type[microprobe.code.wrapper.Wrapper]]:
+    return get_all_subclasses(microprobe.code.wrapper.Wrapper)
+
+
 # Functions
-def get_wrapper(name):
+def get_wrapper(name: str):
     """Return a wrapper object with name *name*.
 
     Look for the registered :class:`~.Wrapper` objects and return and instance
     of the one with name equal *name*.
 
     :param name: Wrapper name
     :type name: :class:`~.str`
@@ -95,32 +102,25 @@
     if _INIT:
         _INIT = False
         _import_default_wrappers()
 
     if MICROPROBE_RC['debugwrapper']:
         name = "DebugBinaryDouble"
 
-    for elem in get_all_subclasses(microprobe.code.wrapper.Wrapper):
+    for elem in _wrapper_subclasses():
         if elem.__name__ == name:
             return elem
 
     raise MicroprobeValueError(
-        "Unknown wrapper '%s'. Available wrappers are: %s. " % (
-            name, [
-                elem.__name__
-                for elem in get_all_subclasses(
-                    microprobe.code.wrapper.Wrapper
-                )
-            ]
-        )
-    )
+        "Unknown wrapper '%s'. Available wrappers are: %s. " %
+        (name, [elem.__name__ for elem in _wrapper_subclasses()]))
 
 
 def _import_default_wrappers():
-    modules = []
+    modules: List[str] = []
     LOG.debug('Wrapper paths: %s', MICROPROBE_RC['wrapper_paths'])
     for path in MICROPROBE_RC['wrapper_paths']:
         for module in findfiles([path], r"wrappers/.+\.py$", full=True):
             module = os.path.realpath(module)
             if module not in modules:
                 modules.append(module)
 
@@ -133,42 +133,40 @@
 
             if name == "__init__":
                 continue
 
             if name in microprobe.code.wrapper.__dict__:
                 raise MicroprobeError(
                     "Wrapper module name '%s' in '%s' already loaded. " %
-                    (name, module_file)
-                )
+                    (name, module_file))
 
             try:
                 module = load_source(name, module_file)
             except MicroprobeValueError:
                 continue
 
             microprobe.code.wrapper.__dict__[name] = module
             modules.remove(module_file)
 
             current_wrappers = \
                 [elem.__name__ for elem in
-                 get_all_subclasses(microprobe.code.wrapper.Wrapper)
+                 _wrapper_subclasses()
                  ]
 
             if len(current_wrappers) != len(set(current_wrappers)):
                 for elem in set(current_wrappers):
                     current_wrappers.remove(elem)
                 overwrapper = list(set(current_wrappers))[0]
                 raise MicroprobeError(
                     "Module name '%s' in '%s' overrides an existing wrapper "
-                    "with name '%s'" % (name, module_file, overwrapper)
-                )
+                    "with name '%s'" % (name, module_file, overwrapper))
 
 
 # Classes
-class Synthesizer(object):
+class Synthesizer:
     """Benchmark synthesizer.
 
     The Synthesizer objects are in charge of creating :class:`~.Benchmark`
     objects based on a set of passes that have been previously defined.
 
     The typical workflow will be as follow. User instantiates the synthesizer,
     specifying also the :class:`~.Target` and the :class:`~.Wrapper`, which are
@@ -223,15 +221,21 @@
 
         - The :meth:`~.synthesize` method and the :meth:`~.save` method can be
           called multiple times to generate and save multiple benchmarks in
           case that some of the passes have some random behavior. Otherwise,
           it does not make sense ;).
     """
 
-    def __init__(self, target, wrapper, **kwargs):
+    def __init__(self,
+                 target: Target,
+                 wrapper: Wrapper | List[Wrapper],
+                 no_scratch: bool = False,
+                 extra_raw: Dict[str, str] = {},
+                 value="random",
+                 threads: int = 1):
         """Create a Synthesizer object.
 
         :param target: Benchmark target
         :type target: :class:`~.Target`
         :param wrapper: Wrapper object defining the output format
         :type wrapper: :class:`~.Wrapper`
         :param value: Default immediate value used for non-initialized
@@ -247,36 +251,35 @@
                          a ``value`` attributes (Default: [])
         :return: A Synthesizer instance
         :rtype: :class:`~.Synthesizer`
         """
         self._target = target
 
         # Extra arguments
-        self._no_scratch = kwargs.get("no_scratch", False)
-        self._raw = kwargs.get("extra_raw", {})
-        self._immediate = kwargs.get("value", "random")
-        self._threads = kwargs.get("threads", 1)
+        self._no_scratch = no_scratch
+        self._raw = extra_raw
+        self._immediate = value
+        self._threads = threads
 
-        self._passes = {}
+        self._passes: Dict[int, List[Pass]] = {}
         for idx in range(1, self._threads + 1):
             self._passes[idx] = []
 
         self._current_thread = 1
 
         if isinstance(wrapper, list):
             if len(wrapper) != self._threads:
                 raise MicroprobeCodeGenerationError(
                     "Number of wrappers provided (%d) is different from "
                     "number of threads (%d) specified in the Synthesizer" %
-                    (len(wrapper), self._threads)
-                )
+                    (len(wrapper), self._threads))
             self._wrappers = wrapper
         else:
             self._wrappers = [wrapper]
-            for dummy in range(1, self._threads):
+            for _ in range(1, self._threads):
                 new_wrapper = copy.deepcopy(wrapper)
                 self._wrappers.append(new_wrapper)
 
         for wrapper in self._wrappers:
             wrapper.set_target(target)
 
     @property
@@ -285,32 +288,34 @@
         return self._target
 
     @property
     def wrapper(self):
         """Wrapper attribute (:class:`~.Wrapper`)."""
         return self._wrappers[self._current_thread - 1]
 
-    def add_pass(self, synth_pass, thread_idx=None):
+    def add_pass(self, synth_pass: Pass, thread_idx: int | None = None):
         """Add a pass to the benchmark synthesizer.
 
         :param synth_pass: New pass to add.
         :type synth_pass: :class:`~.Pass`
         """
 
         if thread_idx is None:
             self._passes[self._current_thread].append(synth_pass)
         else:
             if not 1 <= thread_idx <= self._threads + 1:
                 raise MicroprobeCodeGenerationError(
-                    "Unknown thread id: %d (min: 1, max: %d)"
-                    % (thread_idx, self._threads + 1)
-                )
+                    "Unknown thread id: %d (min: 1, max: %d)" %
+                    (thread_idx, self._threads + 1))
             self._passes[thread_idx].append(synth_pass)
 
-    def save(self, name, bench=None, pad=None):
+    def save(self,
+             name: str,
+             bench: Benchmark | None = None,
+             pad: int | None = None):
         """Save a benchmark to disk.
 
         Save a synthesized benchmark to disk. If bench is not specified a
         benchmark is automatically synthesized using the :meth:`~.synthesize`
         method.
 
         :param name: Filename to save
@@ -320,21 +325,16 @@
         """
         if bench is None:
             bench = self.synthesize()
 
         starttime = time()
         program_str = self._wrap(bench)
         endtime = time()
-        LOG.info(
-            "Pass wrap: %s", (
-                datetime.timedelta(
-                    seconds=endtime - starttime
-                )
-            )
-        )
+        LOG.info("Pass wrap: %s",
+                 (datetime.timedelta(seconds=endtime - starttime)))
 
         outputname = self._wrappers[0].outputname(name)
         fdx = open_generic_fd(outputname, 'wb')
 
         for elem in program_str:
             if elem == []:
                 continue
@@ -384,16 +384,15 @@
             if not self._no_scratch:
                 # self._target.scratch_var.set_address(None)
                 bench.register_var(self._target.scratch_var, bench.context)
 
             # Basic context
             reserved_registers = self._target.reserved_registers
             reserved_registers += self.wrapper.reserved_registers(
-                reserved_registers, self._target
-            )
+                reserved_registers, self._target)
 
             bench.context.add_reserved_registers(reserved_registers)
 
             if MICROPROBE_RC['debugpasses']:
                 previous_level = LOG.getEffectiveLevel()
                 set_log_level(DEBUG)
 
@@ -408,69 +407,56 @@
                 if MICROPROBE_RC['verbose']:
                     cmd.cmdline.print_info("Applying pass %03d: %s" %
                                            (idx, step.__class__.__name__))
 
                 step(bench, self.target)
                 bench.add_pass_info(step.info())
                 endtime = time()
-                LOG.debug(
-                    "Applying pass %03d: %s : Execution time: %s",
-                    idx,
-                    step.__class__.__name__,
-                    datetime.timedelta(seconds=endtime - starttime)
-                )
+                LOG.debug("Applying pass %03d: %s : Execution time: %s", idx,
+                          step.__class__.__name__,
+                          datetime.timedelta(seconds=endtime - starttime))
                 starttime = endtime
 
             starttime = time()
             for idx, step in enumerate(passes):
 
                 LOG.info("Checking pass %03d: %s", idx,
                          step.__class__.__name__)
                 try:
                     pass_ok = step.check(bench, self.target)
                 except NotImplementedError:
-                    LOG.warning(
-                        "Checking pass %03d: %s. NOT IMPLEMENTED", idx,
-                        step.__class__.__name__
-                    )
+                    LOG.warning("Checking pass %03d: %s. NOT IMPLEMENTED", idx,
+                                step.__class__.__name__)
                     pass_ok = False
 
                 endtime = time()
 
                 if not pass_ok:
-                    LOG.warning(
-                        "Checking pass %03d: %s. Test result: FAIL", idx,
-                        step.__class__.__name__
-                    )
+                    LOG.warning("Checking pass %03d: %s. Test result: FAIL",
+                                idx, step.__class__.__name__)
 
                     bench.add_warning(
                         "Pass %03d: %s did not pass the check test" %
-                        (idx, step.__class__.__name__)
-                    )
+                        (idx, step.__class__.__name__))
                 else:
-                    LOG.debug(
-                        "Checking pass %03d: %s. Test result: OK", idx,
-                        step.__class__.__name__
-                    )
-
-                LOG.debug(
-                    "Checking pass %03d: %s : Execution time: %s",
-                    idx,
-                    step.__class__.__name__,
-                    datetime.timedelta(seconds=endtime - starttime)
-                )
+                    LOG.debug("Checking pass %03d: %s. Test result: OK", idx,
+                              step.__class__.__name__)
+
+                LOG.debug("Checking pass %03d: %s : Execution time: %s", idx,
+                          step.__class__.__name__,
+                          datetime.timedelta(seconds=endtime - starttime))
 
                 starttime = endtime
 
             if MICROPROBE_RC['debugpasses']:
                 set_log_level(previous_level)
 
         return bench
 
-    def _wrap_thread(self, bench, thread_id):
+    def _wrap_thread(self, bench: Benchmark, thread_id: int):
         """Wrap a thread in benchmark.
 
         This function wraps a thread using the synthesizer wrapper. The
         wrapping process is the process of converting the internal
         representation of the benchmark to the actual string that is written
         to a file, adding the necessary prologue and epilogue bytes of
         data.
@@ -482,58 +468,51 @@
         :return: A string representation of the benchmark
         :rtype: :class:`~.str`
         """
 
         bench.set_current_thread(thread_id)
         self.set_current_thread(thread_id)
 
-        thread_str = []
+        thread_str: List[str] = []
         thread_str.append(self.wrapper.start_main())
 
         if 'CODE_HEADER' in self._raw:
             thread_str.append("\n" + self._raw['CODE_HEADER'] + "\n")
 
         for var in bench.registered_global_vars():
             if var.value is None:
                 thread_str.append(
-                    self.wrapper.init_global_var(
-                        var, self._immediate
-                    )
-                )
+                    self.wrapper.init_global_var(var, self._immediate))
 
         thread_str.append(self.wrapper.post_var())
 
         # TODO: This is hardcoded and assumes a loop always. Needs to be more
         # generic: pass a building block to a wrapper and it automatically
         # returns the required string
 
         for instr in bench.init:
             thread_str.append(self.wrapper.wrap_ins(instr))
 
-        code_str = []
+        code_str: List[str] = []
         first = True
         instr = None
         for bbl in bench.cfg.bbls:
             for instr in bbl.instrs:
                 if first is True:
                     first = False
                     if bench.init:
                         code_str.append(
-                            self.wrapper.start_loop(
-                                instr, bench.init[0]
-                            )
-                        )
+                            self.wrapper.start_loop(instr, bench.init[0]))
                     else:
                         code_str.append(self.wrapper.start_loop(instr, instr))
                 code_str.append(self.wrapper.wrap_ins(instr))
 
         if instr is None:
             raise MicroprobeCodeGenerationError(
-                "No instructions found in benchmark"
-            )
+                "No instructions found in benchmark")
 
         thread_str.extend(code_str)
 
         for instr in bench.fini:
             thread_str.append(self.wrapper.wrap_ins(instr))
 
         last_instr = instr
@@ -542,15 +521,15 @@
         if 'CODE_FOOTER' in self._raw:
             thread_str.append("\n" + self._raw['CODE_FOOTER'] + "\n")
 
         thread_str.append(self.wrapper.end_main())
 
         return thread_str
 
-    def _wrap(self, bench):
+    def _wrap(self, bench: Benchmark):
         """Wrap a benchmark.
 
         This function wraps a benchmark using the synthesizer wrapper. The
         wrapping process is the process of converting the internal
         representation of the benchmark to the actual string that is written
         to a file, adding the necessary prologue and epilogue bytes of
         data.
@@ -562,50 +541,47 @@
         """
 
         for wrapper in self._wrappers:
             wrapper.set_benchmark(bench)
 
         self.set_current_thread(1)
 
-        bench_str = []
+        bench_str: List[str] = []
 
         if 'FILE_HEADER' in self._raw:
             bench_str.append(self._raw['FILE_HEADER'] + "\n")
 
         bench_str.append(self.wrapper.headers())
 
         for thread_id in range(1, self._threads + 1):
             self.set_current_thread(thread_id)
             bench.set_current_thread(thread_id)
-            for var in sorted(
-                    bench.registered_global_vars(),
-                    key=lambda x: x.address
-            ):
+            for var in sorted(bench.registered_global_vars(),
+                              key=lambda x: x.address):
                 bench_str.append(self.wrapper.declare_global_var(var))
 
         for thread_id in range(1, self._threads + 1):
             bench_str.extend(self._wrap_thread(bench, thread_id))
 
         self.set_current_thread(1)
         bench_str.append(self.wrapper.footer())
 
         if 'FILE_FOOTER' in self._raw:
             bench_str.append("\n" + self._raw['FILE_FOOTER'] + "\n")
 
         bench_str = [elem for elem in bench_str if elem != ""]
         return bench_str
 
-    def set_current_thread(self, idx):
+    def set_current_thread(self, idx: int):
         """ """
         self._current_thread = idx
         if not 1 <= idx <= self._threads + 1:
             raise MicroprobeCodeGenerationError(
-                "Unknown thread id: %d (min: 1, max: %d)" % (idx,
-                                                             self._threads + 1)
-            )
+                "Unknown thread id: %d (min: 1, max: %d)" %
+                (idx, self._threads + 1))
 
 
 class TraceSynthesizer(Synthesizer):
     """Trace synthesizer.
 
     The Trace Synthesizer objects are in charge of creating
     :class:`~.Benchmark` objects based on a set of passes that have been
@@ -620,23 +596,32 @@
     #. ``wrapper.headers()`` contents
     #. Dynamic execution trace from:
       -  **<benchmark initialization code>**
       -  **<benchmark building blocks>**
       -  **<benchmark finalization code>**
     """
 
-    def __init__(self, target, wrapper, **kwargs):
-        super(TraceSynthesizer, self).__init__(target, wrapper,
-                                               **kwargs)
-
-        self._show_trace = kwargs.get("show_trace", False)
-        self._maxins = kwargs.get("maxins", 10000)
-        self._start_addr = kwargs.get("start_addr", None)
+    def __init__(self,
+                 target: Target,
+                 wrapper: Wrapper,
+                 show_trace: bool = False,
+                 maxins: int = 10000,
+                 start_addr: Address | None = None,
+                 no_scratch: bool = False,
+                 extra_raw: Dict[str, str] = {},
+                 value="random",
+                 threads: int = 1):
+        super(TraceSynthesizer, self).__init__(target, wrapper, no_scratch,
+                                               extra_raw, value, threads)
+
+        self._show_trace = show_trace
+        self._maxins = maxins
+        self._start_addr = start_addr
 
-    def _wrap(self, bench):
+    def _wrap(self, bench: Benchmark):
         """Wrap a benchmark.
 
         This function wraps a benchmark using the synthesizer wrapper. The
         wrapping process is the process of converting the internal
         representation of the benchmark to the actual string that is written
         to a file, adding the necessary prologue and epilogue bytes of
         data.
@@ -644,20 +629,21 @@
         :param bench: Benchmark to wrap.
         :type bench: :class:`~.Benchmark`
         :return: A string representation of the benchmark
         :rtype: :class:`~.str`
         """
         self.wrapper.set_benchmark(bench)
 
-        bench_str = []
+        bench_str: List[str] = []
         bench_str.append(self.wrapper.headers())
 
-        instructions = []
-        instructions_dict = {}
-        instructions_next_dict = {}
+        instructions: List[Instruction] = []
+        instructions_dict: Dict[InstructionAddress, Instruction] = {}
+        instructions_next_dict: Dict[InstructionAddress,
+                                     InstructionAddress] = {}
 
         for instr in bench.init:
             instructions.append(instr)
 
         for bbl in bench.cfg.bbls:
             for instr in bbl.instrs:
                 instructions.append(instr)
@@ -679,28 +665,23 @@
             if "EA" in instr.decorators:
                 instr = [
                     ins for ins in instructions
                     if int(ins.decorators["EA"]['value'][0], 16) ==
                     self._start_addr
                 ][0]
             else:
-                instr = instructions_dict[
-                    InstructionAddress(
-                        base_address="code",
-                        displacement=(
-                            self._start_addr - bench.context.code_segment
-                        )
-                    )
-                ]
+                instr = instructions_dict[InstructionAddress(
+                    base_address="code",
+                    displacement=(self._start_addr -
+                                  bench.context.code_segment))]
 
         count = 0
 
-        cmd.cmdline.print_info(
-            "Maximum trace size: %s instructions " %
-            self._maxins)
+        cmd.cmdline.print_info("Maximum trace size: %s instructions " %
+                               self._maxins)
 
         progress = Progress(self._maxins, msg="Instructions generated:")
 
         while True:
 
             count = count + 1
 
@@ -718,32 +699,28 @@
                 next_instr = instructions_dict[instr_address]
 
             except KeyError:
 
                 if instr.mnemonic.upper() == "ATTN":
                     cmd.cmdline.print_warning(
                         "Processor ATTN instruction found. Stopping trace "
-                        "generation. "
-                    )
+                        "generation. ")
                     break
 
                 cmd.cmdline.print_error(
                     "Jump from 0x%X to an unknown instruction in address "
                     "0x%X found. Stoping trace generation." %
                     (instr.address.displacement + bench.context.code_segment,
-                     instr_address.displacement + bench.context.code_segment)
-                )
+                     instr_address.displacement + bench.context.code_segment))
                 exit(-1)
 
             progress()
             wrap_ins = self.wrapper.wrap_ins(instr,
                                              next_instr=next_instr,
                                              show=self._show_trace)
 
-            bench_str.append(
-                wrap_ins
-            )
+            bench_str.append(wrap_ins)
 
             instr = next_instr
 
         bench_str = [elem for elem in bench_str if elem != ""]
         return bench_str
```

## microprobe/code/address.py

```diff
@@ -12,42 +12,48 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.code.address` module
 
 """
 
 # Futures
-from __future__ import absolute_import, print_function
+from __future__ import absolute_import, annotations, print_function
 
 # Built in modules
 import hashlib
+from typing import TYPE_CHECKING
 
 # Third party modules
 import six
 
 # Own modules
 from microprobe.code.var import Variable
 from microprobe.exceptions import MicroprobeCodeGenerationError
 from microprobe.utils.logger import get_logger
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.code.ins import Instruction
 
 # Constants
 LOG = get_logger(__name__)
 __all__ = ["MemoryValue", "Address", "InstructionAddress"]
 
 # Functions
 
 
 # Classes
-class Address(object):
+class Address:
     """Class to represent an address."""
 
     _cmp_attributes = ["_base_address", "_displacement"]
 
-    def __init__(self, base_address=None, displacement=0):
+    def __init__(self,
+                 base_address: Variable | str | None = None,
+                 displacement: int = 0):
         """
 
         :param base_address:  (Default value = None)
         :param displacement:  (Default value = 0)
 
         """
 
@@ -62,130 +68,122 @@
         if self._base_address is not None:
             assert isinstance(self._base_address,
                               tuple(list(six.string_types) + [Variable]))
 
         self._hash = None
 
     @property
-    def base_address(self):
+    def base_address(self) -> Variable | str | None:
         """Base address of the address (:class:`~.str`)"""
         return self._base_address
 
     @property
     def displacement(self):
         """Displacement of the address (:class:`~.int`)"""
         return self._displacement
 
-    def check_alignment(self, align):
+    def check_alignment(self, align: int):
         """Check if the address is aligned to align"""
         return self._displacement % align == 0
 
     def copy(self):
         """Returns a copy of the address."""
-        return self.__class__(
-            base_address=self.base_address,
-            displacement=self.displacement
-        )
+        return self.__class__(base_address=self.base_address,
+                              displacement=self.displacement)
 
-    def __add__(self, other):
+    def __add__(self, other: Address | int):
         """
 
         :param other:
 
         """
 
         if isinstance(other, self.__class__):
 
             if self.base_address != other.base_address:
-                raise MicroprobeCodeGenerationError(
-                    "I can not add '%s' "
-                    "and '%s'" % (self, other)
-                )
-
-            return self.__class__(
-                self.base_address, self.displacement + other.displacement
-            )
+                raise MicroprobeCodeGenerationError("I can not add '%s' "
+                                                    "and '%s'" % (self, other))
+
+            return self.__class__(self.base_address,
+                                  self.displacement + other.displacement)
 
         elif isinstance(other, six.integer_types):
 
             return self.__class__(self.base_address, self.displacement + other)
 
         else:
             raise NotImplementedError
 
-    def _check_cmp(self, other):
+    def _check_cmp(self, other: Address):
         if not isinstance(other, self.__class__):
-            raise NotImplementedError(
-                "%s != %s" % (
-                    other.__class__, self.__class__
-                )
-            )
+            raise NotImplementedError("%s != %s" %
+                                      (other.__class__, self.__class__))
 
-    def __eq__(self, other):
+    def __eq__(self, other: object):
         """x.__eq__(y) <==> x==y"""
 
         if not isinstance(other, self.__class__):
             return False
 
         for attr in self._cmp_attributes:
             if not getattr(self, attr) == getattr(other, attr):
                 return False
         return True
 
-    def __ne__(self, other):
+    def __ne__(self, other: object):
         """x.__ne__(y) <==> x!=y"""
 
         if not isinstance(other, self.__class__):
             return False
 
         for attr in self._cmp_attributes:
             if not getattr(self, attr) == getattr(other, attr):
                 return True
         return False
 
-    def __lt__(self, other):
+    def __lt__(self, other: object):
         """x.__lt__(y) <==> x<y"""
 
         if not isinstance(other, self.__class__):
             return False
 
         for attr in self._cmp_attributes:
             if getattr(self, attr) < getattr(other, attr):
                 return True
             elif getattr(self, attr) > getattr(other, attr):
                 return False
         return False
 
-    def __gt__(self, other):
+    def __gt__(self, other: object):
         """x.__gt__(y) <==> x>y"""
 
         if not isinstance(other, self.__class__):
             return False
 
         for attr in self._cmp_attributes:
             if getattr(self, attr) > getattr(other, attr):
                 return True
             elif getattr(self, attr) < getattr(other, attr):
                 return False
         return False
 
-    def __le__(self, other):
+    def __le__(self, other: object):
         """x.__le__(y) <==> x<=y"""
 
         if not isinstance(other, self.__class__):
             return False
 
         for attr in self._cmp_attributes:
             if getattr(self, attr) <= getattr(other, attr):
                 continue
             else:
                 return False
         return True
 
-    def __ge__(self, other):
+    def __ge__(self, other: object):
         """x.__ge__(y) <==> x>=y"""
 
         if not isinstance(other, self.__class__):
             return False
 
         for attr in self._cmp_attributes:
             if getattr(self, attr) >= getattr(other, attr):
@@ -194,152 +192,135 @@
                 return False
         return True
 
     def __hash__(self):
         """ """
         if self._hash is None:
             self._hash = int(
-                hashlib.sha512(str(self).encode()).hexdigest(), 16
-            )
+                hashlib.sha512(str(self).encode()).hexdigest(), 16)
         return self._hash
 
-    def __iadd__(self, other):
+    def __iadd__(self, other: object):
         """
 
         :param other:
 
         """
 
         if isinstance(other, self.__class__):
 
             if self.base_address != other.base_address:
-                raise MicroprobeCodeGenerationError(
-                    "I can not add '%s'"
-                    " and '%s'" % (
-                        self, other
-                    )
-                )
-
-            return self.__class__(
-                self.base_address, self.displacement + other.displacement
-            )
+                raise MicroprobeCodeGenerationError("I can not add '%s'"
+                                                    " and '%s'" %
+                                                    (self, other))
+
+            return self.__class__(self.base_address,
+                                  self.displacement + other.displacement)
 
         elif isinstance(other, six.integer_types):
 
             return self.__class__(self.base_address, self.displacement + other)
 
         else:
             raise NotImplementedError
 
-    def __mod__(self, other):
+    def __mod__(self, other: object):
         """
 
         :param other:
 
         """
 
         if isinstance(other, self.__class__):
 
             if self.base_address != other.base_address:
-                raise MicroprobeCodeGenerationError(
-                    "I can not compute the "
-                    "module '%s' and '%s'" % (self, other)
-                )
-
-            return self.__class__(
-                self.base_address, self.displacement + other.displacement
-            )
+                raise MicroprobeCodeGenerationError("I can not compute the "
+                                                    "module '%s' and '%s'" %
+                                                    (self, other))
+
+            return self.__class__(self.base_address,
+                                  self.displacement + other.displacement)
 
         elif isinstance(other, six.integer_types):
 
             if isinstance(self._base_address, six.integer_types):
                 return (self._base_address + self.displacement) % other
 
             return self.displacement % other
 
         else:
             raise NotImplementedError
 
-    def __radd__(self, other):
+    def __radd__(self, other: object):
         """
 
         :param other:
 
         """
 
         if isinstance(other, self.__class__):
 
             if self.base_address != other.base_address:
-                raise MicroprobeCodeGenerationError(
-                    "I can not add '%s' and "
-                    "'%s'" % (self, other)
-                )
-
-            return self.__class__(
-                self.base_address, self.displacement + other.displacement
-            )
+                raise MicroprobeCodeGenerationError("I can not add '%s' and "
+                                                    "'%s'" % (self, other))
+
+            return self.__class__(self.base_address,
+                                  self.displacement + other.displacement)
 
         elif isinstance(other, six.integer_types):
             return self.__class__(self.base_address, self.displacement + other)
 
         else:
             raise NotImplementedError
 
     def __repr__(self):
         """ """
 
-        return "%s(%s+0x%016x)" % (
-            self.__class__.__name__, self.base_address, self.displacement
-        )
+        return "%s(%s+0x%016x)" % (self.__class__.__name__, self.base_address,
+                                   self.displacement)
 
-    def __rsub__(self, other):
+    def __rsub__(self, other: object):
         """
 
         :param other:
 
         """
 
         if isinstance(other, (Address, InstructionAddress)):
 
             if self.base_address != other.base_address:
-                raise MicroprobeCodeGenerationError(
-                    "I can not sub '%s' "
-                    "and '%s'" % (self, other)
-                )
+                raise MicroprobeCodeGenerationError("I can not sub '%s' "
+                                                    "and '%s'" % (self, other))
 
             return other.displacement - self.displacement
 
         elif isinstance(other, six.integer_types):
             return self.__class__(self.base_address, self.displacement - other)
         else:
             raise NotImplementedError(
                 "Substraction not implemented for %s and %s "
-                "objects" % (self.__class__, other.__class__)
-            )
+                "objects" % (self.__class__, other.__class__))
 
     def __str__(self):
         """ """
-        return "%s(%s+0x%016x)" % (
-            self.__class__.__name__, self.base_address, self.displacement
-        )
+        return "%s(%s+0x%016x)" % (self.__class__.__name__, self.base_address,
+                                   self.displacement)
 
-    def __sub__(self, other):
+    def __sub__(self, other: object):
         """
 
         :param other:
 
         """
 
         if isinstance(other, self.__class__):
 
             if self.base_address != other.base_address:
-                raise MicroprobeCodeGenerationError(
-                    "I can not sub '%s' "
-                    "and '%s'" % (self, other)
-                )
+                raise MicroprobeCodeGenerationError("I can not sub '%s' "
+                                                    "and '%s'" % (self, other))
 
             return self.displacement - other.displacement
 
         elif isinstance(other, six.integer_types):
             return self.__class__(self.base_address, self.displacement - other)
 
         else:
@@ -347,104 +328,105 @@
             LOG.critical("%s != %s", type(self), type(other))
             raise NotImplementedError
 
 
 class InstructionAddress(Address):
     """Class to represent an instruction address."""
 
-    def __init__(self, base_address=None, displacement=0, instruction=None):
+    def __init__(self,
+                 base_address: Variable | str | None = None,
+                 displacement: int = 0,
+                 instruction: Instruction | None = None):
         """
 
         :param base_address:  (Default value = None)
         :param displacement:  (Default value = 0)
         :param instruction:  (Default value = None)
 
         """
-        super(InstructionAddress, self).__init__(
-            base_address=base_address,
-            displacement=displacement
-        )
+        super(InstructionAddress, self).__init__(base_address=base_address,
+                                                 displacement=displacement)
         self._instruction = instruction
 
     @property
     def target_instruction(self):
         """Target instruction (:class:`~.Instruction`)"""
         return self._instruction
 
-    def set_target_instruction(self, instruction):
+    def set_target_instruction(self, instruction: Instruction):
         """Sets the instruction to which this address is pointing.
 
         :param instruction: Target instruction
         :type instruction: :class:`~.Instruction`
 
         """
 
         self._instruction = instruction
 
-    def __add__(self, other):
+    def __add__(self, other: Address | int):
         """
 
         :param other:
 
         """
         self._instruction = None
         return super(InstructionAddress, self).__add__(other)
 
-    def __iadd__(self, other):
+    def __iadd__(self, other: object):
         """
 
         :param other:
 
         """
         self._instruction = None
         return super(InstructionAddress, self).__iadd__(other)
 
-    def __mod__(self, other):
+    def __mod__(self, other: object):
         """
 
         :param other:
 
         """
         self._instruction = None
         return super(InstructionAddress, self).__mod__(other)
 
-    def __radd__(self, other):
+    def __radd__(self, other: object):
         """
 
         :param other:
 
         """
         self._instruction = None
         return super(InstructionAddress, self).__radd__(other)
 
-    def __rsub__(self, other):
+    def __rsub__(self, other: object):
         """
 
         :param other:
 
         """
         self._instruction = None
         return super(InstructionAddress, self).__rsub__(other)
 
-    def __sub__(self, other):
+    def __sub__(self, other: object):
         """
 
         :param other:
 
         """
         self._instruction = None
         return super(InstructionAddress, self).__sub__(other)
 
 
 class MemoryValue(object):
     """Class to represent a value in memory."""
 
     _cmp_attributes = ['address', 'value', 'length']
 
-    def __init__(self, address, value, length):
+    def __init__(self, address: Address, value: int, length: int):
         """
 
         :param address:
         :param value:
         :param length:
 
         """
@@ -466,84 +448,79 @@
         return self._length
 
     @property
     def value(self):
         """Actual memory value (:class:`~.int`)"""
         return self._value
 
-    def _check_cmp(self, other):
+    def _check_cmp(self, other: object):
         if not isinstance(other, self.__class__):
-            raise NotImplementedError(
-                "%s != %s" % (
-                    other.__class__, self.__class__
-                )
-            )
+            raise NotImplementedError("%s != %s" %
+                                      (other.__class__, self.__class__))
 
-    def __eq__(self, other):
+    def __eq__(self, other: object):
         """x.__eq__(y) <==> x==y"""
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if not getattr(self, attr) == getattr(other, attr):
                 return False
         return True
 
-    def __ne__(self, other):
+    def __ne__(self, other: object):
         """x.__ne__(y) <==> x!=y"""
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if not getattr(self, attr) == getattr(other, attr):
                 return True
         return False
 
-    def __lt__(self, other):
+    def __lt__(self, other: object):
         """x.__lt__(y) <==> x<y"""
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if getattr(self, attr) < getattr(other, attr):
                 return True
             elif getattr(self, attr) > getattr(other, attr):
                 return False
         return False
 
-    def __gt__(self, other):
+    def __gt__(self, other: object):
         """x.__gt__(y) <==> x>y"""
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if getattr(self, attr) > getattr(other, attr):
                 return True
             elif getattr(self, attr) < getattr(other, attr):
                 return False
         return False
 
-    def __le__(self, other):
+    def __le__(self, other: object):
         """x.__le__(y) <==> x<=y"""
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if getattr(self, attr) <= getattr(other, attr):
                 continue
             else:
                 return False
         return True
 
-    def __ge__(self, other):
+    def __ge__(self, other: object):
         """x.__ge__(y) <==> x>=y"""
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if getattr(self, attr) >= getattr(other, attr):
                 continue
             else:
                 return False
         return True
 
     def __repr__(self):
         """ """
-        return "%s(%s, Value:%s, Length:%d)" % (
-            self.__class__.__name__, self._address,
-            hex(self._value), self._length
-        )
+        return "%s(%s, Value:%s, Length:%d)" % (self.__class__.__name__,
+                                                self._address, hex(
+                                                    self._value), self._length)
 
     def __str__(self):
         """ """
-        return "%s(%s, Value:%s, Length:%d)" % (
-            self.__class__.__name__, self._address,
-            hex(self._value), self._length
-        )
+        return "%s(%s, Value:%s, Length:%d)" % (self.__class__.__name__,
+                                                self._address, hex(
+                                                    self._value), self._length)
```

## microprobe/code/bbl.py

```diff
@@ -12,101 +12,102 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.code.bbl` module
 
 """
 
 # Futures
-from __future__ import absolute_import
+from __future__ import absolute_import, annotations
+
+from typing import TYPE_CHECKING, List
 
 # Third party modules
 from six.moves import range
 
 # Own modules
-import microprobe.code.ins
+from microprobe.code.ins import Instruction
 from microprobe import MICROPROBE_RC
 from microprobe.exceptions import MicroprobeCodeGenerationError, \
     MicroprobeValueError
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import Progress
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.code.address import Address
 
 # Constants
 LOG = get_logger(__name__)
 __all__ = ["Bbl", "replicate_bbls"]
 
 
 # Functions
-def replicate_bbls(bbl_list, displacement=None):
+def replicate_bbls(bbl_list: List[Bbl], displacement: int | None = None):
     """Returns a copy the given basic block list at the specified displacement.
 
     :param bbl_list: List of basic blocks to copy
     :type bbl_list: :class:`~.list` of :class:`~.Bbl`
     :param displacement: Displacement of the copied basic blocks
                          (Default value = None)
     :type displacement: :class:`~.int`
 
     """
-    bbls_replicated = []
+    bbls_replicated: List[Bbl] = []
 
     for bbl in bbl_list:
         bbls_replicated.append(bbl.replicate(displacement=displacement))
 
     return bbls_replicated
 
 
 # Classes
-class Bbl(object):
+class Bbl:
     """Class to represent a basic block."""
 
-    def __init__(self, size, instructions=None):
+    def __init__(self, size: int, instructions: List[Instruction] = []):
         """
 
         :param size:
 
         """
         if size < 1:
-            raise MicroprobeValueError(
-                "I can not create a Bbl with %d size" % size
-            )
-
-        if instructions is None:
-            instructions = []
+            raise MicroprobeValueError("I can not create a Bbl with %d size" %
+                                       size)
 
         self._copy_id = 0
 
         self._incstep = 10000
-        self._instrs = [None] * max(self._incstep, (size + 1) * 10)
+        self._instrs: List[Instruction | None] = \
+            [None] * max(self._incstep, (size + 1) * 10)
         self._pointer = 10
 
         self._instdic = {}
 
         self._address = None
         self._displacement = 0
 
         if MICROPROBE_RC["verbose"]:
             progress = Progress(size, "Initializing BBL:")
 
         if not instructions:
             for idx in range(0, size):
                 # self._check_size()
-                instr = microprobe.code.ins.Instruction()
+                instr = Instruction()
                 self._instrs[self._pointer] = instr
                 self._instdic[instr] = self._pointer
                 self._pointer += 10
                 if MICROPROBE_RC["verbose"]:
                     progress()
         else:
             for idx in range(0, size):
                 self._check_size()
                 if idx < len(instructions):
                     self._instrs[self._pointer] = instructions[idx]
                 else:
-                    self._instrs[self._pointer] = \
-                        microprobe.code.ins.Instruction()
+                    self._instrs[self._pointer] = Instruction()
                 self._instdic[self._instrs[self._pointer]] = self._pointer
                 self._pointer += 10
                 if MICROPROBE_RC["verbose"]:
                     progress()
 
     @property
     def instrs(self):
@@ -120,67 +121,67 @@
         ]
 
     @property
     def address(self):
         """Basic block address (:class:`~.Address`)"""
         return self._address
 
-    def set_address(self, address):
+    def set_address(self, address: Address):
         """Set the basic block address.
 
         :param address: Address for the basic block
         :type address: :class:`~.Address`
 
         """
         self._address = address
 
     @property
     def displacement(self):
         """Displacement of the basic block (::class:`~.int`)"""
         return self._displacement
 
-    def set_displacement(self, displacement):
+    def set_displacement(self, displacement: int | None):
         """Set the displacement of the basic block.
 
         :param displacement: Displacement for the basic block
         :type displacement: :class:`~.int`
 
         """
         self._displacement = displacement
 
     @property
     def size(self):
         """Size of the basic block, number of instructions (::class:`~.int`)"""
         return len(self.instrs)
 
-    def _index(self, instr):
+    def _index(self, instr: Instruction):
         """Returns the index of the given instruction within the basic block.
 
         Returns the index of the given instruction within the basic block.
         If the instruction is not found, return a negative number.
 
         :param instr: Instruction instance
         :type instr: :class:`~.Instruction`
 
         """
         return self._instdic.get(instr, -1)
 
-    def get_instruction_index(self, instr):
+    def get_instruction_index(self, instr: Instruction):
         """Returns the index of the given instruction within the basic block.
 
         Returns the index of the given instruction within the basic block.
         If the instruction is not found, return a negative number.
 
         :param instr: Instruction instance
         :type instr: :class:`~.Instruction`
 
         """
         return self._index(instr)
 
-    def reset_instruction(self, instr, new_instr):
+    def reset_instruction(self, instr: Instruction, new_instr: Instruction):
         """Resets the instruction within a basic block by another instruction.
 
         Resets the instruction within a basic block by another instruction.
         If the instruction is not found, an exception is raised.
 
         :param instr: Instruction to replace
         :type instr: :class:`~.Instruction`
@@ -189,21 +190,19 @@
         :raise microprobe.exceptions.MicroprobeCodeGenerationError: if the
             instruction is not found in the basic block
 
         """
 
         idx = self._index(instr)
         if idx < 0:
-            raise MicroprobeCodeGenerationError(
-                "Instruction not found "
-                "in the basic block"
-            )
+            raise MicroprobeCodeGenerationError("Instruction not found "
+                                                "in the basic block")
         self._instrs[idx] = new_instr
 
-    def remove_instructions_from(self, instr):
+    def remove_instructions_from(self, instr: Instruction):
         """Removes the given instruction from the basic block.
 
         Removes the given instruction from the basic block. If the instruction
         is not found, the basic block is not changed.
 
         :param instr: Instruction to remove
         :type instr: :class:`~.Instruction`
@@ -220,15 +219,18 @@
         ]:
             self._instdic.pop(linstr)
 
         self._instrs = self._instrs[0:idx]
         self._pointer = idx
         self._check_size()
 
-    def insert_instr(self, instrs, before=None, after=None):
+    def insert_instr(self,
+                     instrs: List[Instruction],
+                     before: Instruction | None = None,
+                     after: Instruction | None = None):
         """Inserts a list of instruction in the basic block.
 
         Inserts a list of instruction in the basic block. Before/After
         parameters specify the instructions before/after which the new
         instruction should be added.
 
         :param instrs: Instruction to insert
@@ -260,61 +262,57 @@
 
             assert idx_before > idx_after or idx_before == -1, \
                 "Something wrong"
 
             # assert idx_before == -1 and idx_after > -1
 
             if not any(
-                    self._instrs[idx_after + 1:idx_after + 1 + len(instrs)]
-            ):
+                    self._instrs[idx_after + 1:idx_after + 1 + len(instrs)]):
 
                 self._instrs[idx_after + 1:idx_after + 1 + len(instrs)] = \
                     instrs
                 for instr in instrs:
                     assert instr not in self._instdic, "Something wrong"
                     self._instdic[instr] = idx_after + 1
                     idx_after += 1
 
             else:
 
                 self._check_size(extra=len(instrs))
                 self._instrs[(idx_after) + 1:len(instrs)] = instrs
                 self._pointer += len(instrs)
-                self._instdic = dict(
-                    [
-                        (v, idx)
-                        for idx, v in enumerate(self._instrs) if v is not None
-                    ]
-                )
+                self._instdic = dict([(v, idx)
+                                      for idx, v in enumerate(self._instrs)
+                                      if v is not None])
 
-    def _increase(self, num):
+    def _increase(self, num: int):
         """Increases the basic block size by the number specified.
 
         :param num: Number of instructions to increase
         :type num: :class:`~.int`
 
         """
 
-        instrs = []
-        for dummy_idx in range(0, num):
-            instrs.append(microprobe.code.ins.Instruction())
+        instrs: List[Instruction] = []
+        for _ in range(0, num):
+            instrs.append(Instruction())
 
         self.insert_instr(instrs)
 
-    def _check_size(self, extra=0):
+    def _check_size(self, extra: int = 0):
         """Checks and fixes basic block size.
 
         :param extra:  (Default value = 0)
 
         """
 
         if self._pointer + extra >= len(self._instrs):
             self._instrs = self._instrs + [None] * self._incstep
 
-    def replicate(self, displacement=0):
+    def replicate(self, displacement: int | None = 0):
         """Replicates current basic block.
 
         Replicates current basic block with the given extra displacement.
 
         :param displacement: Extra displacement (Default value = 0)
         :type displacement: :class:`~.int`
 
@@ -333,25 +331,25 @@
 
             new_instr.set_address(orig_instr.address + displacement)
             new_bbl.reset_instruction(new_bbl.instrs[idx], new_instr)
 
         self._copy_id += 1
         return new_bbl
 
-    def distance(self, instr1, instr2):
+    def distance(self, instr1: Instruction, instr2: Instruction):
         i1 = self.get_instruction_index(instr1)
         i2 = self.get_instruction_index(instr2)
         idxs = list(sorted([i1, i2]))
         distance = [
             elem for elem in sorted(self._instdic.values())
             if elem > idxs[0] and elem <= idxs[1]
         ]
         return len(distance)
 
-    def get_instruction_by_distance(self, instr, distance):
+    def get_instruction_by_distance(self, instr: Instruction, distance: int):
         i1 = self.get_instruction_index(instr)
         idx = sorted(self._instdic.values()).index(i1)
         if idx - distance >= 0:
             idx = idx + distance
         else:
             idx = 0
         idx = sorted(self._instdic.values())[idx]
```

## microprobe/code/benchmark.py

```diff
@@ -12,32 +12,40 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.code.benchmark` module
 
 """
 
 # Futures
-from __future__ import absolute_import, print_function
+from __future__ import absolute_import, print_function, annotations
+from typing import TYPE_CHECKING, Dict, List
 
 # Own modules
-import microprobe.code.cfg
+from microprobe.code.cfg import Cfg
 from microprobe import MICROPROBE_RC
 from microprobe.code.address import Address
 from microprobe.exceptions import MicroprobeCodeGenerationError
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import OrderedDict
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.code.context import Context
+    from microprobe.code.ins import Instruction
+    from microprobe.code.var import Variable
+
 # Constants
 LOG = get_logger(__name__)
-__all__ = ["BuildingBlock", "Benchmark",
-           "MultiThreadedBenchmark", "benchmark_factory"]
+__all__ = [
+    "BuildingBlock", "Benchmark", "MultiThreadedBenchmark", "benchmark_factory"
+]
 
 
 # Functions
-def benchmark_factory(threads=1):
+def benchmark_factory(threads: int = 1):
     if threads == 1:
         return Benchmark()
     else:
         return MultiThreadedBenchmark(num_threads=threads)
 
 
 # Classes
@@ -49,20 +57,20 @@
     inherit from this class.
 
 
     """
 
     def __init__(self):
         """ """
-        self._warnings = {}
-        self._info = []
-        self._pass_info = []
-        self._requirements = []
+        self._warnings: Dict[str, int] = {}
+        self._info: List[str] = []
+        self._pass_info: List[str] = []
+        self._requirements: List[str] = []
 
-    def add_warning(self, message):
+    def add_warning(self, message: str):
         """Add a warning message to the building block.
 
         :param message: Warning message
         :type message: :class:`~.str`
 
         """
 
@@ -76,24 +84,24 @@
         """List of warnings of the building block
 
         List of warnings of the building block
         (:class:`~.list` of :class:`~.str`)
         """
         return self._warnings
 
-    def add_pass_info(self, message):
+    def add_pass_info(self, message: str):
         """Add an pass information message to the building block.
 
         :param message: Information pass message
         :type message: :class:`~.str`
 
         """
         self._pass_info.append(message)
 
-    def add_info(self, message):
+    def add_info(self, message: str):
         """Add an information message to the building block.
 
         :param message: Information message
         :type message: :class:`~.str`
 
         """
         self._info.append(message)
@@ -112,15 +120,15 @@
         """List of information pass messages of the building block
         (:class:`~.list` of :class:`~.str`)
 
 
         """
         return self._pass_info
 
-    def add_requirement(self, message):
+    def add_requirement(self, message: str):
         """Add an requirement message to the building block.
 
         :param message: Requirement message
         :type message: :class:`~.str`
 
         """
         self._requirements.append(message)
@@ -138,59 +146,57 @@
 class Benchmark(BuildingBlock):
     """Class to represent a benchmark (highest level building block)."""
 
     def __init__(self):
         """ """
 
         super(Benchmark, self).__init__()
-        self._cfg = microprobe.code.cfg.Cfg()
-        self._global_vars = OrderedDict()
-        self._init = []
-        self._fini = []
+        self._cfg = Cfg()
+        self._global_vars: Dict[str, Variable] = OrderedDict()
+        self._init: List[Instruction] = []
+        self._fini: List[Instruction] = []
         self._vardisplacement = 0
         self._context = None
         self._num_threads = 1
 
     @property
     def init(self):
         """Initialization instructions
 
         Initialization instructions (:class:`~.list` of :class:`~.Instruction`)
         """
         return self._init
 
-    def add_init(self, inits, prepend=False):
+    def add_init(self, inits: List[Instruction], prepend: bool = False):
         """Appends the specified list of instructions to initialization list
 
         :param inits: List of instructions to be added
         :type inits: :class:`~.list` of :class:`~.Instruction`
 
         """
         LOG.debug("Add Init")
         for init in inits:
-            LOG.debug(
-                "NEW INIT INSTRUCTION: %s (prepend: %s)",
-                init.assembly(), prepend
-            )
+            LOG.debug("NEW INIT INSTRUCTION: %s (prepend: %s)",
+                      init.assembly(), prepend)
 
         if not prepend:
             self._init = self._init + inits
         else:
             self._init = inits + self._init
 
-    def rm_init(self, inits):
+    def rm_init(self, inits: List[Instruction]):
         """Removes from the initialization list the specified instructions.
 
         :param inits: List of instructions to be removed
         :type inits: :class:`~.list` of :class:`~.Instruction`
 
         """
         self._init = self._init[0:-len(inits)]
 
-    def add_fini(self, finis):
+    def add_fini(self, finis: List[Instruction]):
         """Appends the specified list of instructions to the finalization list
 
         :param finis: List of instructions to be added
         :type finis: :class:`~.list` of :class:`~.Instruction`
 
         """
         self._fini = self._fini + finis
@@ -202,60 +208,56 @@
         return self._fini
 
     @property
     def cfg(self):
         """Returns the benchmark control flow graph."""
         return self._cfg
 
-    def set_cfg(self, cfg):
+    def set_cfg(self, cfg: Cfg):
         """Sets the benchmarks control flow graph.
 
         :param cfg: Control flow graph
         :type cfg: :class:`~.Cfg`
 
         """
         self._cfg = cfg
 
     def registered_global_vars(self):
         """Returns the list of registered global variables."""
         return list(self._global_vars.values())
 
-    def set_var_displacement(self, displacement):
+    def set_var_displacement(self, displacement: int):
         # Displacement only can increase
         assert displacement > self._vardisplacement
         self._vardisplacement = displacement
 
-    def register_var(self, var, context):
+    def register_var(self, var: Variable, context: Context):
         """Registers the given variable as a global variable.
 
         :param var: Variable to register
         :type var: :class:`~.Variable`
 
         """
 
         LOG.debug("Registering global var: '%s'", var.name)
 
         if var.name in self._global_vars:
 
             var2 = self._global_vars[var.name]
-            if (var.value == var2.value and
-                    var.address == var2.address and
-                    var.address is not None and
-                    MICROPROBE_RC['safe_bin']):
-                LOG.warning(
-                    "Variable: '%s' registered multiple times!", var.name
-                )
+            if (var.value == var2.value and var.address == var2.address
+                    and var.address is not None and MICROPROBE_RC['safe_bin']):
+                LOG.warning("Variable: '%s' registered multiple times!",
+                            var.name)
 
                 return
 
             LOG.critical("Registered variables: %s",
                          list(self._global_vars.keys()))
             raise MicroprobeCodeGenerationError(
-                "Variable already registered: %s" % (var.name)
-            )
+                "Variable already registered: %s" % (var.name))
 
         self._global_vars[var.name] = var
 
         if context.symbolic and var.address is None:
 
             LOG.debug("Context symbolic. No need to track base addresses")
             var_address = Address(base_address=var.name, displacement=0)
@@ -267,67 +269,61 @@
             # if (self._vardisplacement == 0 and
             #        context.data_segment is not None):
             #     self._vardisplacement = context.data_segment
 
             address_ok = False
 
             while not address_ok:
-                var_address = Address(
-                    base_address="data",
-                    displacement=self._vardisplacement
-                )
+                var_address = Address(base_address="data",
+                                      displacement=self._vardisplacement)
 
                 LOG.debug("Address before alignment: %s", var_address)
 
                 align = var.align
                 if align is None:
                     align = 1
 
                 LOG.debug("Variable alignment: %s", align)
                 LOG.debug("Current address: %s", var_address)
 
                 if (var_address.displacement +
                         context.data_segment) % align != 0:
                     # alignment needed
-                    var_address += align - ((
-                        var_address.displacement+context.data_segment) % align
-                    )
+                    var_address += align - (
+                        (var_address.displacement + context.data_segment) %
+                        align)
 
                 LOG.debug("Address after alignment: %s", var_address)
-                LOG.debug(
-                    "Current var displacement: %x", self._vardisplacement
-                )
+                LOG.debug("Current var displacement: %x",
+                          self._vardisplacement)
 
                 var.set_address(var_address)
                 over = self._check_variable_overlap(var)
 
                 if over is not None:
                     self._vardisplacement = max(
                         self._vardisplacement,
-                        over.address.displacement + over.size
-                    )
+                        over.address.displacement + over.size)
                     continue
 
                 address_ok = True
                 LOG.debug("Variable registered at address: '%s'", var_address)
 
             self._vardisplacement = var_address.displacement + var.size
 
         else:
             LOG.debug("Using pre-defined address: '%s'", var.address)
 
         over = self._check_variable_overlap(var)
         if over is not None:
             raise MicroprobeCodeGenerationError(
-                "Variable '%s' overlaps with variable '%s'" % (
-                    var.name, over.name
-                )
-            )
+                "Variable '%s' overlaps with variable '%s'" %
+                (var.name, over.name))
 
-    def _check_variable_overlap(self, var):
+    def _check_variable_overlap(self, var: Variable):
 
         return None
 
         vara = var.address
         vara2 = vara + var.size
 
         for rvar in self._global_vars.values():
@@ -348,29 +344,32 @@
                 return rvar
 
             if rvara <= vara and rvara2 >= vara2:
                 return rvar
 
         return None
 
-    def set_context(self, context):
+    def set_context(self, context: Context):
         """Set the execution context of the building block.
 
         :param context: Execution context
         :type context: :class:`~.Context`
 
         """
         self._context = context
 
     @property
     def context(self):
         """Return benchmark's context"""
         return self._context
 
-    def add_instructions(self, instrs, after=None, before=None):
+    def add_instructions(self,
+                         instrs: List[Instruction],
+                         after: Instruction | None = None,
+                         before: Instruction | None = None):
         """Adds the given instruction to the building block.
 
         Adds the given instructions right after the specified instruction and
         before the specified one. If the condition can not be fulfilled an
         specification exception is raised.
 
         :param instrs: Instruction to add
@@ -407,16 +406,15 @@
                 bbl.insert_instr(instrs)
             elif idx_before == idx_after:
                 bbl = self.cfg.get_bbl(idx_before)
                 bbl.insert_instr(instrs, after=after, before=before)
             else:
                 raise MicroprobeCodeGenerationError(
                     "Attempt to inserst instruction in a position that it is"
-                    " not possible"
-                )
+                    " not possible")
 
     @property
     def code_size(self):
         """Return benchmark's size"""
 
         size = 0
         for bbl in self.cfg.bbls:
@@ -431,42 +429,41 @@
         labels = [key.upper() for key in self._global_vars.keys()]
         for bbl in self.cfg.bbls:
             for instr in bbl.instrs:
                 if instr.label is not None:
                     labels.append(instr.label.upper())
 
         labels += [
-            instr.label.upper()
-            for instr in self._fini if instr.label is not None
+            instr.label.upper() for instr in self._fini
+            if instr.label is not None
         ]
 
         labels += [
-            instr.label.upper()
-            for instr in self._init if instr.label is not None
+            instr.label.upper() for instr in self._init
+            if instr.label is not None
         ]
 
         return labels
 
-    def set_current_thread(self, idx):
+    def set_current_thread(self, idx: int):
         """ """
         self._current_thread = idx
         if not 1 <= idx <= self._num_threads + 1:
             raise MicroprobeCodeGenerationError(
                 "Unknown thread id: %d (min: 1, max: %d)" %
-                (idx, self._num_threads + 1)
-            )
+                (idx, self._num_threads + 1))
 
 
 class MultiThreadedBenchmark(Benchmark):
     """ """
 
-    def __init__(self, num_threads=1):
+    def __init__(self, num_threads: int = 1):
         """ """
         self._num_threads = num_threads
-        self._threads = {}
+        self._threads: Dict[int, Benchmark] = {}
         for idx in range(1, num_threads + 1):
             self._threads[idx] = Benchmark()
         self._current_thread = 1
 
-    def __getattr__(self, attribute_name):
-        return self._threads[
-            self._current_thread].__getattribute__(attribute_name)
+    def __getattr__(self, attribute_name: str):
+        return self._threads[self._current_thread].__getattribute__(
+            attribute_name)
```

## microprobe/code/cfg.py

```diff
@@ -12,74 +12,78 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.code.cfg` module
 
 """
 
 # Futures
-from __future__ import absolute_import
+from __future__ import absolute_import, annotations
+from typing import TYPE_CHECKING, List, Tuple
 
 # Own modules
-import microprobe.code.bbl
+from microprobe.code.bbl import Bbl
 from microprobe.utils.logger import get_logger
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.code.ins import Instruction
 
 # Constants
 LOG = get_logger(__name__)
 __all__ = ["Cfg"]
 
 # Functions
 
 # Classes
 
 
-class Cfg(object):
+class Cfg:
     """Class to represent the control flow graph of a building block."""
 
     def __init__(self):
         """ """
-        self._cfg_nodes = []
-        self._cfg_edges = []
+        self._cfg_nodes: List[Bbl] = []
+        self._cfg_edges: List[Tuple[int, int]] = []
         self._idx = 0
         self._last_bbl = None
         self._first_bbl = None
 
-    def add_bbl(self, bbl=None, size=1, instructions=None):
+    def add_bbl(self,
+                bbl: Bbl | None = None,
+                size: int = 1,
+                instructions: List[Instruction] | None = None):
         """Adds a basic block to the control flow graph of the specified size.
 
         :param bbl: Basic block to add (if none, one is created)
                     (Default value = None)
         :type bbl: :class:`~.Bbl`
         :param size: Size of the new basic block (Default value = 1)
         :type size: ::class:`~.int`
         :param instructions: Instructions for the basic block
         :type instructions: :class:`~.list` of :class:`~.Instruction`
 
         """
         if bbl is None:
 
             if instructions is not None:
-                bbl = microprobe.code.bbl.Bbl(
-                    len(instructions),
-                    instructions=instructions
-                )
+                bbl = Bbl(len(instructions), instructions=instructions)
             else:
-                bbl = microprobe.code.bbl.Bbl(size)
+                bbl = Bbl(size)
 
         self._cfg_nodes.append(bbl)
         self._cfg_edges.append((self._idx, self._idx + 1))
 
         if self._first_bbl is None:
             self._first_bbl = 0
 
         self._last_bbl = self._idx
         self._idx += 1
         return bbl
 
-    def add_bbls(self, bbls):
+    def add_bbls(self, bbls: List[Bbl]):
         """Adds a list of basic blocks to the control flow graph.
 
         :param bbls: Lists of basic blocks to add.
         :type bbls: :class:`~.list` of :class:`~.Bbl`
 
         """
         for bbl in bbls:
@@ -87,32 +91,31 @@
 
     @property
     def bbls(self):
         """List of basic blocks in the CFG
         (:class:`~.list` of :class:`~.Bbl`)."""
         return self._cfg_nodes[:]
 
-    def index(self, instr):
+    def index(self, instr: Instruction):
         """Returns index of the basic block containing the given instruction.
 
         :param instr: Instruction to look for
         :type instr: :class:`~.Instruction`
 
         """
         rlist = [
-            idx
-            for idx, bbl in enumerate(self.bbls)
+            idx for idx, bbl in enumerate(self.bbls)
             if bbl.get_instruction_index(instr) >= 0
         ]
 
         if rlist:
             return -1
         return rlist[0]
 
-    def get_bbl(self, index):
+    def get_bbl(self, index: int):
         """Returns the basic block at the specified index
 
         :param index: Index of the bbl
         :type index: :class:`~.int`
 
         """
         return self._cfg_nodes[index]
```

## microprobe/code/context.py

```diff
@@ -25,15 +25,15 @@
 import six
 
 # Own modules
 from microprobe.code.address import Address, InstructionAddress
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import RejectingDict, smart_copy_dict
 
-# Type hints
+# Type hinting
 if TYPE_CHECKING:
     from microprobe.target.isa.register import Register
     from microprobe.code.address import MemoryValue
     from microprobe.target.isa.dat import DynamicAddressTranslation
 
 # Constants
 LOG = get_logger(__name__)
@@ -46,39 +46,35 @@
 class Context(object):  # pylint: disable=too-many-public-methods
     """Class to represent the execution context (e.g. register values, etc ...
     on each benchmark building block)
 
 
     """
 
-    def __init__(
-            self,
-            default_context: Context | None = None,
-            code_segment: int | None = None,
-            data_segment: int | None = None,
-            symbolic: bool = True,
-            absolute: bool = False
-    ):
+    def __init__(self,
+                 default_context: Context | None = None,
+                 code_segment: int | None = None,
+                 data_segment: int | None = None,
+                 symbolic: bool = True,
+                 absolute: bool = False):
         """
 
         :param default_context:  (Default value = None)
         :param code_segment:  (Default value = None)
         :param data_segment:  (Default value = None)
         :param symbolic:  (Default value = True)
 
         """
 
         self._reserved_registers: Dict[str, Register] = RejectingDict()
 
-        self._register_values: Dict[
-            Register, int | float | Address | str | None
-        ] = {}
-        self._value_registers: Dict[
-            int | float | Address | str, List[Register]
-        ] = {}
+        self._register_values: Dict[Register,
+                                    int | float | Address | str | None] = {}
+        self._value_registers: Dict[int | float | Address | str,
+                                    List[Register]] = {}
         self._memory_values: Dict[Address, MemoryValue] = {}
         self._value_memorys: Dict[MemoryValue, List[MemoryValue]] = {}
 
         self._data_segment = data_segment
         self._code_segment = code_segment
         self._symbolic = symbolic
         self._fabsolute = absolute
@@ -91,16 +87,15 @@
     def copy(self):
         """Returns a copy of the current context."""
 
         newcontext = Context()
 
         # pylint: disable=protected-access
         newcontext._reserved_registers = smart_copy_dict(
-            self._reserved_registers
-        )
+            self._reserved_registers)
         newcontext._register_values = smart_copy_dict(self._register_values)
         newcontext._value_registers = smart_copy_dict(self._value_registers)
         newcontext._memory_values = smart_copy_dict(self._memory_values)
         newcontext._value_memorys = smart_copy_dict(self._value_memorys)
 
         if self._dat is not None:
             newcontext.set_dat(self._dat.copy())
@@ -130,34 +125,33 @@
         :type rregs: :class:`~.list` of :class:`~.Register`
 
         """
 
         for reg in rregs:
             del self._reserved_registers[reg.name]
 
-    def set_register_value(
-            self,
-            register: Register, value: int | float | Address | str
-    ):
+    def set_register_value(self, register: Register,
+                           value: int | float | Address | str):
         """Set the provided register to the specified value.
 
         :param register: Register to set
         :type register: :class:`~.Register`
         :param value: Value to assign
         :type value: :class:`~.int`, :class:`~.float`, :class:`~.long`,
              :class:`~.Address` or :class:`~.str`
 
         """
 
         LOG.debug("Setting %s to %s", register.name, value)
 
         assert isinstance(
-            value, tuple(list(six.integer_types) +
-                         [float, Address, InstructionAddress, str])
-        ), type(value)
+            value,
+            tuple(
+                list(six.integer_types) +
+                [float, Address, InstructionAddress, str])), type(value)
 
         if isinstance(value, str):
             assert len(value.split("_")) == 2
 
         if self.get_register_value(register) is not None:
             self.unset_register(register)
 
@@ -190,16 +184,15 @@
         for reg, val in self._register_values.items():
 
             if not isinstance(val, type(value)):
                 continue
 
             possible_regs.append((reg, val))
 
-        possible_regs = sorted(possible_regs,
-                               key=lambda x: abs(x[1] - value))
+        possible_regs = sorted(possible_regs, key=lambda x: abs(x[1] - value))
         if possible_regs:
             return possible_regs[0]
 
         return None
 
     def get_closest_address_value(self, address: Address):
         """Returns the closest address to the given address.
@@ -219,17 +212,17 @@
             if not isinstance(value, Address):
                 continue
 
             if Address(base_address=value.base_address) == \
                     Address(base_address=address.base_address):
                 possible_regs.append((reg, value))
 
-        possible_regs = sorted(possible_regs,
-                               key=lambda x: abs(x[1].displacement -
-                                                 address.displacement))
+        possible_regs = sorted(
+            possible_regs,
+            key=lambda x: abs(x[1].displacement - address.displacement))
         if possible_regs:
             return possible_regs[0]
 
         return None
 
     def get_register_closest_value(self, value: int | float | str):
         """Returns the register with the closest value to the given value.
@@ -259,17 +252,18 @@
                     continue
 
             possible_regs.append((reg, reg_value))
 
         if not isinstance(value, str):
             possible_regs = sorted(possible_regs, key=lambda x: abs(x - value))
         else:
-            possible_regs = sorted(possible_regs,
-                                   key=lambda x: abs(int(x.split("_")[0]) -
-                                                     int(value.split("_")[0])))
+            possible_regs = sorted(
+                possible_regs,
+                key=lambda x: abs(
+                    int(x.split("_")[0]) - int(value.split("_")[0])))
 
         if possible_regs:
             return possible_regs[0]
 
         return None
 
     def get_register_value(self, register: Register):
@@ -297,16 +291,15 @@
         assert isinstance(register_name, str)
 
         register_names = [reg.name for reg in self._register_values]
         if register_name not in register_names:
             return None
 
         register = [
-            reg for reg in self._register_values
-            if reg.name == register_name
+            reg for reg in self._register_values if reg.name == register_name
         ][0]
 
         return self._register_values.get(register, None)
 
     def unset_registers(self, registers: List[Register]):
         """Removes the values from registers.
 
@@ -349,18 +342,16 @@
         self._memory_values[mem_value.address] = mem_value
 
         if mem_value.value in self._memory_values:
 
             if mem_value not in self._value_memorys[mem_value.value]:
 
                 self._value_memorys[mem_value.value].append(mem_value)
-                LOG.debug(
-                    "Values inv %s: %s", mem_value.value,
-                    self._value_memorys[mem_value.value]
-                )
+                LOG.debug("Values inv %s: %s", mem_value.value,
+                          self._value_memorys[mem_value.value])
 
             else:
                 LOG.debug("Already in inv dictionary")
 
         else:
 
             self._value_memorys[mem_value.value] = [mem_value]
@@ -393,31 +384,28 @@
         :type length: :class:`~.int`
 
         """
 
         LOG.debug("Start unset address: %s (length: %s)", address, length)
 
         possible_addresses = [
-            addr
-            for addr in self._memory_values
+            addr for addr in self._memory_values
             if addr.base_address == address.base_address
         ]
 
         # LOG.debug("Possible addresses: %s", possible_addresses)
 
         for paddr in possible_addresses:
 
             diff = paddr - address
             diff2 = address - paddr
             length2 = self._memory_values[paddr].length
 
-            if (
-                    (diff >= 0 and diff < length) or
-                    (diff2 >= 0 and diff2 < length2)
-            ):
+            if ((diff >= 0 and diff < length)
+                    or (diff2 >= 0 and diff2 < length2)):
 
                 LOG.debug("Address overlap: %s", paddr)
                 mem_value = self._memory_values.pop(paddr)
 
                 LOG.debug("Memory value: %s", mem_value)
 
                 if mem_value in self._value_memorys[mem_value.value]:
@@ -428,16 +416,18 @@
     def register_has_value(self, value: int | float | Address | str):
         """Returns if a value is in a register.
 
         :param value: Value to look for
         :type value: :class:`~.bool`
 
         """
-        return value in list([elem for elem in self._value_registers.keys()
-                             if type(elem) == type(value)])
+        return value in list([
+            elem for elem in self._value_registers.keys()
+            if type(elem) == type(value)
+        ])
 
     def registers_get_value(self, value: int | float | Address | str):
         """Gets a list of registers containing the specified value.
 
         :param value: Value to look for
         :type value: :class:`~.int` or :class:`~.float` or :class:`~.Address`
 
@@ -562,18 +552,16 @@
             mstr.append("Idx:\t%s\tValue:\t%s" % (key, value))
 
         mstr.append("Registers values:")
         for key, value in sorted(self._register_values.items()):
             mstr.append("Idx:\t%s\tRaw Value:\t%s" % (key, value))
 
         mstr.append("Registers values inverted:")
-        for key, value in sorted([
-                    (str(k), str(v)) for k, v
-                    in self._value_registers.items()
-                ]):
+        for key, value in sorted([(str(k), str(v))
+                                  for k, v in self._value_registers.items()]):
             mstr.append("Idx:\t%s\tValue:\t%s" % (key, value))
 
         mstr.append("Memory values:")
         for key, value in sorted(self._memory_values.items()):
             mstr.append("Idx:\t%s\tRaw Value:\t%s" % (key, value))
 
         mstr.append("Memory values inverted:")
```

## microprobe/code/ins.py

```diff
@@ -12,19 +12,20 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.code.ins` module
 
 """
 
 # Futures
-from __future__ import absolute_import, division, print_function
+from __future__ import absolute_import, division, print_function, annotations
 
 # Built-in modules
 import copy
 from itertools import product
+from typing import TYPE_CHECKING, Callable
 
 # Third party modules
 import six
 from six.moves import range, zip
 
 # Own modules
 from microprobe.code.address import Address, InstructionAddress
@@ -35,14 +36,19 @@
     OperandConstReg, OperandDescriptor, OperandImmRange
 from microprobe.target.isa.register import Register
 from microprobe.utils.asm import interpret_asm
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import OrderedDict, \
     Pickable, RejectingDict, RejectingOrderedDict
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.target.isa.instruction import InstructionType
+    from microprobe.code.context import Context
+    from microprobe.target import Target
 
 # Constants
 LOG = get_logger(__name__)
 __all__ = [
     "Instruction",
     "InstructionMemoryOperandValue",
     "InstructionOperandValue",
@@ -55,15 +61,15 @@
     'instruction_factory',
 ]
 
 _LABEL_COUNTER = 0
 
 
 # Functions
-def instruction_to_definition(instr):
+def instruction_to_definition(instr: Instruction):
     """
     Return the definition of an instruction.
 
     Given an :class:`~.Instruction` object, return the corresponding
     :class:`~.MicroprobeInstructionDefinition` object.
 
     :param instr: Instruction object
@@ -77,44 +83,46 @@
     asm = instr.assembly()
     comments = instr.comments
     if instr.disable_asm is True:
         asmfmt = "0x%%0%dX" % (len(instr.binary()) / 4)
         asm = asmfmt % int(instr.binary(), 2)
         comments = [instr.assembly()] + instr.comments
 
-    return MicroprobeInstructionDefinition(instr.architecture_type, [
-        operand.value for operand in instr.operands()
-    ], label, instr.address, asm,
-        instr.decorators, comments)
+    return MicroprobeInstructionDefinition(
+        instr.architecture_type,
+        [operand.value for operand in instr.operands()], label, instr.address,
+        asm, instr.decorators, comments)
 
 
-def instruction_from_definition(definition, fix_relative=True):
+def instruction_from_definition(definition: MicroprobeInstructionDefinition,
+                                fix_relative: bool = True):
     """
     Return the instruction from a definition.
 
     Given an :class:`~.MicroprobeInstructionDefinition` object, return the
     corresponding :class:`~.Instruction` object.
 
     :param instr: Instruction definition object
     :type instr: :class:`~.MicroprobeInstructionDefinition`
     :rtype: :class:`~.Instruction`
     """
 
     ninstr = Instruction()
-    instruction_set_def_properties(
-        ninstr, definition, fix_relative=fix_relative)
+    instruction_set_def_properties(ninstr,
+                                   definition,
+                                   fix_relative=fix_relative)
     return ninstr
 
 
 def instruction_set_def_properties(instr,
-                                   definition,
+                                   definition: MicroprobeInstructionDefinition,
                                    building_block=None,
-                                   target=None,
+                                   target: Target | None = None,
                                    allowed_registers=None,
-                                   fix_relative=True,
+                                   fix_relative: bool = True,
                                    label_displ=None):
     """
     Set instruction properties from an intruction definition.
 
     Set instruction properties according to the properties in the instruction
     definition. If *building_block* is provided, its context is used.
     Otherwise, an empty context is used. The *target* is the target platform
@@ -163,17 +171,17 @@
         fixed_operands = []
         relocation_mode = False
         LOG.debug("Fixed operands: %s", fixed_operands)
 
         for idx, operand in enumerate(operands):
             LOG.debug("Fixing operands: %s", operand)
 
-            if (isinstance(operand, six.integer_types) and
-                    instr.operands()[idx].type.address_relative and
-                    fix_relative):
+            if (isinstance(operand, six.integer_types)
+                    and instr.operands()[idx].type.address_relative
+                    and fix_relative):
                 LOG.debug("Hardcoded displacement")
                 if instr.branch:
 
                     LOG.debug("Branch label")
                     if label is None:
                         if label_displ is not None:
                             label = "instr_displ_label_%s" % (label_displ)
@@ -198,23 +206,21 @@
             displacement = 0
 
             # Check if there is displacement from a variable
             if building_block is not None:
                 for var in building_block.registered_global_vars():
                     if operand.startswith(var.name) and "@" not in operand:
                         if operand.replace(var.name, "") != "":
-                            displacement = int(
-                                operand.replace(var.name, ""),
-                                base=0)
+                            displacement = int(operand.replace(var.name, ""),
+                                               base=0)
                             operand = var.name
                             break
 
                 possible_vars = [
-                    var
-                    for var in building_block.registered_global_vars()
+                    var for var in building_block.registered_global_vars()
                     if var.name == operand
                 ]
 
                 LOG.debug("Possible variables: %s", possible_vars)
 
                 if len(possible_vars) == 1:
                     LOG.debug("Operand variable")
@@ -264,16 +270,16 @@
         assert len(fixed_operands) == len(operands)
 
         LOG.debug("Setting operands: %s", fixed_operands)
         if not relocation_mode:
             instr.set_operands(fixed_operands)
         else:
             for operand, value in zip(instr.operands(), fixed_operands):
-                if (isinstance(operand.type, OperandImmRange) and
-                        "@" in value):
+                if (isinstance(operand.type, OperandImmRange)
+                        and "@" in value):
                     operand.set_value(value, check=False)
                 else:
                     operand.set_value(value)
 
     if address is not None:
         instr.set_address(address.copy())
 
@@ -283,16 +289,16 @@
     for decorator_key, decorator_value in decorators.items():
 
         if decorator_key in ['MA', 'BT', 'EA']:
             if not isinstance(decorator_value, list):
                 decorator_value = [decorator_value]
             decorator_value = ["0x%016X" % elem for elem in decorator_value]
 
-        instr.add_comment("Decorator: %s = %s" % (decorator_key,
-                                                  decorator_value))
+        instr.add_comment("Decorator: %s = %s" %
+                          (decorator_key, decorator_value))
         instr.add_decorator(decorator_key, decorator_value)
 
     for register_name in allowed_registers:
         if register_name not in list(target.registers.keys()):
             raise MicroprobeCodeGenerationError(
                 "Unknown register '%s'. Known registers: %s" %
                 (register_name, list(target.registers.keys())))
@@ -337,15 +343,15 @@
     instrs = [
         instruction_from_definition(asm_def, fix_relative=fix_relative)
         for asm_def in asm_defs
     ]
     return instrs
 
 
-def instruction_factory(ins_type):
+def instruction_factory(ins_type: InstructionType):
     """Return a instruction of the given instruction type.
 
     :param ins_type: Instruction type of the new instruction
     :type ins_type: :class:`~.InstructionType`
     :return: A new instruction instance with the type *ins_type*
     :rtype: :class:`~.Instruction`
     """
@@ -354,15 +360,15 @@
     return instruction
 
 
 # Classes
 class InstructionOperandValue(Pickable):
     """Class to represent an instruction operand value"""
 
-    def __init__(self, operand_descriptor):
+    def __init__(self, operand_descriptor: OperandDescriptor):
         """
 
         :param operand_descriptor:
 
         """
         self._operand_descriptor = operand_descriptor
         self._value = None
@@ -387,23 +393,23 @@
         newobj = InstructionOperandValue(self._operand_descriptor)
         if self.value is not None:
             newobj.set_value(self.value)
         newobj.register_operand_callbacks(self._set_function,
                                           self._unset_function)
         return newobj
 
-    def set_descriptor(self, descriptor):
+    def set_descriptor(self, descriptor: OperandDescriptor):
         """
 
         :param descriptor:
 
         """
         self._operand_descriptor = descriptor
 
-    def set_value(self, value, check=True):
+    def set_value(self, value, check: bool = True):
         """
 
         :param value:
         :param check:  (Default value = True)
 
         """
         if self._value is not None and self._unset_function is not None:
@@ -444,32 +450,44 @@
         :rtype: :class:`~.list` of :class:`~.Register`
         """
         if not self.is_input or self._value is None:
             return []
 
         return self._operand_descriptor.type.access(self.value)
 
-    def __getattr__(self, name):
+    @property
+    def type(self):
+        """Type of the operand descriptor (:class:`~.Operand`)"""
+        return self._operand_descriptor._type
+
+    @property
+    def is_input(self):
+        """Is input flag (:class:`~.bool`) """
+        return self._operand_descriptor._is_input
+
+    @property
+    def is_output(self):
+        """Is output flag (:class:`~.bool`) """
+        return self._operand_descriptor._is_output
+
+    def set_type(self, new_type):
         """
 
-        :param name:
+        :param new_type:
 
         """
-        try:
-            return self._operand_descriptor.__getattribute__(name)
-        except AttributeError:
-            raise AttributeError("'%s' object has no attribute '%s'" %
-                                 (self.__class__.__name__, name))
+        self._operand_descriptor._type = new_type
 
     def __repr__(self):
         """ """
         return "%s(Type: %s, Value: %s)" % (self.__class__.__name__, self.type,
                                             self.value)
 
-    def register_operand_callbacks(self, set_function, unset_function):
+    def register_operand_callbacks(self, set_function,
+                                   unset_function: Callable[[], None]):
         """
 
         :param set_function:
         :param unset_function:
 
         """
 
@@ -510,15 +528,16 @@
         self._forbidden_min = None
         self._forbidden_max = None
 
         if not self.variable_length:
             self._length = self._compute_length()
 
     def register_mem_operand_callback(self, set_address, set_length,
-                                      unset_address, unset_length):
+                                      unset_address: Callable[[], None],
+                                      unset_length: Callable[[], None]):
         """
 
         :param set_address:
         :param set_length:
         :param unset_address:
         :param unset_length:
 
@@ -556,28 +575,28 @@
         return self._operand_values
 
     @property
     def variable_length(self):
         """Variable length value(:class:`~.bool`)."""
 
         operand_values = [
-            operand
-            for operand in self._length_values
+            operand for operand in self._length_values
             if (isinstance(operand, InstructionOperandValue) or isinstance(
                 operand, OperandDescriptor) or isinstance(operand, tuple))
         ]
 
         if len(operand_values) > 0:
             for operand in operand_values:
                 if isinstance(operand, tuple):
                     return True
                 elif len(list(operand.type.values())) > 1:
                     return True
-                elif not isinstance(list(operand.type.values())[0],
-                                    tuple([str] + list(six.integer_types))):
+                elif not isinstance(
+                        list(operand.type.values())[0],
+                        tuple([str] + list(six.integer_types))):
                     return True
 
         return False
 
     def _compute_length(self):
         """Compute legnth based on current operand values."""
 
@@ -590,51 +609,48 @@
                 length = 0
             else:
                 LOG.critical("Warning unknown length: %s", str(operand))
                 raise NotImplementedError
 
         return length
 
-    def _compute_possible_lengths(self, context):
+    def _compute_possible_lengths(self, context: Context):
         """Compute the possible lengths that can be generated.
 
         Compute the possible lengths that can be generated from the context
         specified.
 
         :param context: execution context
         :type context: :class:`~.Context`
 
         """
         if not self.variable_length:
             self._possible_lengths = [self._length]
             return
 
         operand_values = [
-            operand
-            for operand in self._length_values
+            operand for operand in self._length_values
             if isinstance(operand, InstructionOperandValue)
         ]
 
         operand_constants = [
-            operand
-            for operand in self._length_values
-            if (not isinstance(operand, InstructionOperandValue) and
-                not isinstance(operand, tuple) and not isinstance(
-                    operand, OperandDescriptor))
+            operand for operand in self._length_values
+            if (not isinstance(operand, InstructionOperandValue)
+                and not isinstance(operand, tuple)
+                and not isinstance(operand, OperandDescriptor))
         ]
 
         operand_register_const = [
-            operand
-            for operand in self._length_values
+            operand for operand in self._length_values
             if isinstance(operand, OperandDescriptor)
         ]
 
         operand_special = [
-            operand
-            for operand in self._length_values if isinstance(operand, tuple)
+            operand for operand in self._length_values
+            if isinstance(operand, tuple)
         ]
 
         operand_registers_diff = [
             operand for operand in operand_special if operand[1] != "MASK"
         ]
 
         operand_masks = [
@@ -661,21 +677,20 @@
 
             for idx, operand in enumerate(operand_values):
 
                 if operand.type.immediate:
 
                     # Check if the operand is negated
                     preindex = [
-                        lidx
-                        for lidx, elem in enumerate(self._length_values)
+                        lidx for lidx, elem in enumerate(self._length_values)
                         if elem == operand
                     ][0]
 
-                    if (preindex > 0 and self._length_values[
-                            preindex - 1] == "-"):
+                    if (preindex > 0
+                            and self._length_values[preindex - 1] == "-"):
                         LOG.debug("Negated Immediate operand")
                         operand_lengths[operand] = [
                             elem * (-1) for elem in operand.type.values()
                         ]
                         negate_idx.append(idx)
                     else:
                         LOG.debug("Immediate operand")
@@ -758,16 +773,16 @@
 
                 if val1 in context.reserved_registers and not allow_reserved:
                     LOG.debug("%s in reserved registers", val1)
                     continue
 
                 for val2 in reg2_vals:
 
-                    if (val2 in context.reserved_registers and
-                            not allow_reserved):
+                    if (val2 in context.reserved_registers
+                            and not allow_reserved):
                         LOG.debug("%s in reserved registers", val2)
                         continue
 
                     LOG.debug("Checking combination: %s and %s", val1, val2)
 
                     ival1 = int(val1.representation)
                     ival2 = int(val2.representation)
@@ -781,16 +796,16 @@
                         continue
 
                     if not allow_reserved:
 
                         skip = False
 
                         for reserved in context.reserved_registers:
-                            if (int(reserved.representation) > ival2 and
-                                    int(reserved.representation) < ival1):
+                            if (int(reserved.representation) > ival2
+                                    and int(reserved.representation) < ival1):
                                 skip = True
                                 break
 
                         if skip:
                             LOG.debug("Skipping: traversing reserved register")
                             continue
 
@@ -871,16 +886,15 @@
 
                     else:
 
                         lengths_to_remove.append(length)
 
                         # TODO: Maximum length is hard-coded to 1024 bytes
                         for elem in range(
-                                0,
-                                min((2**length[0].type.size) - 1, 1024),
+                                0, min((2**length[0].type.size) - 1, 1024),
                                 ceil_value):
                             newlengths[(length[0], elem)] = elem
 
                 elif operand_constant.startswith("min"):
                     assert isinstance(length, tuple)
 
                     maxvalue = int(operand_constant.replace("min", ""))
@@ -899,23 +913,23 @@
                             if isinstance(length, six.integer_types):
 
                                 if length > maxvalue:
                                     lengths_to_remove.append(length)
 
                             elif isinstance(length, tuple):
 
-                                if (isinstance(length[0], Register) and
-                                        isinstance(length[1], Register)):
+                                if (isinstance(length[0], Register)
+                                        and isinstance(length[1], Register)):
 
                                     if lengths[length] > maxvalue:
                                         lengths_to_remove.append(length)
 
-                                elif (isinstance(length[0], Register) and
-                                      isinstance(length[1],
-                                                 six.integer_types)):
+                                elif (isinstance(length[0], Register)
+                                      and isinstance(length[1],
+                                                     six.integer_types)):
 
                                     if lengths[length] > maxvalue:
                                         # TODO: Assuming that min value is
                                         # the ceiling for lengths operands
                                         lengths[length] = maxvalue
 
                                 else:
@@ -966,15 +980,15 @@
         assert "reg_range" not in list(lengths.values()), lengths
         assert len(lengths) > 0
         for elem in lengths.values():
             assert isinstance(elem, six.integer_types), elem
 
         self._possible_lengths = lengths
 
-    def possible_lengths(self, context):
+    def possible_lengths(self, context: Context):
         """
 
         :param context:
 
         """
 
         # if self._possible_lengths_set is not None:
@@ -983,23 +997,23 @@
         self._compute_possible_lengths(context)
 
         if not self.variable_length:
             return self._possible_lengths
         else:
             return list(self._possible_lengths.values())
 
-    def possible_addresses(self, dummy_context):
+    def possible_addresses(self, dummy_context: Context):
         """
 
         :param dummy_context:
 
         """
         return self._possible_addresses
 
-    def set_possible_addresses(self, addreses, dummy_context):
+    def set_possible_addresses(self, addreses, dummy_context: Context):
         """Set the possible addresses for the memory operand.
 
         :param addreses:
         :param dummy_context:
 
         """
         assert self._possible_addresses is None
@@ -1018,41 +1032,41 @@
         assert self._alignment is None
         self._alignment = alignment
 
     def alignment(self):
         """Required alignment of the memory operand (::class:`~.int`)."""
         return self._alignment
 
-    def set_possible_lengths(self, lengths, dummy_context):
+    def set_possible_lengths(self, lengths, dummy_context: Context):
         """
 
         :param lengths:
         :param dummy_context:
 
         """
         assert self._possible_lengths_set is None
         self._possible_lengths_set = lengths
 
     def unset_possible_lengths(self):
         """Unset the possible lengths of the memory operand."""
         self._possible_lengths_set = None
 
     def set_forbidden_address_range(self, min_address, max_address,
-                                    dummy_context):
+                                    dummy_context: Context):
         """
 
         :param min_address:
         :param max_address:
         :param dummy_context:
 
         """
         self._forbidden_min = min_address
         self._forbidden_max = max_address
 
-    def set_length(self, length, context):
+    def set_length(self, length: int, context: Context):
         """
 
         :param length:
         :param context:
 
         """
 
@@ -1061,38 +1075,37 @@
 
         if self._unset_length_function is not None:
             self._unset_length_function()
 
         self._compute_possible_lengths(context)
 
         operand_values = [
-            key
-            for key in self._possible_lengths
+            key for key in self._possible_lengths
             if self._possible_lengths[key] == length
         ]
 
         LOG.debug("Operand value required: %s", operand_values)
 
         # free memory?
         self._possible_lengths = None
 
         operands = []
         for operand in self._length_values:
-            if isinstance(operand, (InstructionOperandValue,
-                                    OperandDescriptor)):
+            if isinstance(operand,
+                          (InstructionOperandValue, OperandDescriptor)):
                 operands.append(operand)
             elif isinstance(operand, tuple):
                 if operand[1] == "MASK":
                     operands.append(operand[0])
-                elif (isinstance(operand[1], InstructionOperandValue) and
-                      isinstance(operand[2], InstructionOperandValue)):
+                elif (isinstance(operand[1], InstructionOperandValue)
+                      and isinstance(operand[2], InstructionOperandValue)):
                     operands.append(operand[1])
                     operands.append(operand[2])
-                elif (operand[1] == "REGMAX" and
-                      isinstance(operand[2], InstructionOperandValue)):
+                elif (operand[1] == "REGMAX"
+                      and isinstance(operand[2], InstructionOperandValue)):
                     # operands.append(max(operand[2].type.values()))
                     operands.append(operand[2])
                 else:
                     raise NotImplementedError
             elif isinstance(operand, six.integer_types):
                 continue
             elif operand.startswith("*") and operand[1:].isdigit():
@@ -1121,16 +1134,16 @@
                                                 "requested length")
 
         LOG.debug("Operand to use: %s", operands)
 
         # TODO: Why this check?
         if isinstance(operand_values, tuple):
 
-            if (isinstance(operand_values[0], Register) and
-                    isinstance(operand_values[1], Register)):
+            if (isinstance(operand_values[0], Register)
+                    and isinstance(operand_values[1], Register)):
 
                 operand_values = [operand_values[0], operand_values[1]]
 
             else:
 
                 operand_values = [operand_values]
 
@@ -1160,16 +1173,16 @@
             elif isinstance(operand_value, tuple):
 
                 register = operand_value[0]
                 value = operand_value[1]
 
                 operand.set_value(register)
 
-                if (value is not None and
-                        context.get_register_value(register) != value):
+                if (value is not None
+                        and context.get_register_value(register) != value):
 
                     LOG.debug("Context: %s", context.dump())
                     LOG.debug("Register used: %s", register)
 
                     raise MicroprobeCodeGenerationError(
                         "Unable to generate the requested length. Need a "
                         "register initialized to value: %s" % value)
@@ -1186,24 +1199,24 @@
         self._check_forbidden_range()
 
         if self._set_length_function is not None:
             self._set_length_function(length, context)
 
         LOG.debug("End set length: %s", length)
 
-    def update_address(self, address):
+    def update_address(self, address: Address):
         """
 
         :param address:
         :param context:
 
         """
         self._address = address
 
-    def set_address(self, address, context):
+    def set_address(self, address: Address, context: Context):
         """
 
         :param address:
         :param context:
 
         """
 
@@ -1230,26 +1243,26 @@
 
             LOG.debug("Operand %d: '%s'", idx, operand)
 
             if operand.descriptor.type.address_base and base_operand is None:
                 LOG.debug("Base operand %d: %s", idx, operand)
                 base_operand = operand
 
-            if (operand.descriptor.type.address_index and
-                    index_operand_reg is None):
+            if (operand.descriptor.type.address_index
+                    and index_operand_reg is None):
                 LOG.debug("Index operand %d: %s", idx, operand)
                 index_operand_reg = operand
 
-            if (operand.descriptor.type.address_immediate and
-                    index_operand_imm is None):
+            if (operand.descriptor.type.address_immediate
+                    and index_operand_imm is None):
                 LOG.debug("Immediate operand %d: %s", idx, operand)
                 index_operand_imm = operand
 
-            if (operand.descriptor.type.address_relative and
-                    relative_operand is None):
+            if (operand.descriptor.type.address_relative
+                    and relative_operand is None):
                 LOG.debug("Relative operand %d: %s", idx, operand)
                 relative_operand = operand
 
         if relative_operand is not None:
 
             assert base_operand is None
             assert index_operand_imm is None
@@ -1264,22 +1277,20 @@
         if self.descriptor.is_agen and base_operand is None:
             raise MicroprobeCodeGenerationError(
                 "I do not know how to generate this address: %s" % address)
 
         if base_operand is None:
             raise MicroprobeCodeGenerationError(
                 "I do not know how to generate "
-                "this address: %s (no base operand)" % address
-            )
+                "this address: %s (no base operand)" % address)
 
         if not base_operand.descriptor.is_input:
             raise MicroprobeCodeGenerationError(
                 "I do not know how to generate "
-                "this address: %s (no base operand input)" % address
-            )
+                "this address: %s (no base operand input)" % address)
 
         fast_path = False
         if context.register_has_value(address):
             if context.registers_get_value(address)[0] in \
                     list(base_operand.type.values()):
                 fast_path = True
 
@@ -1297,25 +1308,24 @@
 
             if index_operand_reg is not None:
 
                 register_zero_list = []
                 if context.register_has_value(0):
 
                     register_zero_list = [
-                        reg for reg
-                        in context.registers_get_value(0)
+                        reg for reg in context.registers_get_value(0)
                         if reg in list(index_operand_reg.type.values())
                     ]
 
                 if len(register_zero_list) == 0:
                     raise MicroprobeCodeGenerationError(
                         "I do not know how to generate this address: %s. "
                         "One of the following registers should be set to zero:"
-                        " %s" % (address,
-                                 list(index_operand_reg.type.values())))
+                        " %s" %
+                        (address, list(index_operand_reg.type.values())))
 
                 index_operand_reg.set_value(register_zero_list[0])
 
             generated_address = address.copy()
 
         else:
 
@@ -1351,22 +1361,21 @@
 
             # get the closest address in the context
             closest_index = index - possible_base_regs[0][1].displacement
             closest_reg = possible_base_regs[0][0]
             closest_address = possible_base_regs[0][1]
 
             for reg, paddress in possible_base_regs[1:]:
-                if index - paddress.displacement > 0 and (abs(
-                        index - paddress.displacement) < abs(closest_index)):
-
-                    if ((index_operand_imm is None) and
-                            not context.register_has_value(
-                        index -
-                        paddress.displacement
-                    )):
+                if index - paddress.displacement > 0 and (
+                        abs(index - paddress.displacement)
+                        < abs(closest_index)):
+
+                    if ((index_operand_imm is None)
+                            and not context.register_has_value(
+                                index - paddress.displacement)):
                         continue
 
                     closest_index = index - paddress.displacement
                     closest_reg = reg
                     closest_address = paddress
 
             register_base = closest_reg
@@ -1380,76 +1389,78 @@
             LOG.debug("Closest index: '%s (0x%x)'", index, index)
 
         # TODO: some instructions only have base operands
         # if index_operand_reg is not None or index_operand_imm is not None:
         #    assert address == generated_address
 
         set_index = False
-        if (index_operand_imm is not None and not set_index and
-                generated_address != address):
+        if (index_operand_imm is not None and not set_index
+                and generated_address != address):
 
             LOG.debug("The instruction has immediate operand, and the "
                       "generated address still needs some extra displacement")
-            assert (index_operand_imm.descriptor.is_input and
-                    not index_operand_imm.descriptor.is_output)
+            assert (index_operand_imm.descriptor.is_input
+                    and not index_operand_imm.descriptor.is_output)
 
             try:
                 LOG.debug("Setting immediate displacement")
                 index_operand_imm.set_value(index)
                 set_index = True
                 generated_address += index
             except MicroprobeValueError:
                 LOG.debug("Unable to generate the address with the current "
                           "context")
                 raise MicroprobeCodeGenerationError(
                     "I do not know how to generate that address. Index "
                     "register not set.")
 
-        if (index_operand_reg is not None and not set_index and
-                generated_address != address):
+        if (index_operand_reg is not None and not set_index
+                and generated_address != address):
 
             LOG.debug("The instruction has index register operand, and the "
                       "generated address still needs some extra displacement")
-            assert (index_operand_reg.descriptor.is_input and
-                    not index_operand_reg.descriptor.is_output)
+            assert (index_operand_reg.descriptor.is_input
+                    and not index_operand_reg.descriptor.is_output)
 
             if not context.register_has_value(index):
                 LOG.debug("Unable to generate the address with the current "
                           "context")
                 raise MicroprobeCodeGenerationError(
                     "I do not know how to generate that address. Index "
                     "register not set. Change the generation policy.")
 
             registers_index = context.registers_get_value(index)
-            registers_index = [reg for reg in registers_index
-                               if reg in list(index_operand_reg.type.values())]
+            registers_index = [
+                reg for reg in registers_index
+                if reg in list(index_operand_reg.type.values())
+            ]
 
             if len(registers_index) == 0:
                 LOG.debug("Unable to generate the address with the current "
                           "context")
                 raise MicroprobeCodeGenerationError(
                     "I do not know how to generate that address. Index "
                     "register not set. Change the generation policy.")
 
             register_index = registers_index[0]
             index_operand_reg.set_value(register_index)
             set_index = True
             generated_address += index
             LOG.debug("Using register: %s", register_index.name)
 
-        if (index_operand_imm is not None and set_index and
-                generated_address == address and
-                index_operand_imm.value is None):
+        if (index_operand_imm is not None and set_index
+                and generated_address == address
+                and index_operand_imm.value is None):
 
             LOG.debug("Setting index immediate operand to zero")
             index_operand_imm.set_value(0)
 
-        if (index_operand_reg is not None and set_index and
-                generated_address == address and
-                index_operand_reg.value is None):
+        if (index_operand_reg is not None and set_index
+                and generated_address == address
+                and index_operand_reg.value is None):
 
             LOG.debug("Setting index register operand to zero")
             register_zero = context.registers_get_value(0)[0]
             index_operand_reg.set_value(register_zero)
 
         if address != generated_address:
             LOG.debug("Unable to generate the address. Raising exception.")
@@ -1493,17 +1504,16 @@
 
         for operand in self.operands:
             if operand.value is None:
                 # Unable to update anything if some operad does not have value
                 return
 
         # Only fixing relative operands.
-        if (len(self.operands) == 1 and
-                self.operands[0].type.address_relative and
-                isinstance(self.operands[0].value, InstructionAddress)):
+        if (len(self.operands) == 1 and self.operands[0].type.address_relative
+                and isinstance(self.operands[0].value, InstructionAddress)):
             self._address = self.operands[0].value
 
         if context is not None:
             # TODO: fix other types as well
             pass
 
     def _check_forbidden_range(self):
@@ -1513,16 +1523,16 @@
             return
 
         if self._length is None:
             return
 
         if self._forbidden_max is None and self._forbidden_min is None:
             return
-        elif (self._forbidden_max is not None and
-              self._forbidden_min is not None):
+        elif (self._forbidden_max is not None
+              and self._forbidden_min is not None):
 
             assert self._address > self._forbidden_max or \
                 (self._address + self._length) < self._forbidden_min
 
     def unset_forbidden_address_range(self):
         """Unset the forbiddend address range."""
         self._forbidden_min = None
@@ -1582,15 +1592,15 @@
         self._decorators = RejectingDict()
         self._dependency_distance = 0
         self._generic_type = None
         self._label = None
         self._mem_operands = []
         self._operands = RejectingOrderedDict()
 
-    def set_arch_type(self, instrtype):
+    def set_arch_type(self, instrtype: InstructionType):
         """
 
         :param instrtype:
 
         """
         self._arch_type = instrtype
         self._operands = RejectingOrderedDict()
@@ -1631,18 +1641,19 @@
 
                     assert isinstance(operand_value.type, OperandConstReg)
 
                     # TODO: memory operand is implicit
                     # force it to be address base (is this generic?)
                     # needed for POWERPC branches to CTR or LR
 
-                    operand_value.descriptor.set_type(OperandConstReg(
-                        operand_value.type.name, operand_value.type.
-                        description, list(operand_value.type.values())[
-                            0], True, False, False, False))
+                    operand_value.descriptor.set_type(
+                        OperandConstReg(operand_value.type.name,
+                                        operand_value.type.description,
+                                        list(operand_value.type.values())[0],
+                                        True, False, False, False))
                     operand_value.descriptor.set_type(operand_value.type)
 
                     operand_value.set_value(operand_value.type.values()[0])
 
                     operand_values.append(operand_value)
 
             length_values = []
@@ -1675,23 +1686,24 @@
 
                     if rsecond in self._operands:
                         length_value_b = self._operands[rsecond]
                     else:
                         raise NotImplementedError
 
                     # assert operand_type == length_value.type
-                    length_values.append((operand_type, length_value_a,
-                                          length_value_b))
+                    length_values.append(
+                        (operand_type, length_value_a, length_value_b))
 
                 else:
 
                     length_values.append(operand_type)
 
-            self._mem_operands.append(InstructionMemoryOperandValue(
-                mem_operand_descr, operand_values, length_values))
+            self._mem_operands.append(
+                InstructionMemoryOperandValue(mem_operand_descr,
+                                              operand_values, length_values))
 
         for value in instrtype.instruction_checks.values():
             function, args = value
             function(self, *args)
 
     def register_context_callback(self, key, checking_function,
                                   fixing_function):
@@ -1705,21 +1717,19 @@
 
         self._context_callback_check[key] = checking_function
         self._context_callback_fix[key] = fixing_function
 
     @property
     def context_callbacks(self):
         """Returns the list of context callbacks registered."""
-        return [
-            (key, self._context_callback_check[key],
-             self._context_callback_fix[key])
-            for key in self._context_callback_check.keys()
-        ]
+        return [(key, self._context_callback_check[key],
+                 self._context_callback_fix[key])
+                for key in self._context_callback_check.keys()]
 
-    def check_context(self, context):
+    def check_context(self, context: Context):
         """
 
         :param context:
 
         """
 
         fixing_callbacks = []
@@ -1761,17 +1771,16 @@
         :rtype: :class:`~.Instruction`
         """
         new_instruction = Instruction()
         new_instruction.set_arch_type(self.architecture_type)
         for callback in self.context_callbacks:
             new_instruction.register_context_callback(*callback)
 
-        new_instruction.set_operands(
-            [op.value for op in self.operands()], check=False
-        )
+        new_instruction.set_operands([op.value for op in self.operands()],
+                                     check=False)
 
         for reg in self.allowed_regs:
             new_instruction.add_allow_register(reg)
 
         for comment in self.comments:
             new_instruction.add_comment(comment)
 
@@ -1804,17 +1813,15 @@
                     "Looking for field name with multiple options. "
                     "Check the definition of instruction type "
                     "'%s'" % self._arch_type)
 
             return self._operands[fieldname]
         except (KeyError, IndexError):
             raise MicroprobeLookupError(
-                "'%s' not in %s" %
-                (fieldname, list(
-                    self._operands.keys())))
+                "'%s' not in %s" % (fieldname, list(self._operands.keys())))
 
     def operand_fields(self):
         """Instruction field names of the operands.
 
         :rtype: list of  :class:`~.str`
         """
         assert self._arch_type is not None
@@ -1945,15 +1952,15 @@
         return reg in self._allowed_regs
 
     @property
     def allowed_regs(self):
         """List of allowed registers of the instructon. """
         return self._allowed_regs
 
-    def set_label(self, label):
+    def set_label(self, label: str):
         """
 
         :param label:
 
         """
 
         if label == "":
@@ -2002,15 +2009,15 @@
         return self._arch_type.binary(list(self._operands.values()))
 
     @property
     def address(self):
         """Instruction address (:class:`~.InstructionAddress`)"""
         return self._address
 
-    def set_address(self, address):
+    def set_address(self, address: Address):
         """
 
         :param address:
 
         """
         self._address = address
 
@@ -2063,39 +2070,36 @@
             memoperand._unset_address_function = None
             memoperand._set_length_function = None
             memoperand._unset_length_function = None
 
         return state
 
 
-def create_dependency_between_ins(output_ins, input_ins, context):
+def create_dependency_between_ins(output_ins: Instruction,
+                                  input_ins: Instruction, context: Context):
     """
 
     :param output_ins:
     :param input_ins:
     :param context:
 
     """
 
     reserved_registers = set(context.reserved_registers)
 
     output_operands = [
-        operand
-        for operand in output_ins.operands()
-        if operand.is_output and not operand.type.immediate and
-        not operand.type.address_relative and not operand.type.address_base and
-        not operand.type.address_index
+        operand for operand in output_ins.operands() if operand.is_output
+        and not operand.type.immediate and not operand.type.address_relative
+        and not operand.type.address_base and not operand.type.address_index
     ]
 
     input_operands = [
-        operand
-        for operand in input_ins.operands()
-        if operand.is_input and not operand.type.immediate and
-        not operand.type.address_relative and not operand.type.address_base and
-        not operand.type.address_index
+        operand for operand in input_ins.operands() if operand.is_input
+        and not operand.type.immediate and not operand.type.address_relative
+        and not operand.type.address_base and not operand.type.address_index
     ]
 
     # prioritize the operands that are only inputs or only outputs
 
     output_operands = [operand for operand in output_operands
                        if not operand.is_input] + \
                       [operand for operand in output_operands
@@ -2143,16 +2147,16 @@
             break
 
     return dependency_set
 
 
 class MicroprobeInstructionDefinition(object):
 
-    def __init__(self, instruction_type, operands, label, address, asm,
-                 decorators, comments):
+    def __init__(self, instruction_type: InstructionType, operands, label,
+                 address: Address, asm, decorators, comments):
 
         self._type = instruction_type
         self._operands = operands
         self._label = label
         self._address = address
         self._asm = asm
         self._decorators = decorators
```

## microprobe/code/var.py

```diff
@@ -12,34 +12,35 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.code.var` module
 
 """
 
 # Futures
-from __future__ import absolute_import, print_function
+from __future__ import absolute_import, print_function, annotations
 
 # Built-in modules
 import abc
 import hashlib
 import math
-
-# Third party modules
-import six
+from typing import TYPE_CHECKING, Dict, List
 
 # Own modules
 from microprobe.exceptions import MicroprobeCodeGenerationError
 from microprobe.utils.logger import get_logger
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.code.address import Address
 
 # Constants
 __all__ = ["Variable", "VariableSingle", "VariableArray"]
 LOG = get_logger(__name__)
 
-VAR_TYPE_LEN_DICT = {}
+VAR_TYPE_LEN_DICT: Dict[str, int] = {}
 VAR_TYPE_LEN_DICT["char"] = 1
 VAR_TYPE_LEN_DICT["signed char"] = 1
 VAR_TYPE_LEN_DICT["unsigned char"] = 1
 VAR_TYPE_LEN_DICT["short"] = 2
 VAR_TYPE_LEN_DICT["short int"] = 2
 VAR_TYPE_LEN_DICT["signed short"] = 2
 VAR_TYPE_LEN_DICT["signed short int"] = 2
@@ -88,136 +89,140 @@
 VAR_TYPE_LEN_DICT["uint_least64_t"] = 8
 VAR_TYPE_LEN_DICT["uint_fast64_t"] = 8
 
 # Functions
 
 
 # Classes
-class Variable(six.with_metaclass(abc.ABCMeta, object)):
+class Variable(abc.ABC):
     """ """
 
-    _cmp_attributes = []
+    _cmp_attributes: List[str] = []
 
     def __init__(self):
         """ """
         self._address = None
         self._hash = None
 
-    @abc.abstractproperty
-    def type(self):
+    @property
+    @abc.abstractmethod
+    def type(self) -> str:
         """Variable type (:class:`~.str`)."""
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def name(self):
+    @property
+    @abc.abstractmethod
+    def name(self) -> str:
         """Variable name (:class:`~.str`)."""
         raise NotImplementedError
 
-    @abc.abstractmethod
-    def array(self):
+    def array(self) -> bool:
         """Return if the variable is an array.
 
         :rtype: :class:`~.bool`
         """
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def size(self):
+    @property
+    @abc.abstractmethod
+    def size(self) -> int:
         """Variable size in bytes (::class:`~.int`)."""
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def value(self):
         """Variable value."""
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def align(self):
+    @property
+    @abc.abstractmethod
+    def align(self) -> int | None:
         """Variable alignment (:class:`~.int`)."""
         raise NotImplementedError
 
-    def set_address(self, address):
+    def set_address(self, address: Address):
         """Set variable address.
 
         :param address: Address of the variable.
         """
         self._address = address
 
     @property
     def address(self):
         """Variable address (:class:`~.Address`)."""
         return self._address
 
-    @abc.abstractproperty
-    def __str__(self):
+    @abc.abstractmethod
+    def __str__(self) -> str:
         """ """
         raise NotImplementedError
 
-    def __eq__(self, other):
+    def __eq__(self, other: object):
         """x.__eq__(y) <==> x==y"""
 
         if not isinstance(other, self.__class__):
             return False
 
         for attr in self._cmp_attributes:
             if not getattr(self, attr) == getattr(other, attr):
                 return False
         return True
 
-    def __ne__(self, other):
+    def __ne__(self, other: object):
         """x.__ne__(y) <==> x!=y"""
 
         if not isinstance(other, self.__class__):
             return False
 
         for attr in self._cmp_attributes:
             if not getattr(self, attr) == getattr(other, attr):
                 return True
         return False
 
-    def __lt__(self, other):
+    def __lt__(self, other: object):
         """x.__lt__(y) <==> x<y"""
 
         if not isinstance(other, self.__class__):
             return False
 
         for attr in self._cmp_attributes:
             if getattr(self, attr) < getattr(other, attr):
                 return True
             elif getattr(self, attr) > getattr(other, attr):
                 return False
         return False
 
-    def __gt__(self, other):
+    def __gt__(self, other: object):
         """x.__gt__(y) <==> x>y"""
 
         if not isinstance(other, self.__class__):
             return False
 
         for attr in self._cmp_attributes:
             if getattr(self, attr) > getattr(other, attr):
                 return True
             elif getattr(self, attr) < getattr(other, attr):
                 return False
         return False
 
-    def __le__(self, other):
+    def __le__(self, other: object):
         """x.__le__(y) <==> x<=y"""
 
         if not isinstance(other, self.__class__):
             return False
 
         for attr in self._cmp_attributes:
             if getattr(self, attr) <= getattr(other, attr):
                 continue
             else:
                 return False
         return True
 
-    def __ge__(self, other):
+    def __ge__(self, other: object):
         """x.__ge__(y) <==> x>=y"""
 
         if not isinstance(other, self.__class__):
             return False
 
         for attr in self._cmp_attributes:
             if getattr(self, attr) >= getattr(other, attr):
@@ -226,25 +231,29 @@
                 return False
         return True
 
     def __hash__(self):
         """ """
         if self._hash is None:
             self._hash = int(
-                hashlib.sha512(str(self).encode()).hexdigest(), 16
-            )
+                hashlib.sha512(str(self).encode()).hexdigest(), 16)
         return self._hash
 
 
 class VariableSingle(Variable):
     """ """
 
     _cmp_attributes = ["name", "type", "size"]
 
-    def __init__(self, name, vartype, align=1, value=None, address=None):
+    def __init__(self,
+                 name: str,
+                 vartype: str,
+                 align: int = 1,
+                 value=None,
+                 address: Address | None = None):
         """
 
         :param name:
         :param vartype:
         :param align:  (Default value = 16)
         :param value:  (Default value = None)
 
@@ -319,20 +328,20 @@
 
 class VariableArray(Variable):
     """ """
 
     _cmp_attributes = ["name", "type", "size"]
 
     def __init__(self,
-                 name,
-                 vartype,
-                 size,
-                 align=None,
+                 name: str,
+                 vartype: str,
+                 size: int,
+                 align: int | None = None,
                  value=None,
-                 address=None):
+                 address: Address | None = None):
         """
 
         :param name:
         :param vartype:
         :param size:
         :param align:  (Default value = 16)
         :param value:  (Default value = None)
```

## microprobe/code/wrapper.py

```diff
@@ -11,157 +11,167 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """
 This is the wrapper module documentation
 """
 # Futures
-from __future__ import absolute_import
+from __future__ import absolute_import, annotations
 
 # Built-in modules
 import abc
-
-# Third party modules
-import six
+from typing import TYPE_CHECKING, Callable, List
 
 # Own modules
 from microprobe.code.context import Context
 from microprobe.exceptions import MicroprobeCodeGenerationError
 from microprobe.utils.logger import get_logger
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.code.benchmark import Benchmark
+    from microprobe.code.ins import Instruction
+    from microprobe.code.var import Variable
+    from microprobe.target import Target
+    from microprobe.target.isa.register import Register
 
 # Constants
 LOG = get_logger(__name__)
 __all__ = ["Wrapper"]
 
 # Functions
 
 
 # Classes
-class Wrapper(six.with_metaclass(abc.ABCMeta, object)):
+class Wrapper(abc.ABC):
     """
     Abstract class to represent a language wrapper.
     """
 
     @abc.abstractmethod
     def __init__(self):
         """Initialization abstract method."""
         self._bench = None
         self._target = None
         self._context = Context()
         self._reset_state = False
         self._direct_init_dict = None
 
     @abc.abstractmethod
-    def outputname(self, name):
+    def outputname(self, name: str) -> str:
         """
 
         :param name:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def headers(self):
+    def headers(self) -> str:
         """ """
         raise NotImplementedError
 
     # @abc.abstractmethod
     # def declare_option(self, option_flag, var,):
     #    raise NotImplementedError
 
     @abc.abstractmethod
-    def declare_global_var(self, var):
+    def declare_global_var(self, var: Variable) -> str:
         """
 
         :param var:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def init_global_var(self, var, value):
+    def init_global_var(self, var: Variable,
+                        value: int | str | Callable[[], int | str]) -> str:
         """
 
         :param var:
         :param value:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def required_global_vars(self):
+    def required_global_vars(self) -> List[Variable]:
         """ """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def start_main(self):
+    def start_main(self) -> str:
         """ """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def post_var(self):
+    def post_var(self) -> str:
         """ """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def start_loop(self, instr, instr_reset, aligned=True):
+    def start_loop(self,
+                   instr: Instruction,
+                   instr_reset: Instruction,
+                   aligned: bool = True) -> str:
         """
 
         :param instr:
         :param instr_reset:
         :param aligned:  (Default value = True)
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def wrap_ins(self, instr):
+    def wrap_ins(self, instr: Instruction) -> str:
         """
 
         :param instr:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def end_loop(self, instr):
+    def end_loop(self, instr: Instruction) -> str:
         """
 
         :param instr:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def end_main(self):
+    def end_main(self) -> str:
         """ """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def footer(self):
+    def footer(self) -> str:
         """ """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def infinite(self):
+    def infinite(self) -> bool:
         """Returns a :class:`~.bool` indicating if the loop is infinite. """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def reserved_registers(self, registers, target):
+    def reserved_registers(self, registers: List[Register],
+                           target: Target) -> List[Register]:
         """
 
         :param registers:
         :param target:
 
         """
         raise NotImplementedError
 
-    def set_benchmark(self, bench):
+    def set_benchmark(self, bench: Benchmark):
         """
 
         :param bench:
 
         """
         self._bench = bench
 
@@ -171,15 +181,15 @@
         return self._bench
 
     @property
     def reset(self):
         """ """
         return self._reset_state
 
-    def set_target(self, target):
+    def set_target(self, target: Target):
         """
 
         :param target:
 
         """
         self._target = target
 
@@ -213,38 +223,34 @@
 
     def register_direct_init(self, dummy_key, dummy_value):
         """ Initialize *key* with the value *value* """
         if self.direct_initialization_support:
             raise NotImplementedError
         else:
             raise MicroprobeCodeGenerationError(
-                "Direct intialization function called but not supported"
-            )
+                "Direct intialization function called but not supported")
 
     def get_direct_init(self, key, defaultvalue):
         """ Get the *value* for *key* """
         if self.direct_initialization_support:
 
             if isinstance(key, str):
                 keys = self.target.registers.values()
                 keys = [lkey for lkey in keys if lkey.name == key]
                 if len(keys) != 1:
                     raise MicroprobeCodeGenerationError(
                         "Unable to find the direct initialization value"
-                        " name: %s" % key
-                    )
+                        " name: %s" % key)
                 key = keys[0]
 
             if key in self._direct_init_dict:
                 return self._direct_init_dict[key]
 
             if defaultvalue is not None:
                 return defaultvalue
 
             raise MicroprobeCodeGenerationError(
-                "Unable to find the direct initialization value"
-            )
+                "Unable to find the direct initialization value")
 
         else:
             raise MicroprobeCodeGenerationError(
-                "Direct intialization function called but not supported"
-            )
+                "Direct intialization function called but not supported")
```

## microprobe/passes/ilp/__init__.py

```diff
@@ -12,34 +12,35 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.passes.ilp` module
 
 """
 
 # Futures
-from __future__ import absolute_import, print_function
+from __future__ import absolute_import, print_function, annotations
 
 # Built-in modules
-import itertools
-import random
-import re
+from typing import TYPE_CHECKING
 
 # Third party modules
 
 # Own modules
 import microprobe.passes
 import microprobe.utils.distrib
 from microprobe.code.address import Address, MemoryValue
 from microprobe.exceptions import MicroprobeCodeGenerationError, \
     MicroprobeValueError
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import OrderedDict
 
 # Local modules
 
+# Type hinting
+if TYPE_CHECKING:
+    import random
 
 # Constants
 LOG = get_logger(__name__)
 __all__ = [
     'ConstantDependencyDistancePass',
     'AverageDependencyDistancePass',
     'RandomDependencyDistancePass',
@@ -108,23 +109,23 @@
 
 
 class RandomDependencyDistancePass(microprobe.passes.Pass):
     """RandomDependencyDistancePass pass.
 
     """
 
-    def __init__(self, maxdep):
+    def __init__(self, maxdep: int, rand: random.Random):
         """
 
         :param maxdep:
 
         """
         super(RandomDependencyDistancePass, self).__init__()
         self._max = maxdep
-        self._func = random.randint
+        self._func = rand.randint
 
     def __call__(self, building_block, dummy_target):
         """
 
         :param building_block:
         :param dummy_target:
```

## microprobe/passes/instruction/__init__.py

```diff
@@ -12,22 +12,22 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.passes.instruction` module
 
 """
 
 # Futures
-from __future__ import absolute_import, division, print_function
+from __future__ import absolute_import, division, print_function, annotations
 
 # Built-in modules
 import copy
 import itertools
 import multiprocessing as mp
-import random
 import pickle
+from typing import TYPE_CHECKING, List
 
 # Third party modules
 from six.moves import range
 from six.moves import zip
 
 # Own modules
 import microprobe.code.ins
@@ -45,16 +45,18 @@
 from microprobe.utils.cmdline import print_info
 from microprobe.utils.distrib import generate_weighted_profile, \
     weighted_choice
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import RejectingDict, closest_divisor, \
     Progress, iter_flatten, getnextf
 
-# Local modules
-
+# Type hinting
+if TYPE_CHECKING:
+    import random
+    from microprobe.code.ins import Instruction
 
 # Constants
 LOG = get_logger(__name__)
 __all__ = [
     'SetInstructionTypePass',
     'ReplaceInstructionByTypePass',
     'SetInstructionTypeByProfilePass',
@@ -351,25 +353,23 @@
 
 
 class SetRandomInstructionTypePass(microprobe.passes.Pass):
     """SetRandomInstructionTypePass pass.
 
     """
 
-    def __init__(self, instructions):
+    def __init__(self, instructions: List[Instruction], rand: random.Random):
         """
 
         :param instructions:
 
         """
         super(SetRandomInstructionTypePass, self).__init__()
         self._instrs = instructions
-        myrandom = random.Random()
-        myrandom.seed(10)
-        self._func = myrandom.choice
+        self._func = rand.choice
 
     def __call__(self, building_block, target):
         """
 
         :param building_block:
         :param target:
```

## microprobe/target/__init__.py

```diff
@@ -29,53 +29,57 @@
 - :class:`~.Target` objects are in charge of providing a generic API to query
   all kind of target properties. This is the main object that is used by other
   modules and packages of microprobe to query target information (e.g.
   instructions, registers, functional units, etc.).
 """
 
 # Futures
-from __future__ import absolute_import
+from __future__ import absolute_import, annotations
 
 # Built-in modules
-import collections
 import copy
 import itertools
 import os
+from typing import TYPE_CHECKING, Tuple
 
 # Third party modules
 
 # Own modules
-from microprobe import MICROPROBE_RC
-from microprobe.exceptions import MicroprobeDuplicatedValueError, \
-    MicroprobeError, MicroprobeImportDefinitionError, \
-    MicroprobePolicyError, MicroprobeTargetDefinitionError
+from microprobe.exceptions import MicroprobeError, \
+    MicroprobeTargetDefinitionError
 from microprobe.target.env import GenericEnvironment, \
     find_env_definitions, import_env_definition
 from microprobe.target.isa import find_isa_definitions, import_isa_definition
 from microprobe.target.uarch import find_microarchitecture_definitions, \
     import_microarchitecture_definition
-from microprobe.utils.imp import get_attr_from_module, get_dict_from_module
 from microprobe.utils.logger import get_logger
-from microprobe.utils.misc import Pickable, RejectingDict, findfiles
+from microprobe.utils.misc import Pickable
 
 # Local modules
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.target.env import Environment
+    from microprobe.target.isa import ISA
+    from microprobe.target.uarch import Microarchitecture
+    from microprobe.code.wrapper import Wrapper
 
 # Constants
 LOG = get_logger(__name__)
 __all__ = [
     "import_definition",
     # "import_policies",
     "Target",
     "Definition"
 ]
 
 
 # Functions
-def import_definition(definition_tuple):
+def import_definition(definition_tuple: str
+                      | Tuple[Definition, Definition, Definition]):
     """Return the target corresponding the to the given *definition_tuple*.
 
     Return the target object corresponding the to the given
     *definition_tuple*. The *definition_tuple* is a string of the form
     ``<architecture_name>-<uarch_name>-<environment_name>`` that defines the
     target. This function uses the search paths provided in the configuration
     to look for the definitions to import.
@@ -90,32 +94,28 @@
     LOG.debug("Start importing definition tuple")
 
     if isinstance(definition_tuple, str):
         definition_tuple = _parse_definition_tuple(definition_tuple)
 
     isa_def, uarch_def, env_def = definition_tuple
     isa = import_isa_definition(os.path.dirname(isa_def.filename))
-    env = import_env_definition(
-        env_def.filename, isa,
-        definition_name=env_def.name
-    )
+    env = import_env_definition(env_def.filename,
+                                isa,
+                                definition_name=env_def.name)
     uarch = import_microarchitecture_definition(
-        os.path.dirname(uarch_def.filename)
-    )
+        os.path.dirname(uarch_def.filename))
 
     target = Target(isa, uarch=uarch, env=env)
-    LOG.info(
-        "Target '%s-%s-%s' imported", isa_def.name, uarch_def.name,
-        env_def.name
-    )
+    LOG.info("Target '%s-%s-%s' imported", isa_def.name, uarch_def.name,
+             env_def.name)
     LOG.debug("End importing definition tuple")
     return target
 
 
-def _parse_definition_tuple(definition_tuple):
+def _parse_definition_tuple(definition_tuple: str):
     """Return the target definitions corresponding to the *definition_tuple*.
 
     Return the target definitions corresponding to the *definition_tuple*.
     Check the *definition_tuple* format, and for each element (architecture,
     microarchitecture and environment) looks for the if there is a definition
     present in the current defined definition paths. It returns a tuple with
     the three corresponding definitions.
@@ -129,53 +129,49 @@
         specified is not found
     """
 
     try:
         isa_def, architecture_def, env_def = definition_tuple.split("-")
     except ValueError:
         raise MicroprobeTargetDefinitionError(
-            "Invalid format of '%s' target tuple" % definition_tuple
-        )
+            "Invalid format of '%s' target tuple" % definition_tuple)
 
     definitions = find_isa_definitions()
     if isa_def not in [definition.name for definition in definitions]:
-        raise MicroprobeTargetDefinitionError(
-            "ISA '%s' not available" % isa_def
-        )
+        raise MicroprobeTargetDefinitionError("ISA '%s' not available" %
+                                              isa_def)
     else:
         isa_def = [
-            definition
-            for definition in definitions if definition.name == isa_def
+            definition for definition in definitions
+            if definition.name == isa_def
         ][-1]
 
     definitions = find_microarchitecture_definitions()
     if architecture_def not in [definition.name for definition in definitions]:
         raise MicroprobeTargetDefinitionError(
-            "Microarchitecture '%s' not available" % architecture_def
-        )
+            "Microarchitecture '%s' not available" % architecture_def)
     else:
         architecture_def = [
-            definition
-            for definition in definitions
+            definition for definition in definitions
             if definition.name == architecture_def
         ][-1]
 
     definitions = find_env_definitions()
     if env_def not in [definition.name for definition in definitions]:
         raise MicroprobeTargetDefinitionError(
-            "Environment '%s' not available. " % env_def
-        )
+            "Environment '%s' not available. " % env_def)
     else:
         env_def = [
-            definition
-            for definition in definitions if definition.name == env_def
+            definition for definition in definitions
+            if definition.name == env_def
         ][-1]
 
     return (isa_def, architecture_def, env_def)
 
+
 # def import_policies(target_name):
 #    """Return the dictionary of policies for the *target_name*."""
 #
 #    paths = MICROPROBE_RC["default_paths"]
 #    policies = RejectingDict()
 #
 #    for policy_file in findfiles(paths, "^.*.py$"):
@@ -207,33 +203,32 @@
 #                "Policy '%s' in '%s' is duplicated" % (name, policy_file)
 #            )
 #
 #    return policies
 
 
 # Classes
-class Definition(object):
+class Definition:
     """Class to represent a target element definition.
 
     A target element definition could be the definition of the architecture,
     the microarchitecture or the environment. In all three cases a definition
     is composed by the definition name, the filename (where in the file system
     the definition is located) and the description.
     """
 
     # Class constant used for nice string formmating
     _field1 = 18
     _field2 = 25
     _field3 = 78 - _field1 - _field2
     _fmt_str_ = "Name:'%%%ds', Description:'%%%ds', File:'%%%ds'" % (
-        _field1, _field2, _field3
-    )
+        _field1, _field2, _field3)
     _cmp_attributes = ["name", "description", "filename"]
 
-    def __init__(self, filename, name, description):
+    def __init__(self, filename: str, name: str, description: str):
         """Create a Definition object.
 
         :param filename: Filename where the definition is placed
         :type filename: :class:`~.str`
         :param name: Name of the definition
         :type name: :class:`~.str`
         :param description: Description of the definition
@@ -262,19 +257,16 @@
 
     def __str__(self):
         """x.__str__() <==> str(x)."""
         return self._fmt_str_ % (self._name, self._description, self._file)
 
     def _check_cmp(self, other):
         if not isinstance(other, self.__class__):
-            raise NotImplementedError(
-                "%s != %s" % (
-                    other.__class__, self.__class__
-                )
-            )
+            raise NotImplementedError("%s != %s" %
+                                      (other.__class__, self.__class__))
 
     def __eq__(self, other):
         """x.__eq__(y) <==> x==y"""
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if not getattr(self, attr) == getattr(other, attr):
                 return False
@@ -338,48 +330,45 @@
     architecture/microarchitecture/environment specific methods using a
     facade software design pattern.
     Therefore, all the references to target related properties should go
     through this object interface in order to minimize the coupling with the
     other modules (code generation, design space exploration, ...).
     """
 
-    def __init__(self, isa, env=None, uarch=None):
+    def __init__(self,
+                 isa: ISA,
+                 env: Environment | None = None,
+                 uarch: Microarchitecture | None = None):
         """Create a Target object.
 
         :param isa: Architecture (i.e. Instruction Set Architecture)
         :type isa: :class:`~.ISA`
         :param env: Environment (default: None)
         :type env: :class:`~.Environment`
         :param uarch: Microarchitecture (default: None)
         :type uarch: :class:`~.Microarchitecture`
         :return: Target instance
         :rtype: :class:`~.Target`
         """
-        self._isa = None
         self._uarch = None
         self._env = None
         self._policies = None
         self._wrapper = None
 
         self.set_isa(isa)
 
         if uarch is not None:
             self.set_uarch(uarch)
-            self.microarchitecture.add_properties_to_isa(
-                self.isa.instructions
-            )
+            self.microarchitecture.add_properties_to_isa(self.isa.instructions)
 
         if env is not None:
             self.set_env(env)
         else:
             self.set_env(
-                GenericEnvironment(
-                    "Default", "Empty environment", self.isa
-                )
-            )
+                GenericEnvironment("Default", "Empty environment", self.isa))
 
     @property
     def name(self):
         """Name of the Target (:class:`~.str`)."""
         name = self._isa.name
         if self._uarch is not None:
             name += "-" + self._uarch.name
@@ -390,28 +379,24 @@
     @property
     def description(self):
         """Description of the Target (:class:`~.str`)."""
         description = []
         description.append("Target ISA: %s" % self.isa.name)
         description.append("ISA Description: %s" % self.isa.description)
         if self.microarchitecture is not None:
-            description.append(
-                "Target Micro-architecture: %s" % self.microarchitecture.name
-            )
-            description.append(
-                "Micro-architecture Description: %s" %
-                self.microarchitecture.description
-            )
+            description.append("Target Micro-architecture: %s" %
+                               self.microarchitecture.name)
+            description.append("Micro-architecture Description: %s" %
+                               self.microarchitecture.description)
         else:
             description.append("Target Micro-architecture: Not defined")
             description.append("Micro-architecture Description: Not defined")
         description.append("Target Environment: %s" % self.environment.name)
-        description.append(
-            "Environment description: %s" % self.environment.description
-        )
+        description.append("Environment description: %s" %
+                           self.environment.description)
         return "\n".join(description)
 
     @property
     def environment(self):
         """Environment of the Target (:class:`~.Environment`)."""
         return self._env
 
@@ -466,16 +451,15 @@
 
         for instr in self.isa.instructions.values():
 
             try:
                 value = getattr(instr, prop_name)
             except AttributeError:
                 raise MicroprobeTargetDefinitionError(
-                    "Property '%s' for instruction not found" % prop_name
-                )
+                    "Property '%s' for instruction not found" % prop_name)
 
             if not isinstance(value, list):
                 values = [value]
             else:
                 values = value
 
             for value in values:
@@ -486,50 +470,51 @@
                 prop_map[value].append(instr)
 
         for key in prop_map.keys():
             prop_map[key] = set(prop_map[key])
 
         return prop_map
 
-    def set_env(self, env):
+    def set_env(self, env: Environment):
         """Set the environment of the Target.
 
         :param env: Execution environment definition
         :type env: :class:`~.Environment`
         """
         self._env = copy.deepcopy(env)
         self._env.set_target(self)
 
-    def set_isa(self, isa):
+    def set_isa(self, isa: ISA):
         """Set the ISA of the Target.
 
         :param isa: Architecture (i.e. ISA)
         :type isa: :class:`~.ISA`
         """
         self._isa = copy.deepcopy(isa)
         self._isa.set_target(self)
 
-    def set_uarch(self, uarch):
+    def set_uarch(self, uarch: Microarchitecture):
         """Set the microarchitecture of the Target.
 
         :param uarch: Microarchitecture
         :type uarch: :class:`~.Microarchitecture`
         """
         self._uarch = uarch
         self._uarch.set_target(self)
 
     # TODO: remove this interface once the code generation back-end is fixed
-    def set_wrapper(self, wrapper):
+    def set_wrapper(self, wrapper: Wrapper):
         """Set the wrapper of the Target.
 
         :param wrapper: Wrapper
         :type wrapper: :class:`~.Wrapper`
         """
         self._wrapper = wrapper
 
+    # TODO: Remove facade pattern to allow type hints to propagate
     def __getattr__(self, name):
         """Facade design pattern implementation.
 
         This is where we implement the facade design pattern. Whenever an
         attribute is not defined by the Target object itself, it is searched
         if it is defined by one of the three elements composing the target.
 
@@ -568,11 +553,9 @@
             return attrs[0]
         elif len(attrs) > 1:
             if all([isinstance(attr, list) for attr in attrs]):
                 return list(itertools.chain.from_iterable(attrs))
             else:
                 raise MicroprobeError("Attribute defined in multiple objects")
         else:
-            raise AttributeError(
-                "'%s' object has no attribute '%s'" %
-                (self.__class__.__name__, name)
-            )
+            raise AttributeError("'%s' object has no attribute '%s'" %
+                                 (self.__class__.__name__, name))
```

## microprobe/target/env/__init__.py

```diff
@@ -12,96 +12,98 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.target.env` package
 
 """
 
 # Futures
-from __future__ import absolute_import
+from __future__ import absolute_import, annotations
 
 # Built-in modules
 import abc
+from typing import TYPE_CHECKING, List
 
 # Third party modules
+import six
 
 # Own modules
 from microprobe import MICROPROBE_RC
 from microprobe.code.address import Address
 from microprobe.code.context import Context
 from microprobe.code.var import VariableArray
 from microprobe.exceptions import MicroprobeImportDefinitionError, \
     MicroprobeValueError
 from microprobe.property import Property, PropertyHolder
 from microprobe.utils.imp import find_subclasses
 from microprobe.utils.logger import get_logger
-from microprobe.utils.misc import RejectingOrderedDict, findfiles
-import six
+from microprobe.utils.misc import findfiles
 
 # Local modules
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.target.isa import ISA
+    from microprobe.code.ins import Instruction
+    from microprobe.target import Target
+    from microprobe.target.isa.register import Register
 
 # Constants
 LOG = get_logger(__name__)
 
 _INIT = True
 _ENV_DEFINITIONS = None
 __all__ = [
     "import_env_definition", "find_env_definitions", "Environment",
     "GenericEnvironment"
 ]
 
 
 # Functions
-def import_env_definition(module, isa, definition_name=None):
+def import_env_definition(module,
+                          isa: ISA,
+                          definition_name: str | None = None):
     """
 
     :param module:
     :param isa:
     :param definition_name:  (Default value = None)
 
     """
 
     LOG.info("Start Environment import")
     envcls = list(
-        find_subclasses(
-            module,
-            GenericEnvironment,
-            extra_import_name=definition_name
-        )
-    )
+        find_subclasses(module,
+                        GenericEnvironment,
+                        extra_import_name=definition_name))
 
     LOG.debug("Definition name: %s", definition_name)
     LOG.debug("Classes: %s", envcls)
 
     if definition_name is not None:
         envcls = [cls for cls in envcls if cls.__name__ == definition_name]
 
     if len(envcls) > 1 and definition_name is None:
-        LOG.warning(
-            "Multiple environment definitions found and a specific"
-            " name not provided. Taking the first one."
-        )
+        LOG.warning("Multiple environment definitions found and a specific"
+                    " name not provided. Taking the first one.")
     elif len(envcls) < 1 and definition_name is None:
         raise MicroprobeImportDefinitionError(
-            "No environment definitions found in '%s'" % module
-        )
+            "No environment definitions found in '%s'" % module)
 
     elif len(envcls) < 1:
         raise MicroprobeImportDefinitionError(
             "No environment definitions found in '%s' with name"
-            " '%s'" % (module, definition_name)
-        )
+            " '%s'" % (module, definition_name))
 
     environment = envcls[0](isa)
 
     LOG.info("Environment '%s' imported", environment)
     return environment
 
 
-def find_env_definitions(paths=None):
+def find_env_definitions(paths: List[str] | None = None):
 
     LOG.debug("Start find environment definitions")
 
     global _INIT  # pylint: disable=global-statement
     global _ENV_DEFINITIONS  # pylint: disable=global-statement
 
     if not _INIT:
@@ -111,15 +113,15 @@
 
     if paths is None:
         paths = []
 
     paths = paths + MICROPROBE_RC["environment_paths"] \
         + MICROPROBE_RC["default_paths"]
 
-    results = []
+    results: List[Definition] = []
     files = findfiles(paths, "env/.*.py$", full=True)
 
     if len(files) > 0:
         from microprobe.target import Definition
         LOG.debug("Files found")
 
     for modfile in files:
@@ -150,319 +152,292 @@
 
 # Classes
 class Environment(six.with_metaclass(abc.ABCMeta, PropertyHolder)):
     """ """
 
     @abc.abstractmethod
     def __init__(self):
-        """ """
         pass
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def name(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def description(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def isa(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def environment_reserved_registers(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def threads(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def set_threads(self, num_threads):
         """
 
         :param num_threads:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
     def __str__(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def register_name(self, register):
         """
 
         :param register:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
     def full_report(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def default_wrapper(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def stack_pointer(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def stack_direction(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def elf_abi(self, stack_size, start_symbol):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def function_call(self, target, return_address_reg=None, long_jump=False):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def function_return(self, return_address_reg=None):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def volatile_registers(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def little_endian(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def set_target(self, target):
         """
 
         :param target:
 
         """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def target(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def hook_before_test_instructions(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def hook_after_test_instructions(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def hook_test_init_instructions(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def hook_after_reset_instructions(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def hook_test_end_instructions(self):
-        """ """
         raise NotImplementedError
 
 
 class GenericEnvironment(Environment):
     """ """
 
     _cmp_attributes = ["name", "descr"]
 
-    def __init__(self, name, descr, isa, little_endian=False):
+    def __init__(self,
+                 name: str,
+                 descr: str,
+                 isa: ISA,
+                 little_endian: bool = False):
         """
 
         :param name:
         :param descr:
         :param isa:
 
         """
         super(GenericEnvironment, self).__init__()
         self._name = name
         self._description = descr
         self._isa = isa
-        self._reserved_registers = []
+        self._reserved_registers: List[Register] = []
         self._threads = 1
         self._target = None
         self._default_wrapper = None
         self._little_endian = little_endian
         self.register_property(
             Property(
                 "problem_state", "Boolean indicating if the program"
                 " is executed in the problem state"
-                " (not privilege level)", True
-            )
-        )
+                " (not privilege level)", True))
 
     @property
     def name(self):
-        """ """
         return self._name
 
     @property
     def description(self):
-        """ """
         return self._description
 
     @property
     def isa(self):
-        """ """
         return self._isa
 
     @property
     def environment_reserved_registers(self):
-        """ """
         return self._reserved_registers
 
     @property
     def threads(self):
-        """ """
         return self._threads
 
     @property
     def target(self):
-        """ """
         return self._target
 
-    def set_target(self, target):
+    def set_target(self, target: Target):
         """
 
         :param target:
 
         """
         self._target = target
 
-    def set_threads(self, num_threads):
+    def set_threads(self, num_threads: int):
         """
 
         :param num_threads:
 
         """
         self._threads = num_threads
 
     def __str__(self):
-        """ """
         return "Environment '%s': %s" % (self.name, self.description)
 
-    def register_name(self, register):
+    def register_name(self, register: str):
         """
 
         :param register:
 
         """
         raise NotImplementedError(
             "Register name translation requested but not implemented. Check"
-            " if you are targeting the appropriate environment (%s)" % register
-        )
+            " if you are targeting the appropriate environment (%s)" %
+            register)
 
     def full_report(self):
-        """ """
         return str(self)
 
     @property
     def default_wrapper(self):
-        """ """
         return self._default_wrapper
 
-    def elf_abi(self, stack_size, start_symbol, **kwargs):
-        """ """
-
-        stack = VariableArray(
-            kwargs.get("stack_name", "microprobe_stack"),
-            "uint8_t",
-            stack_size,
-            align=kwargs.get("stack_alignment", 16),
-            address=kwargs.get("stack_address", None)
-        )
+    def elf_abi(self,
+                stack_size: int,
+                start_symbol,
+                stack_name: str = "microprobe stack",
+                stack_alignment: int = 16,
+                stack_address: Address | None = None,
+                **kwargs):
+
+        stack = VariableArray(stack_name,
+                              "uint8_t",
+                              stack_size,
+                              align=stack_alignment,
+                              address=stack_address)
 
-        instructions = []
+        instructions: List[Instruction] = []
         instructions += self.target.set_register_to_address(
-            self.stack_pointer,
-            Address(
-                base_address=kwargs.get(
-                    "stack_name", "microprobe_stack"
-                )
-            ),
-            Context()
-        )
+            self.stack_pointer, Address(base_address=stack_name), Context())
 
         if self.stack_direction == "decrease":
             instructions += self.target.add_to_register(
-                self.stack_pointer, stack_size
-            )
+                self.stack_pointer, stack_size)
 
         if start_symbol is not None:
             instructions += self.target.function_call(start_symbol)
             instructions += self.target.function_call("ELF_ABI_EXIT")
 
         instructions[0].set_label("ELF_ABI_START")
 
         return [stack], instructions
 
-    def function_call(self, target, return_address_reg=None, long_jump=False):
-        """ """
+    def function_call(self,
+                      target: Target,
+                      return_address_reg: Register | None = None,
+                      long_jump: bool = False):
         raise NotImplementedError
 
-    def function_return(self, return_address_reg=None):
-        """ """
+    def function_return(self, return_address_reg: Register | None = None):
         raise NotImplementedError
 
     @property
     def volatile_registers(self):
-        """ """
         raise NotImplementedError
 
+    @property
     def stack_pointer(self):
-        """ """
         raise NotImplementedError
 
+    @property
     def stack_direction(self):
-        """ """
         raise NotImplementedError
 
     @property
     def little_endian(self):
-        """ """
         return self._little_endian
 
     def _check_cmp(self, other):
 
         if not isinstance(other, self.__class__):
-            raise NotImplementedError(
-                "%s != %s" % (
-                    other.__class__, self.__class__
-                )
-            )
+            raise NotImplementedError("%s != %s" %
+                                      (other.__class__, self.__class__))
 
     def __eq__(self, other):
         """x.__eq__(y) <==> x==y"""
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if not getattr(self, attr) == getattr(other, attr):
                 return False
@@ -513,25 +488,20 @@
             if getattr(self, attr) >= getattr(other, attr):
                 continue
             else:
                 return False
         return True
 
     def hook_before_test_instructions(self):
-        """ """
         return []
 
     def hook_after_test_instructions(self):
-        """ """
         return [self._target.nop()]
 
     def hook_test_init_instructions(self):
-        """ """
         return []
 
     def hook_after_reset_instructions(self):
-        """ """
         return []
 
     def hook_test_end_instructions(self):
-        """ """
         return []
```

## microprobe/target/isa/__init__.py

```diff
@@ -12,65 +12,68 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.target.isa` package
 
 """
 
 # Futures
-from __future__ import absolute_import
+from __future__ import absolute_import, annotations
 
 # Built-in modules
 import abc
 import os
+from typing import TYPE_CHECKING, List, Dict
 
 # Third party modules
 
 # Own modules
 import microprobe.code.ins
 from microprobe import MICROPROBE_RC
-from microprobe.code.address import Address, InstructionAddress
+from microprobe.code.address import InstructionAddress
 from microprobe.code.context import Context
 from microprobe.code.var import VariableArray
-from microprobe.exceptions import MicroprobeArchitectureDefinitionError, \
-    MicroprobeCodeGenerationError, MicroprobeTargetDefinitionError, \
-    MicroprobeYamlFormatError
+from microprobe.exceptions import MicroprobeCodeGenerationError, \
+    MicroprobeTargetDefinitionError, MicroprobeYamlFormatError
 from microprobe.target.isa import comparator as comparator_mod
 from microprobe.target.isa import generator as generator_mod
 from microprobe.target.isa import instruction as instruction_mod
 from microprobe.target.isa import instruction_field as ifield_mod
 from microprobe.target.isa import instruction_format as iformat_mod
 from microprobe.target.isa import operand as operand_mod
 from microprobe.target.isa import register as register_mod
 from microprobe.target.isa import register_type as register_type_mod
 from microprobe.target.isa.dat import GenericDynamicAddressTranslation
 from microprobe.utils.imp import get_object_from_module, \
     import_cls_definition, import_definition, import_operand_definition
 from microprobe.utils.logger import DEBUG, get_logger
-from microprobe.utils.misc import dict2OrderedDict, findfiles, natural_sort
+from microprobe.utils.misc import dict2OrderedDict, findfiles
 from microprobe.utils.yaml import read_yaml
-import six
 
 # Local modules
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.target import Definition, Target
+    from microprobe.target.isa.register import Register
+    from microprobe.code.var import Variable
+    from microprobe.code.ins import Instruction, InstructionType
 
 # Constants
-SCHEMA = os.path.join(
-    os.path.dirname(os.path.abspath(__file__)), "schemas", "isa.yaml"
-)
-DEFAULT_ISA = os.path.join(
-    os.path.dirname(os.path.abspath(__file__)), "default", "isa.yaml"
-)
+SCHEMA = os.path.join(os.path.dirname(os.path.abspath(__file__)), "schemas",
+                      "isa.yaml")
+DEFAULT_ISA = os.path.join(os.path.dirname(os.path.abspath(__file__)),
+                           "default", "isa.yaml")
 LOG = get_logger(__name__)
 __all__ = [
     "find_isa_definitions", "import_isa_definition", "ISA", "GenericISA"
 ]
 
 
 # Functions
-def _read_isa_extensions(isadefs, path):
+def _read_isa_extensions(isadefs: List[Dict[str, str]], path: str):
     """
 
     :param isadefs:
     :param path:
 
     """
 
@@ -84,15 +87,15 @@
         isadef = read_yaml(os.path.join(isadefval, "isa.yaml"), SCHEMA)
         isadef["Path"] = isadefval
         isadefs.append(isadef)
 
         _read_isa_extensions(isadefs, isadefval)
 
 
-def _read_yaml_definition(isadefs, path):
+def _read_yaml_definition(isadefs: List[Dict[str, str]], path: str):
     """
 
     :param isadefs:
     :param path:
 
     """
 
@@ -132,220 +135,186 @@
                             if override:
                                 complete_isadef[key][key2] = [val[key2]]
                             else:
                                 complete_isadef[key][key2].append(val[key2])
                         else:
                             if override:
                                 complete_isadef[key][key2] = [
-                                    os.path.join(
-                                        isadef["Path"], val[key2]
-                                    )
+                                    os.path.join(isadef["Path"], val[key2])
                                 ]
                             else:
                                 complete_isadef[key][key2].append(
-                                    os.path.join(
-                                        isadef["Path"], val[key2]
-                                    )
-                                )
+                                    os.path.join(isadef["Path"], val[key2]))
 
                         if inherit:
                             key3 = "%s_inherits" % key2
                             if key3 not in complete_isadef[key]:
                                 complete_isadef[key][key3] = []
                             complete_isadef[key][key3].append(
-                                complete_isadef[key][key2][-1]
-                            )
+                                complete_isadef[key][key2][-1])
 
                     elif key2 == "Module":
                         if val[key2].startswith("microprobe"):
-                            val[key2] = os.path.join(
-                                os.path.dirname(__file__), "..", "..", "..",
-                                val[key2]
-                            )
+                            val[key2] = os.path.join(os.path.dirname(__file__),
+                                                     "..", "..", "..",
+                                                     val[key2])
 
                         if os.path.isabs(val[key2]):
                             complete_isadef[key][key2] = val[key2]
                         else:
                             complete_isadef[key][key2] = os.path.join(
-                                isadef["Path"], val[key2]
-                            )
+                                isadef["Path"], val[key2])
                     else:
                         complete_isadef[key][key2] = val[key2]
 
     return complete_isadef
 
 
-def import_isa_definition(path):
+def import_isa_definition(path: str):
     """Imports a ISA definition given a path
 
     :param path:
 
     """
 
     LOG.info("Start ISA import")
     LOG.debug("Importing definition from '%s'", path)
 
     if not os.path.isabs(path):
         path = os.path.abspath(path)
 
     isadef = _read_yaml_definition([], path)
 
-    regts, force = import_definition(
-        isadef, os.path.join(path, "isa.yaml"), "Register_type",
-        register_type_mod, None
-    )
+    regts, force = import_definition(isadef, os.path.join(path, "isa.yaml"),
+                                     "Register_type", register_type_mod, None)
     regts = dict2OrderedDict(regts)
 
-    regs, force = import_definition(
-        isadef,
-        os.path.join(
-            path, "isa.yaml"
-        ),
-        "Register",
-        register_mod,
-        regts,
-        force=force
-    )
+    regs, force = import_definition(isadef,
+                                    os.path.join(path, "isa.yaml"),
+                                    "Register",
+                                    register_mod,
+                                    regts,
+                                    force=force)
     regs = dict2OrderedDict(regs)
 
-    ops, force = import_operand_definition(
-        isadef,
-        os.path.join(
-            path, "isa.yaml"
-        ),
-        "Operand",
-        operand_mod,
-        regs,
-        force=force
-    )
+    ops, force = import_operand_definition(isadef,
+                                           os.path.join(path, "isa.yaml"),
+                                           "Operand",
+                                           operand_mod,
+                                           regs,
+                                           force=force)
     ops = dict2OrderedDict(ops)
 
-    ifields, force = import_definition(
-        isadef,
-        os.path.join(
-            path, "isa.yaml"
-        ),
-        "Instruction_field",
-        ifield_mod,
-        ops,
-        force=force
-    )
+    ifields, force = import_definition(isadef,
+                                       os.path.join(path, "isa.yaml"),
+                                       "Instruction_field",
+                                       ifield_mod,
+                                       ops,
+                                       force=force)
     ifields = dict2OrderedDict(ifields)
 
-    iformats, force = import_definition(
-        isadef,
-        os.path.join(
-            path, "isa.yaml"
-        ),
-        "Instruction_format",
-        iformat_mod,
-        ifields,
-        force=force
-    )
+    iformats, force = import_definition(isadef,
+                                        os.path.join(path, "isa.yaml"),
+                                        "Instruction_format",
+                                        iformat_mod,
+                                        ifields,
+                                        force=force)
 
     iformats = dict2OrderedDict(iformats)
 
-    ins, force = import_definition(
-        isadef,
-        os.path.join(
-            path, "isa.yaml"
-        ),
-        "Instruction",
-        instruction_mod, (iformats, ops),
-        force=force
-    )
+    ins, force = import_definition(isadef,
+                                   os.path.join(path, "isa.yaml"),
+                                   "Instruction",
+                                   instruction_mod, (iformats, ops),
+                                   force=force)
     ins = dict2OrderedDict(ins)
 
-    comp_clss = import_cls_definition(
-        isadef, os.path.join(path, "isa.yaml"), "Comparator", comparator_mod
-    )
-
-    gen_clss = import_cls_definition(
-        isadef, os.path.join(path, "isa.yaml"), "Generator", generator_mod
-    )
-
-    isa_cls = get_object_from_module(
-        isadef["ISA"]["Class"], isadef["ISA"]["Module"]
-    )
+    comp_clss = import_cls_definition(isadef, os.path.join(path, "isa.yaml"),
+                                      "Comparator", comparator_mod)
+
+    gen_clss = import_cls_definition(isadef, os.path.join(path, "isa.yaml"),
+                                     "Generator", generator_mod)
+
+    isa_cls = get_object_from_module(isadef["ISA"]["Class"],
+                                     isadef["ISA"]["Module"])
 
     try:
-        isa = isa_cls(
-            isadef["Name"], isadef["Description"], path, ins,
-            regs, comp_clss, gen_clss
-        )
+        isa = isa_cls(isadef["Name"], isadef["Description"], path, ins, regs,
+                      comp_clss, gen_clss)
     except TypeError as exc:
         LOG.critical("Unable to import ISA definition.")
         LOG.critical("Check if you definition is complete.")
         LOG.critical("Error reported: %s", exc)
         raise MicroprobeTargetDefinitionError(exc)
 
     LOG.info("ISA '%s' imported", isa)
 
     if not LOG.isEnabledFor(DEBUG):
         return isa
 
     # Check definition. Ensure that all the components defined are referenced.
     for unused_regt in [
-        regt
-        for regt in regts.values()
-        if regt not in [reg.type for reg in isa.registers.values()]
+            regt for regt in regts.values()
+            if regt not in [reg.type for reg in isa.registers.values()]
     ]:
         LOG.warning("Unused register type definition: %s", unused_regt)
 
     for unused_reg in [
-        reg for reg in regs.values() if reg not in list(isa.registers.values())
+            reg for reg in regs.values()
+            if reg not in list(isa.registers.values())
     ]:
         LOG.warning("Unused register definition: %s", unused_reg)
 
     used_operands = []
     for ins in isa.instructions.values():
         for oper in ins.operands.values():
             used_operands.append(oper[0].name)
         for operand in [operand.type for operand in ins.implicit_operands]:
             used_operands.append(operand.name)
         for field in ins.format.fields:
             used_operands.append(field.default_operand.name)
 
     for unused_op in [
-        operand for operand in ops.values()
-        if operand.name not in used_operands
+            operand for operand in ops.values()
+            if operand.name not in used_operands
     ]:
         LOG.warning("Unused operand definition: %s", unused_op)
 
     used_fields = []
     for ins in isa.instructions.values():
         used_fields += [field.name for field in ins.format.fields]
 
     for unused_field in [
-        field for field in ifields.values() if field.name not in used_fields
+            field for field in ifields.values()
+            if field.name not in used_fields
     ]:
         LOG.warning("Unused field definition: %s", unused_field)
 
     used_formats = []
     for ins in isa.instructions.values():
         used_formats.append(ins.format.name)
 
     for unused_format in [
-        iformat
-        for iformat in iformats.values() if iformat.name not in used_formats
+            iformat for iformat in iformats.values()
+            if iformat.name not in used_formats
     ]:
         LOG.warning("Unused format definition: %s", unused_format)
 
     return isa
 
 
-def find_isa_definitions(paths=None):
+def find_isa_definitions(paths: List[str] | None = None):
 
     if paths is None:
         paths = []
 
     paths = paths + MICROPROBE_RC["architecture_paths"] \
         + MICROPROBE_RC["default_paths"]
 
-    results = []
+    results: List[Definition] = []
     isafiles = findfiles(paths, "^isa.yaml$")
 
     if len(isafiles) > 0:
         from microprobe.target import Definition
 
     for isafile in isafiles:
 
@@ -353,342 +322,336 @@
             isadef = read_yaml(isafile, SCHEMA)
         except MicroprobeYamlFormatError as exc:
             LOG.info("Exception: %s", exc)
             LOG.info("Skipping '%s'", isafile)
             continue
 
         try:
-            definition = Definition(
-                isafile, isadef["Name"], isadef["Description"]
-            )
-            if (
-                definition not in results and
-                not definition.name.endswith("common")
-            ):
+            definition = Definition(isafile, isadef["Name"],
+                                    isadef["Description"])
+            if (definition not in results
+                    and not definition.name.endswith("common")):
                 results.append(definition)
         except TypeError as exc:
             # Skip bad definitions
             LOG.info("Exception: %s", exc)
             LOG.info("Skipping '%s'", isafile)
             continue
     return results
 
 
 # Classes
-class ISA(six.with_metaclass(abc.ABCMeta, object)):
+class ISA(abc.ABC):
     """Abstract class to represent an Instruction Set Architecture (ISA).
 
     An instruction set architecture (ISA) object defines the part of the
     computer architecture related to programming, including instructions,
     registers, operands, memory operands, etc.
     """
 
     @abc.abstractmethod
     def __init__(self):
-        """ """
         pass
 
-    @abc.abstractproperty
-    def name(self):
+    @property
+    @abc.abstractmethod
+    def name(self) -> str:
         """ISA name (:class:`~.str`)."""
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def description(self):
+    @property
+    @abc.abstractmethod
+    def description(self) -> str:
         """ISA description (:class:`~.str`)."""
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def path(self):
+    @property
+    @abc.abstractmethod
+    def path(self) -> str:
         """Path to definition (:class:`~.str`)."""
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def instructions(self):
+    @property
+    @abc.abstractmethod
+    def instructions(self) -> Dict[str, InstructionType]:
         """ISA instructions (:class:`~.dict` mapping strings to
-           :class:`~.InstructionType`). """
+        :class:`~.InstructionType`)."""
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def target(self):
+    @property
+    @abc.abstractmethod
+    def target(self) -> Target:
         """Associated target object (:class:`~.Target`)."""
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def registers(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def registers(self) -> Dict[str, Register]:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def scratch_registers(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def scratch_registers(self) -> List[Register]:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def address_registers(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def address_registers(self) -> List[Register]:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def float_registers(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def float_registers(self) -> List[Register]:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def control_registers(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def control_registers(self) -> List[Register]:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def scratch_var(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def scratch_var(self) -> Variable:
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def context_var(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def __str__(self):
-        """ """
+    def __str__(self) -> str:
         raise NotImplementedError
 
     @abc.abstractmethod
     def full_report(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def set_register(self, reg, value, context):
+    def set_register(self, reg: Register, value, context: Context):
         """
 
         :param reg:
         :param value:
         :param context:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def negate_register(self, reg, context):
+    def negate_register(self, reg: Register, context: Context):
         """
 
         :param reg:
         :param context:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def load(self, reg, address, context):
+    def load(self, reg: Register, address, context: Context):
         """
 
         :param reg:
         :param address:
         :param context:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def load_float(self, reg, address, context):
+    def load_float(self, reg: Register, address, context: Context):
         """
 
         :param reg:
         :param address:
         :param context:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def store_float(self, reg, address, context):
+    def store_float(self, reg: Register, address, context: Context):
         """
 
         :param reg:
         :param address:
         :param context:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def store_integer(self, reg, address, length, context):
+    def store_integer(self, reg: Register, address, length, context: Context):
         """
 
         :param reg:
         :param address:
         :param length:
         :param context:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def store_decimal(self, address, length, value, context):
+    def store_decimal(self, address, length, value, context: Context):
         """
 
         :param address:
         :param length:
         :param value:
         :param context:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def set_register_to_address(
-        self,
-        reg,
-        address,
-        context,
-        force_absolute=False,
-        force_relative=False
-    ):
+    def set_register_to_address(self,
+                                reg: Register,
+                                address,
+                                context: Context,
+                                force_absolute: bool = False,
+                                force_relative: bool = False):
         """
 
         :param reg:
         :param address:
         :param context:
         :param force_absolute:  (Default value = False)
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def get_register_for_address_arithmetic(self, context):
+    def get_register_for_address_arithmetic(self, context: Context):
         """
 
         :param context:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def get_register_for_float_arithmetic(self, context):
+    def get_register_for_float_arithmetic(self, context: Context):
         """
 
         :param context:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def set_register_bits(self, register, value, mask, shift, context):
+    def set_register_bits(self, register, value, mask, shift,
+                          context: Context):
         """
 
         :param register:
         :param value:
         :param mask:
         :param shift:
         :param context:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def new_instruction(self, name):
+    def new_instruction(self, name: str):
         """
 
         :param name:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def set_target(self, target):
+    def set_target(self, target: Target):
         """
 
         :param target:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def add_to_register(self, register, value):
+    def add_to_register(self, register: Register, value):
         """
 
         :param register:
         :param value:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def branch_unconditional_relative(self, source, target):
+    def branch_unconditional_relative(self, source, target: Target):
         """
 
         :param source:
         :param target:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
     def branch_to_itself(self):
         raise NotImplementedError
 
     @abc.abstractmethod
-    def compare_and_branch(self, val1, val2, cond, target, context):
+    def compare_and_branch(self, val1, val2, cond, target, context: Context):
         """
 
         :param val1:
         :param val2:
         :param cond:
         :param target:
         :param context:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
     def nop(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def flag_registers(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def get_dat(self, **kwargs):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def set_context(self, variable=None, tmpl_path=None):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def get_context(self, variable=None, tmpl_path=None):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def register_value_comparator(self, comp):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def normalize_asm(self, mnemonic, operands):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def randomize_register(self, register, seed=None):
         raise NotImplementedError
 
 
 class GenericISA(ISA):
     """Class to represent a generic Instruction Set Architecture (ISA)."""
 
-    def __init__(self, name, descr, path, ins, regs, comparators, generators):
+    def __init__(self, name: str, descr: str, path: str,
+                 ins: Dict[str, InstructionType], regs: Dict[str, Register],
+                 comparators, generators):
         """
 
         :param name:
         :param descr:
         :param ins:
         :param regs:
         :param comparators:
@@ -714,100 +677,87 @@
         for comparator in comparators:
             self._comparators.append(comparator(self))
 
         self._generators = []
         for generator in generators:
             self._generators.append(generator(self))
 
-        self._scratch_registers = []
-        self._control_registers = []
-        self._flag_registers = []
+        self._scratch_registers: List[Register] = []
+        self._control_registers: List[Register] = []
+        self._flag_registers: List[Register] = []
 
         self._scratch_var = VariableArray(
-            ("%s_scratch_var" % self._name).upper(), "char", 256, align=8
-        )
+            ("%s_scratch_var" % self._name).upper(), "char", 256, align=8)
         self._context_var = None
 
     @property
     def name(self):
-        """ """
         return self._name
 
     @property
     def description(self):
-        """ """
         return self._descr
 
     @property
     def path(self):
         """Path to definition (:class:`~.str`)."""
         return self._path
 
     @property
     def address_registers(self):
-        """ """
         return self._address_registers
 
     @property
     def float_registers(self):
-        """ """
         return self._float_registers
 
     @property
     def flag_registers(self):
-        """ """
         return self._flag_registers
 
     @property
     def instructions(self):
-        """ """
         return self._instructions
 
     @property
     def scratch_var(self):
-        """ """
         return self._scratch_var
 
     @property
     def registers(self):
-        """ """
         return self._registers
 
     @property
     def target(self):
-        """ """
         return self._target
 
     def normalize_asm(self, mnemonic, operands):
-        """ """
         return mnemonic, operands
 
-    def set_target(self, target):
+    def set_target(self, target: Target):
         """
 
         :param target:
 
         """
         self._target = target
 
     def __str__(self):
-        """ """
         return "ISA Name: %s - %s" % (self.name, self.description)
 
-    def new_instruction(self, name):
+    def new_instruction(self, name: str):
         """
 
         :param name:
 
         """
         ins_type = self.instructions[name]
         return microprobe.code.ins.instruction_factory(ins_type)
 
     def full_report(self):
-        """ """
         rstr = "-" * 80 + "\n"
         rstr += "ISA Name: %s\n" % self.name
         rstr += "ISA Description: %s\n" % self.name
         rstr += "-" * 80 + "\n"
         rstr += "Register Types:\n"
         for regt in set([reg.type for reg in self.registers.values()]):
             rstr += str(regt) + "\n"
@@ -823,176 +773,155 @@
         rstr += "\n Instructions defined: %s \n" % \
             len(set([ins.mnemonic for ins in self.instructions.values()]))
 
         rstr += " Variants defined: %s \n" % len(self.instructions)
         rstr += "-" * 80 + "\n"
         return rstr
 
-    def set_register(self, reg, value, context):
+    def set_register(self, reg: Register, value, context: Context):
         """
 
         :param reg:
         :param value:
         :param context:
 
         """
-        raise MicroprobeCodeGenerationError(
-            "Unable to set register '%s' to "
-            " value '%d'." % (reg.name, value)
-        )
+        raise MicroprobeCodeGenerationError("Unable to set register '%s' to "
+                                            " value '%d'." % (reg.name, value))
 
     @property
     def scratch_registers(self):
-        """ """
         return self._scratch_registers
 
     @property
     def control_registers(self):
-        """ """
         return self._control_registers
 
-    def get_register_for_address_arithmetic(self, context):
+    def get_register_for_address_arithmetic(self, context: Context):
         """
 
         :param context:
 
         """
         reg = [
-            reg
-            for reg in self._address_registers
+            reg for reg in self._address_registers
             if reg not in context.reserved_registers
         ]
 
         if len(reg) == 0:
-            raise MicroprobeCodeGenerationError(
-                "No free registers available. "
-                "Change your policy."
-            )
+            raise MicroprobeCodeGenerationError("No free registers available. "
+                                                "Change your policy.")
 
         # REG0 tends to have special meaning and it is usually at the
         # beginning, move it
         reg = reg[1:] + [reg[0]]
         return reg[0]
 
-    def get_register_for_float_arithmetic(self, context):
+    def get_register_for_float_arithmetic(self, context: Context):
         """
 
         :param context:
 
         """
         reg = [
-            reg
-            for reg in self._float_registers
+            reg for reg in self._float_registers
             if reg not in context.reserved_registers
         ]
 
         assert len(reg) > 0, "All registers for floats already reserved"
 
         # REG0 tends to have special meaning and it is usually at the
         # beginning, move it
         reg = reg[1:] + [reg[0]]
         return reg[0]
 
-    def add_to_register(self, register, value):
+    def add_to_register(self, register: Register, value):
         """
 
         :param register:
         :param value:
 
         """
         super(GenericISA, self).add_to_register(register, value)
 
-    def branch_unconditional_relative(self, source, target):
+    def branch_unconditional_relative(self, source, target: Target):
         """
 
         :param source:
         :param target:
 
         """
-        return super(GenericISA, self).branch_unconditional_relative(
-                source, target)
+        return super(GenericISA,
+                     self).branch_unconditional_relative(source, target)
 
     def branch_to_itself(self):
         instr = self.branch_unconditional_relative(
-            InstructionAddress(
-                base_address="code"
-            ),
-            InstructionAddress(
-                base_address="code"
-            )
-        )
+            InstructionAddress(base_address="code"),
+            InstructionAddress(base_address="code"))
         instr.set_address(None)
         return instr
 
     def get_dat(self, **kwargs):
-        """ """
         return GenericDynamicAddressTranslation(self, **kwargs)
 
     def set_context(self, variable=None, tmpl_path=None, complete=False):
-        """ """
 
         if variable is None:
             variable = self.context_var
 
         if variable.size < self.context_var.size:
             raise MicroprobeCodeGenerationError(
-                "Variable '%s' is too small to restore the target context"
-            )
+                "Variable '%s' is too small to restore the target context")
 
         asm = open(os.path.join(tmpl_path, "setcontext.S")).readlines()
         for idx, line in enumerate(asm):
             asm[idx] = line.replace("@@SCRATCH@@", variable.name)
 
         if len(asm) == 0:
             return []
 
         if complete:
             return microprobe.code.ins.instructions_from_asm(
-                asm, self.target, labels=[variable.name]
-            )
+                asm, self.target, labels=[variable.name])
         else:
             reg = self._scratch_registers[0]
-            instrs = self.set_register_to_address(
-                reg, variable.address, Context()
-            )
+            instrs = self.set_register_to_address(reg, variable.address,
+                                                  Context())
             return instrs + microprobe.code.ins.instructions_from_asm(
-                asm, self.target, labels=[variable.name]
-            )
+                asm, self.target, labels=[variable.name])
 
-    def get_context(self, variable=None, tmpl_path=None, complete=False):
-        """ """
+    def get_context(self,
+                    variable=None,
+                    tmpl_path=None,
+                    complete: bool = False):
 
         if variable is None:
             variable = self.context_var
 
         if variable.size < self.context_var.size:
             raise MicroprobeCodeGenerationError(
-                "Variable '%s' is too small to save the target context"
-            )
+                "Variable '%s' is too small to save the target context")
 
         asm = open(os.path.join(tmpl_path, "getcontext.S")).readlines()
         for idx, line in enumerate(asm):
             asm[idx] = line.replace("@@SCRATCH@@", variable.name)
 
         if len(asm) == 0:
             return []
 
         if complete:
             return microprobe.code.ins.instructions_from_asm(
-                asm, self.target, labels=[variable.name]
-            )
+                asm, self.target, labels=[variable.name])
         else:
             reg = self._scratch_registers[0]
-            instrs = self.set_register_to_address(
-                reg, variable.address, Context()
-            )
+            instrs = self.set_register_to_address(reg, variable.address,
+                                                  Context())
             return instrs + \
                 microprobe.code.ins.instructions_from_asm(
                     asm, self.target, labels=[variable.name]
                 )
 
     def register_value_comparator(self, comp):
-        """ """
         raise NotImplementedError
 
-    def randomize_register(self, register, seed=None):
+    def randomize_register(self, register: Register, seed=None):
         raise NotImplementedError
```

## microprobe/target/isa/comparator.py

```diff
@@ -18,22 +18,20 @@
 # Futures
 from __future__ import absolute_import
 
 # Built-in modules
 import abc
 
 # Third party modules
-import six
 
 # Own modules
 from microprobe.exceptions import MicroprobeArchitectureDefinitionError
 from microprobe.utils.imp import find_subclasses
 from microprobe.utils.logger import get_logger
 
-
 # Constants
 LOG = get_logger(__name__)
 __all__ = ["import_classes_from", "Comparator"]
 
 
 # Functions
 def import_classes_from(modules):
@@ -51,28 +49,27 @@
 
             name = cls.__name__
             if name in classes:
                 raise MicroprobeArchitectureDefinitionError(
                     "Duplicated "
                     "definition"
                     " of Comparator '%s' "
-                    "in module '%s'" % (name, module_str)
-                )
+                    "in module '%s'" % (name, module_str))
             LOG.info("%s comparator imported", name)
             classes[name] = cls
 
     if len(classes) == 0:
         LOG.warning("No comparators imported.")
 
     LOG.info("End")
     return list(classes.values())
 
 
 # Classes
-class Comparator(six.with_metaclass(abc.ABCMeta, object)):
+class Comparator(object, metaclass=abc.ABCMeta):
     """Abstract class to perform comparisons. :class:`~.Comparator`
     objects are in charge of performing comparisons between values
     while providing an architecture independent and modular interface.
     They are registered in an :class:`~.ISA` object using the
     :meth:`~.ISA.register_value_comparator`.
     Once registered, whenever a comparison is needed to perform a
     given operation, it is possible to check (:meth:`check`) if
@@ -124,15 +121,16 @@
         :param helper_instr: List of helper instructions.
         :type helper_instr: :class:`~.list` of :class`~.Instruction`
                     instances.
 
         """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def instr_name(self):
         """Value comparator name, usually the opcode of the instruction it
         uses (:class:`~.str`).
 
 
         """
         raise NotImplementedError
```

## microprobe/target/isa/dat.py

```diff
@@ -19,99 +19,88 @@
 from __future__ import absolute_import, print_function
 
 # Built-in modules
 import abc
 import warnings
 
 # Third party modules
-import six
 
 # Own modules
 from microprobe.exceptions import MicroprobeAddressTranslationError, \
     MicroprobeDuplicatedValueError
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import RejectingDict
 
-
 # Constants
 
 LOG = get_logger(__name__)
 __all__ = ["DynamicAddressTranslation", "GenericDynamicAddressTranslation"]
 
 # Functions
 
 
 # Classes
-class DynamicAddressTranslation(six.with_metaclass(abc.ABCMeta, object)):
+class DynamicAddressTranslation(abc.ABC):
     """ """
 
     @abc.abstractmethod
     def __init__(self, target, **kwargs):
-        """ """
         pass
 
     @abc.abstractmethod
     def add_mapping(self, source, target, mask):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def maps(self):
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def control(self):
         raise NotImplementedError
 
     @abc.abstractmethod
     def copy(self, **kwargs):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def translate(self, address):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def raw_parse(self, raw_str):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def raw_decorate(self, raw_str):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def required_register_values(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def required_memory_values(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def update_dat(self, **kwargs):
-        """ """
         raise NotImplementedError
 
 
 class GenericDynamicAddressTranslation(DynamicAddressTranslation):
     """ """
 
     _control_keys = {'DAT': False}
 
     def __init__(self, target, **kwargs):
-        """ """
-        super(GenericDynamicAddressTranslation, self).__init__(
-            target, **kwargs
-        )
+        super(GenericDynamicAddressTranslation,
+              self).__init__(target, **kwargs)
 
         self._map = RejectingDict()
         self._target = target
         self._control = self._control_keys.copy()
         self._control.update(kwargs)
 
         tmaps = kwargs.pop('dat_map', False)
@@ -124,91 +113,77 @@
         return self._control
 
     @property
     def maps(self):
         return self._map
 
     def add_mapping(self, source, target, mask):
-        """ """
 
         try:
             self._map[source & mask] = DATmap(source, target, mask)
         except MicroprobeDuplicatedValueError:
             raise MicroprobeAddressTranslationError(
-                "Map in '%s' already exists" % hex(source & mask)
-            )
+                "Map in '%s' already exists" % hex(source & mask))
 
     def copy(self, **kwargs):
-        """ """
 
         newargs = self.control.copy()
         newargs.update(kwargs)
         new_dat = GenericDynamicAddressTranslation(self._target, **newargs)
         for datmap in self.maps.values():
             new_dat.add_mapping(datmap.source, datmap.target, datmap.mask)
         return new_dat
 
     def translate(self, address, rev=False):
-        """ """
 
         if not self.control['DAT']:
             return address
 
         tmap = [
             tmap for tmap in self.maps.values()
             if tmap.address_in_map(address, rev=rev)
         ]
 
         if len(tmap) > 1:
             raise MicroprobeAddressTranslationError(
                 "Multiple translation maps found for address '%s'" %
-                hex(address)
-            )
+                hex(address))
         elif len(tmap) < 1:
             raise MicroprobeAddressTranslationError(
-                "No translation maps found for address '%s'" % hex(address)
-            )
+                "No translation maps found for address '%s'" % hex(address))
         else:
             return tmap[0].address_translate(address, rev=rev)
 
     def raw_parse(self, raw_str):
-        """ """
         raise NotImplementedError(
             "DAT mechanisms and parameters are target dependent. Target: '%s'"
-            " does not implement them. " % self._target
-        )
+            " does not implement them. " % self._target)
 
     def raw_decorate(self, raw_str):
-        """ """
         raise NotImplementedError(
             "DAT mechanisms and parameters are target dependent. Target: '%s'"
-            " does not implement them. " % self._target
-        )
+            " does not implement them. " % self._target)
 
     def required_register_values(self):
-        """ """
         return []
 
     def required_memory_values(self):
-        """ """
         return []
 
     def update_dat(self, **kwargs):
-        """ """
         for key, value in kwargs.items():
             if key not in self._control_keys:
                 warnings.warn(
                     "DAT Control key '%s' specified but not supported. "
-                    "Ignoring it." % key
-                )
+                    "Ignoring it." % key)
                 continue
             self._control[key] = value['value']
 
 
-class DATmap(object):
+class DATmap:
     """ """
 
     def __init__(self, source, target, mask):
         self._source = source
         self._target = target
         self._mask = mask
 
@@ -228,18 +203,16 @@
         if rev:
             return self.target & self.mask == address & self.mask
         return self.source & self.mask == address & self.mask
 
     def address_translate(self, address, rev=False):
         if not self.address_in_map(address, rev=rev):
             raise MicroprobeAddressTranslationError(
-                "Unable to translate address '%s' in map: %s" % (
-                    hex(address), str(self)
-                )
-            )
+                "Unable to translate address '%s' in map: %s" %
+                (hex(address), str(self)))
 
         address &= (~self.mask)
         if rev:
             address |= (self.source & self.mask)
         else:
             address |= (self.target & self.mask)
         return address
```

## microprobe/target/isa/generator.py

```diff
@@ -12,35 +12,39 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.target.isa.generator` module
 
 """
 
 # Futures
-from __future__ import absolute_import
+from __future__ import absolute_import, annotations
 
 # Built-in modules
 import abc
+from typing import TYPE_CHECKING, List
 
 # Third party modules
-import six
 
 # Own modules
 from microprobe.exceptions import MicroprobeArchitectureDefinitionError
 from microprobe.utils.imp import find_subclasses
 from microprobe.utils.logger import get_logger
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.target.isa.register import Register
+    from microprobe.code.ins import Instruction
 
 # Constants
 LOG = get_logger(__name__)
 __all__ = ["import_classes_from", "Generator"]
 
 
 # Functions
-def import_classes_from(modules):
+def import_classes_from(modules: List[str]):
     """
 
     :param modules:
 
     """
 
     LOG.info("Start")
@@ -51,29 +55,28 @@
 
             name = cls.__name__
             if name in classes:
                 raise MicroprobeArchitectureDefinitionError(
                     "Duplicated "
                     "definition"
                     " of Generator '%s' "
-                    "in module '%s'", name, module_str
-                )
+                    "in module '%s'", name, module_str)
 
             LOG.info("%s generator imported", name)
             classes[name] = cls
 
     if len(classes) == 0:
         LOG.warning("No generators imported.")
 
     LOG.info("End")
     return list(classes.values())
 
 
 # Classes
-class Generator(six.with_metaclass(abc.ABCMeta, object)):
+class Generator(abc.ABC):
     """ """
 
     def __init__(self, arch):
         """
 
         :param arch:
 
@@ -88,20 +91,20 @@
         :param fvalue:
         :param address:  (Default value = False)
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def generate(
-        self, value,
-        fvalue, dummy_reg,
-        dummy_instr=None,
-        address=False
-    ):
+    def generate(self,
+                 value,
+                 fvalue,
+                 dummy_reg,
+                 dummy_instr=None,
+                 address=False):
         """
 
         :param value:
         :param fvalue:
         :param dummy_reg:
         :param dummy_instr:  (Default value = None)
         :param address:  (Default value = False)
@@ -109,25 +112,24 @@
         """
         assert (value, fvalue) == self.check(value, fvalue, address=address), \
             "Check error: (%s, %s) != %s " % (value, fvalue,
                                               self.check(value,
                                                          fvalue,
                                                          address=address))
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def instr_name(self):
-        """ """
         raise NotImplementedError
 
     @property
     def arch(self):
-        """ """
         return self._arch
 
-    def _orig_reg(self, value, reg, instr):
+    def _orig_reg(self, value, reg: Register, instr: Instruction):
         """
 
         :param value:
         :param reg:
         :param instr:
 
         """
@@ -136,9 +138,8 @@
             if reg2 != reg:
                 instr.add_allow_register(reg2)
                 return reg2
         return reg
 
     @property
     def alias(self):  # pylint: disable=no-self-use
-        """ """
         return []
```

## microprobe/target/isa/instruction.py

```diff
@@ -12,23 +12,24 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.target.isa.instruction` module
 
 """
 
 # Futures
-from __future__ import absolute_import, print_function
+from __future__ import absolute_import, print_function, annotations
 
 # Built-in modules
 import abc
 import hashlib
 import os
 import random
 import sys
 from inspect import getmembers, getmodule, isfunction
+from typing import TYPE_CHECKING, List
 
 # Third party modules
 import six
 from six.moves import range, zip
 
 # Own modules
 from microprobe.exceptions import MicroprobeArchitectureDefinitionError
@@ -38,28 +39,31 @@
     OperandConstReg, OperandDescriptor
 from microprobe.target.isa.instruction_field import GenericInstructionField
 from microprobe.target.isa.instruction_format import GenericInstructionFormat
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import OrderedDict, getnextf
 from microprobe.utils.yaml import read_yaml
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.target.isa.register import Register
+    from microprobe.target.isa.operand import Operand
 
 # Constants
-SCHEMA = os.path.join(
-    os.path.dirname(os.path.abspath(__file__)), "schemas", "instruction.yaml"
-)
+SCHEMA = os.path.join(os.path.dirname(os.path.abspath(__file__)), "schemas",
+                      "instruction.yaml")
 LOG = get_logger(__name__)
-__all__ = ["import_definition",
-           "InstructionType",
-           "GenericInstructionType",
-           "instruction_type_from_bin"]
+__all__ = [
+    "import_definition", "InstructionType", "GenericInstructionType",
+    "instruction_type_from_bin"
+]
 
 
 # Functions
-def import_definition(cls, filenames, args):
+def import_definition(cls, filenames: List[str], args):
     """
 
     :param filenames:
     :param args:
 
     """
 
@@ -92,54 +96,44 @@
                 raise MicroprobeArchitectureDefinitionError(
                     "Unknown "
                     "instruction "
                     "format '%s' in "
                     "instruction "
                     "definition "
                     "'%s' found "
-                    "in '%s'" % (
-                        elem["Format"], name, filename
-                    )
-                )
+                    "in '%s'" % (elem["Format"], name, filename))
+
+            operands = _merge_operands(name, filename, operands, iformat,
+                                       defined_operands)
 
-            operands = _merge_operands(
-                name, filename, operands, iformat, defined_operands
-            )
-
-            ioperands = _translate_ioperands(
-                name, filename, ioperands, defined_operands
-            )
-
-            moperands = _translate_moperands(
-                name, filename, operands, ioperands, moperands,
-                defined_memory_operands, iformat
-            )
+            ioperands = _translate_ioperands(name, filename, ioperands,
+                                             defined_operands)
+
+            moperands = _translate_moperands(name, filename, operands,
+                                             ioperands, moperands,
+                                             defined_memory_operands, iformat)
 
             # target_checks = _translate_callbacks(name, filename,
             #                                                target_checks)
 
-            instruction_checks = _translate_checks(
-                name, filename, cls, instruction_checks, operands
-            )
-
-            instruction = cls(
-                name, mnemonic, opcode, descr, iformat, operands, ioperands,
-                moperands, instruction_checks, target_checks
-            )
+            instruction_checks = _translate_checks(name, filename, cls,
+                                                   instruction_checks,
+                                                   operands)
+
+            instruction = cls(name, mnemonic, opcode, descr, iformat, operands,
+                              ioperands, moperands, instruction_checks,
+                              target_checks)
 
             if name in instructions:
-                raise MicroprobeArchitectureDefinitionError(
-                    "Duplicated "
-                    "definition "
-                    "of instruction "
-                    " '%s' found "
-                    "in '%s'" % (
-                        name, filename
-                    )
-                )
+                raise MicroprobeArchitectureDefinitionError("Duplicated "
+                                                            "definition "
+                                                            "of instruction "
+                                                            " '%s' found "
+                                                            "in '%s'" %
+                                                            (name, filename))
 
             LOG.debug(instruction)
             instructions[name] = instruction
 
     for filename in filenames:
         import_properties(filename, instructions)
 
@@ -154,34 +148,23 @@
     :param bin:
     :type bin:
     :param target:
     :type target:
     """
 
     foperand = OperandConst("raw", "raw", int(binstr, 16))
-    fields = [GenericInstructionField(
-        "raw", "raw", len(binstr) * 4, False, '?', foperand)]
-    iformat = GenericInstructionFormat(
-        "raw",
-        "raw",
-        fields,
-        "raw: 0x%s" %
-        binstr)
-    instr_type = GenericInstructionType(
-        "raw",
-        "raw",
-        "0",
-        "Unknown raw code",
-        iformat,
-        {'raw': [foperand, '?']},
-        {},
-        [],
-        {},
-        {}
-    )
+    fields = [
+        GenericInstructionField("raw", "raw",
+                                len(binstr) * 4, False, '?', foperand)
+    ]
+    iformat = GenericInstructionFormat("raw", "raw", fields,
+                                       "raw: 0x%s" % binstr)
+    instr_type = GenericInstructionType("raw", "raw", "0", "Unknown raw code",
+                                        iformat, {'raw': [foperand, '?']}, {},
+                                        [], {}, {})
 
     for prop in target.nop().properties.values():
 
         if prop.name == "disable_asm":
             prop.set_value(True)
 
         instr_type.register_property(prop)
@@ -220,26 +203,22 @@
             raise MicroprobeArchitectureDefinitionError(
                 "Definition of "
                 "instruction "
                 "'%s' in '%s' "
                 "requires the "
                 "definition of '%s' "
                 "in '%s' module with "
-                "operands '%s'." % (
-                    name, filename, fname, module_filename, fargs
-                )
-            )
+                "operands '%s'." %
+                (name, filename, fname, module_filename, fargs))
 
     return dict(translated_checks)
 
 
-def _translate_moperands(
-    name, filename, operands, ioperands, moperands, defined_memory_operands,
-    iformat
-):
+def _translate_moperands(name, filename, operands, ioperands, moperands,
+                         defined_memory_operands, iformat):
     """
 
     :param name:
     :param filename:
     :param operands:
     :param ioperands:
     :param moperands:
@@ -263,16 +242,16 @@
             if field == "D?":
 
                 voperands = [
                     key for key in operands.keys() if key.startswith("D")
                 ]
 
                 vfield = [
-                    tfield.name
-                    for tfield in iformat.fields if tfield.name.startswith("D")
+                    tfield.name for tfield in iformat.fields
+                    if tfield.name.startswith("D")
                 ]
 
                 assert sorted(voperands) == sorted(vfield)
 
                 if len(voperands) == 1:
 
                     field = voperands[0]
@@ -287,44 +266,37 @@
 
                     if voperands2 == voperands:
                         for voper in voperands:
                             sformula.append(voper)
                     else:
 
                         number = set(
-                            [
-                                elem[-1] for elem in formula if elem != "D?"
-                            ]
-                        )
+                            [elem[-1] for elem in formula if elem != "D?"])
 
                         if len(number) != 1:
                             raise MicroprobeArchitectureDefinitionError(
                                 "Bad formula in name '%s' in memory operand"
                                 " '%s' of instruction '%s' (%s) in filename "
-                                "'%s'" % (
-                                    field, memoperand, name, iformat.name,
-                                    filename
-                                )
-                            )
+                                "'%s'" % (field, memoperand, name,
+                                          iformat.name, filename))
                         number = number.pop()
                         sformula.append("D%s" % number)
 
             else:
                 sformula.append(field)
 
         for field in sformula:
 
             if isinstance(field, six.integer_types):
                 field = str(field)
 
             if field.startswith('@'):
                 try:
                     field = [
-                        elem
-                        for elem in operands.keys()
+                        elem for elem in operands.keys()
                         if elem[0] == field[1] and elem[-3:] == field[-3:]
                     ][0]
                 except IndexError:
                     pass
                     # raise MicroprobeArchitectureDefinitionError(
                     #     "Bad formula in name '%s' in memory operand"
                     #     " '%s' of instruction '%s' (%s) in filename '%s'" %
@@ -335,27 +307,24 @@
                 tformula.append((field, operands[field][0]))
             elif field in ioperands:
                 tformula.append((field, ioperands[field].type))
             else:
                 raise MicroprobeArchitectureDefinitionError(
                     "Unknown field name '%s' in memory operand"
                     " '%s' of instruction '%s' (%s) in filename '%s'" %
-                    (field, memoperand, name, iformat.name, filename)
-                )
+                    (field, memoperand, name, iformat.name, filename))
 
         for idx, field in enumerate(length):
             fname = "no_field_%s" % idx
             if isinstance(field, six.integer_types):
                 tlength.append((fname, field))
-            elif (
-                field.startswith("#") or field.startswith("min") or
-                field.startswith("max") or field.startswith("*") or
-                field.startswith("CEIL") or field == "Unknown" or
-                field.startswith("+") or field.startswith("-")
-            ):
+            elif (field.startswith("#") or field.startswith("min")
+                  or field.startswith("max") or field.startswith("*")
+                  or field.startswith("CEIL") or field == "Unknown"
+                  or field.startswith("+") or field.startswith("-")):
                 tlength.append((fname, field))
             else:
 
                 if field.endswith("_"):
                     field = field[0:-1]
 
                 pfields = [
@@ -370,38 +339,32 @@
                 except KeyError:
                     try:
                         tlength.append((field, ioperands[field]))
                     except Exception:
                         raise MicroprobeArchitectureDefinitionError(
                             "Unknown field name '%s' in length of "
                             "memory operand '%s' of instruction '%s' in"
-                            " filename '%s'" % (
-                                field, memoperand, name, filename
-                            )
-                        )
-
-        memory_operand = MemoryOperand(
-            OrderedDict(tformula), OrderedDict(tlength)
-        )
+                            " filename '%s'" %
+                            (field, memoperand, name, filename))
+
+        memory_operand = MemoryOperand(OrderedDict(tformula),
+                                       OrderedDict(tlength))
 
         is_defined = [
-            operand
-            for operand in defined_memory_operands if operand == memory_operand
+            operand for operand in defined_memory_operands
+            if operand == memory_operand
         ]
 
         if len(is_defined) > 0:
             memory_operand = is_defined[0]
         else:
             defined_memory_operands.append(memory_operand)
 
         roperands.append(
-            MemoryOperandDescriptor(
-                memory_operand, io_flags, rate
-            )
-        )
+            MemoryOperandDescriptor(memory_operand, io_flags, rate))
 
     return roperands
 
 
 def _translate_ioperands(name, filename, ioperands, defined_operands):
     """
 
@@ -417,57 +380,50 @@
 
         operand_name, io_def = value
         try:
             operand = defined_operands[operand_name]
         except KeyError:
             raise MicroprobeArchitectureDefinitionError(
                 "Unknown operand name '%s' in definition "
-                "of instruction '%s' in filename '%s'" % (
-                    operand_name, name, filename
-                )
-            )
+                "of instruction '%s' in filename '%s'" %
+                (operand_name, name, filename))
 
         try:
             if operand.constant:
                 reg = operand.random_value()
             else:
                 reg = [
                     value for value in operand.values()
                     if value.name == regname
                 ][0]
         except IndexError:
             raise MicroprobeArchitectureDefinitionError(
                 "Unknown constant register value '%s' in definition "
-                "of instruction '%s' in filename '%s'" % (
-                    regname, name, filename
-                )
-            )
+                "of instruction '%s' in filename '%s'" %
+                (regname, name, filename))
 
         try:
             operand = defined_operands[reg.name]
         except KeyError:
-            operand = OperandConstReg(
-                "ConstantReg-%s" % reg.name, "Constant register %s" % reg.name,
-                reg, False, False, False, False
-            )
+            operand = OperandConstReg("ConstantReg-%s" % reg.name,
+                                      "Constant register %s" % reg.name, reg,
+                                      False, False, False, False)
             LOG.debug("Operand added: %s", operand)
             defined_operands[reg.name] = operand
 
         if not operand.constant:
             raise MicroprobeArchitectureDefinitionError(
                 "Implicit operand defined but it is not constant in"
                 " definition of instruction '%s' in filename '%s'" %
-                (name, filename)
-            )
+                (name, filename))
 
         # TODO: This can be improved, we can recycle operand
         # descriptors if operand and I/O are the same
-        roperands[regname] = OperandDescriptor(
-            operand, "I" in io_def, "O" in io_def
-        )
+        roperands[regname] = OperandDescriptor(operand, "I" in io_def, "O"
+                                               in io_def)
 
     return roperands
 
 
 def _merge_operands(name, filename, loperands, iformat, defined_operands):
     """
 
@@ -491,40 +447,37 @@
 
     for operand_description in loperands.values():
         operand_name, field_name, field_io = operand_description
 
         if field_name not in roperands:
 
             field_names = [
-                field
-                for field in roperands.keys()
+                field for field in roperands.keys()
                 if field.split("_")[0] == field_name
                 # if field.startswith(field_name)
             ]
 
             if len(field_names) == 0:
                 LOG.debug("Fields: %s", roperands.keys())
                 raise MicroprobeArchitectureDefinitionError(
                     "Unknown instruction field '%s' in instruction definition"
-                    " '%s' found in '%s'" % (field_name, name, filename)
-                )
+                    " '%s' found in '%s'" % (field_name, name, filename))
             elif len(field_names) > 1:
                 raise MicroprobeArchitectureDefinitionError(
                     "Multiple matches for instruction field '%s' in "
                     "instruction definition"
                     " '%s' found in '%s'. Candidates: %s" %
                     (field_name, name, filename, field_names))
             else:
                 field_name = field_names[0]
 
         # Fix names referring to original operands
         if operand_name.startswith("@ORIG@"):
-            operand_name = operand_name.replace(
-                "@ORIG@", roperands[field_name][0].name
-            )
+            operand_name = operand_name.replace("@ORIG@",
+                                                roperands[field_name][0].name)
 
         try:
             operand = defined_operands[operand_name]
 
         except KeyError:
 
             # Try for a constant
@@ -532,34 +485,30 @@
 
             try:
                 constant_value = int(operand_name, 0)
             except ValueError:
                 constant_value = None
 
             if constant_value is not None:
-                operand = OperandConst(
-                    "Constant-%s" % operand_name,
-                    "Constant value %s" % operand_name, constant_value
-                )
+                operand = OperandConst("Constant-%s" % operand_name,
+                                       "Constant value %s" % operand_name,
+                                       constant_value)
                 defined_operands[operand_name] = operand
                 LOG.debug("Operand added: %s", operand)
             else:
                 raise MicroprobeArchitectureDefinitionError(
                     "Unknown instruction operand '%s' in "
                     "instruction definition '%s' found in '%s'" %
-                    (operand_name, name, filename)
-                )
+                    (operand_name, name, filename))
 
         if field_name in fields_processed:
             raise MicroprobeArchitectureDefinitionError(
                 "Field '%s' processed twice. Check definition"
-                " instruction '%s' in file '%s'" % (
-                    field_name, name, filename
-                )
-            )
+                " instruction '%s' in file '%s'" %
+                (field_name, name, filename))
 
         roperands[field_name] = [operand, field_io]
         fields_processed.append(field_name)
 
     return roperands
 
 
@@ -584,16 +533,15 @@
         :param context:
 
         """
 
         if context.register_has_value(value):
 
             registers = [
-                register
-                for register in context.registers_get_value(value)
+                register for register in context.registers_get_value(value)
                 if register in context.reserved_registers
             ]
 
             for register in operand.type.values():
                 if register not in registers:
                     return True
 
@@ -626,38 +574,35 @@
         :param building_block:
 
         """
 
         assert operand.is_input and not operand.is_output
 
         registers = [
-            reg
-            for reg in valid_values
-            if reg in building_block.context.reserved_registers and
-            building_block.context.get_register_value(reg) != value
+            reg for reg in valid_values
+            if reg in building_block.context.reserved_registers
+            and building_block.context.get_register_value(reg) != value
         ]
 
         if len(registers) == 0:
 
             valid_registers = [
-                reg
-                for reg in valid_values
+                reg for reg in valid_values
                 if reg not in building_block.context.reserved_registers
             ]
 
             assert len(valid_registers) > 0
             register = valid_registers[0]
 
             random_value = value
             while random_value == value:
                 random_value = random.randint(0, (2**(register.type.size - 1)))
 
-            instructions = target.set_register(
-                register, random_value, building_block.context
-            )
+            instructions = target.set_register(register, random_value,
+                                               building_block.context)
 
             building_block.context.add_reserved_registers([register])
             building_block.context.set_register_value(register, random_value)
             building_block.add_init(instructions)
             registers = [register]
 
         new_descriptor_operand = operand.descriptor.copy()
@@ -675,25 +620,23 @@
         :param building_block:
 
         """
 
         if not building_block.context.register_has_value(value):
 
             valid_registers = [
-                reg
-                for reg in valid_values
+                reg for reg in valid_values
                 if reg not in building_block.context.reserved_registers
             ]
 
             assert len(valid_registers) > 0
             register = valid_registers[0]
 
-            instructions = target.set_register(
-                register, value, building_block.context
-            )
+            instructions = target.set_register(register, value,
+                                               building_block.context)
 
             building_block.context.add_reserved_registers([register])
             building_block.context.set_register_value(register, value)
             building_block.add_init(instructions)
 
         registers = [
             register
@@ -707,22 +650,20 @@
         new_type_operand.set_valid_values(registers)
 
         new_descriptor_operand.set_type(new_type_operand)
         operand.set_descriptor(new_descriptor_operand)
 
     if condition is False:
 
-        instruction.register_context_callback(
-            key, checking_function_false, fixing_function_false
-        )
+        instruction.register_context_callback(key, checking_function_false,
+                                              fixing_function_false)
     else:
 
-        instruction.register_context_callback(
-            key, checking_function_true, fixing_function_true
-        )
+        instruction.register_context_callback(key, checking_function_true,
+                                              fixing_function_true)
 
 
 def _check_reg_bit_value(instruction, register_name, bit, value, condition):
     """
 
     :param instruction:
     :param register_name:
@@ -774,32 +715,29 @@
 
         :param target:
         :param building_block:
 
         """
 
         register = target.registers[register_name]
-        instructions = target.set_register_bits(
-            register, value, mask, shift, building_block.context
-        )
+        instructions = target.set_register_bits(register, value, mask, shift,
+                                                building_block.context)
 
         if register not in building_block.context.reserved_registers:
             building_block.context.add_reserved_registers([register])
 
         building_block.context.set_register_value(register, cannary_value)
         building_block.add_init(instructions)
 
-    instruction.register_context_callback(
-        key, checking_function, fixing_function
-    )
+    instruction.register_context_callback(key, checking_function,
+                                          fixing_function)
 
 
-def _check_operands(
-    instruction, operand1_name, operand2_name, check_type, condition
-):
+def _check_operands(instruction, operand1_name, operand2_name, check_type,
+                    condition):
     """
 
     :param instruction:
     :param operand1_name:
     :param operand2_name:
     :param check_type:
     :param condition:
@@ -843,42 +781,34 @@
 
             previous_values = list(new_type_operand2.values())
 
             if condition:
                 new_type_operand2.set_valid_values([value])
                 assert list(new_type_operand2.values()) == [value]
             else:
-                new_type_operand2.set_valid_values(
-                    [
-                        elem
-                        for elem in orig_descriptor_operand2.type.values(
-                        ) if elem != value
-                    ]
-                )
+                new_type_operand2.set_valid_values([
+                    elem for elem in orig_descriptor_operand2.type.values()
+                    if elem != value
+                ])
 
             # LOG.debug("Orig operand 2 values: %s",
             #          orig_descriptor_operand2.type.values())
             # LOG.debug("New operand 2 values: %s", new_type_operand2.values())
 
             LOG.debug(
                 "Removed from orig: %s",
                 set(orig_descriptor_operand2.type.values()) -
-                set(new_type_operand2.values())
-            )
+                set(new_type_operand2.values()))
 
-            LOG.debug(
-                "Removed from previous: %s",
-                set(previous_values) - set(new_type_operand2.values())
-            )
+            LOG.debug("Removed from previous: %s",
+                      set(previous_values) - set(new_type_operand2.values()))
 
             assert len(
-                set(new_type_operand2.values()) - set(
-                    orig_descriptor_operand2.type.values()
-                )
-            ) == 0
+                set(new_type_operand2.values()) -
+                set(orig_descriptor_operand2.type.values())) == 0
 
         def function_set_operand2(value):
             """
 
             :param value:
 
             """
@@ -895,100 +825,78 @@
             LOG.debug("Setting operand 2 to: %s", value)
 
             previous_values = list(new_type_operand1.values())
 
             if condition:
                 new_type_operand1.set_valid_values([value])
             else:
-                new_type_operand1.set_valid_values(
-                    [
-                        elem
-                        for elem in orig_descriptor_operand1.type.values(
-                        ) if elem != value
-                    ]
-                )
+                new_type_operand1.set_valid_values([
+                    elem for elem in orig_descriptor_operand1.type.values()
+                    if elem != value
+                ])
 
             # LOG.debug("Orig operand 1 values: %s",
             #          orig_descriptor_operand1.type.values())
             # LOG.debug("New operand 1 values: %s", new_type_operand1.values())
 
             LOG.debug(
                 "Removed from orig: %s",
                 set(orig_descriptor_operand1.type.values()) -
-                set(new_type_operand1.values())
-            )
+                set(new_type_operand1.values()))
 
-            LOG.debug(
-                "Removed from previous: %s",
-                set(previous_values) - set(new_type_operand1.values())
-            )
+            LOG.debug("Removed from previous: %s",
+                      set(previous_values) - set(new_type_operand1.values()))
 
             assert len(
-                set(new_type_operand1.values()) - set(
-                    orig_descriptor_operand1.type.values()
-                )
-            ) == 0
+                set(new_type_operand1.values()) -
+                set(orig_descriptor_operand1.type.values())) == 0
 
         def function_unset_operand1():
             """ """
             operand2.set_descriptor(orig_descriptor_operand2)
 
         def function_unset_operand2():
             """ """
             operand1.set_descriptor(orig_descriptor_operand1)
 
-        operand1.register_operand_callbacks(
-            function_set_operand1, function_unset_operand1
-        )
-
-        operand2.register_operand_callbacks(
-            function_set_operand2, function_unset_operand2
-        )
+        operand1.register_operand_callbacks(function_set_operand1,
+                                            function_unset_operand1)
+
+        operand2.register_operand_callbacks(function_set_operand2,
+                                            function_unset_operand2)
     elif check_type == "less":
 
         new_base_descriptor_operand1 = operand1.descriptor.copy()
         new_base_type_operand1 = new_base_descriptor_operand1.type.copy()
 
         new_base_descriptor_operand2 = operand2.descriptor.copy()
         new_base_type_operand2 = new_base_descriptor_operand2.type.copy()
 
         # first remove the maximum value of operand1, so that it is never used
         # and also remove the minimum value of operand2, so that it is never
         # used
         operand1.set_descriptor(new_base_descriptor_operand1)
         new_base_descriptor_operand1.set_type(new_base_type_operand1)
-        new_base_type_operand1.set_valid_values(
-            [
-                elem
-                for elem in orig_descriptor_operand1.type.values()
-                if len(
-                    [
-                        value for value in
-                        orig_descriptor_operand2.type.values() if value > elem
-                    ]
-                ) > 0
-            ]
-        )
+        new_base_type_operand1.set_valid_values([
+            elem for elem in orig_descriptor_operand1.type.values() if len([
+                value for value in orig_descriptor_operand2.type.values()
+                if value > elem
+            ]) > 0
+        ])
 
         orig_descriptor_operand1 = operand1.descriptor
 
         operand2.set_descriptor(new_base_descriptor_operand2)
         new_base_descriptor_operand2.set_type(new_base_type_operand2)
-        new_base_type_operand2.set_valid_values(
-            [
-                elem
-                for elem in orig_descriptor_operand2.type.values()
-                if len(
-                    [
-                        value for value in
-                        orig_descriptor_operand1.type.values() if value < elem
-                    ]
-                ) > 0
-            ]
-        )
+        new_base_type_operand2.set_valid_values([
+            elem for elem in orig_descriptor_operand2.type.values() if len([
+                value for value in orig_descriptor_operand1.type.values()
+                if value < elem
+            ]) > 0
+        ])
 
         orig_descriptor_operand2 = operand2.descriptor
 
         # print(operand1_name)
         # print(orig_descriptor_operand1.type.values())
 
         # print(operand2_name)
@@ -1012,27 +920,23 @@
             new_type_operand2 = new_descriptor_operand2.type.copy()
 
             operand2.set_descriptor(new_descriptor_operand2)
             new_descriptor_operand2.set_type(new_type_operand2)
 
             previous_values = set(new_type_operand2.values())
 
-            new_type_operand2.set_valid_values(
-                [
-                    elem
-                    for elem in orig_descriptor_operand2.type.values(
-                    ) if elem > value
-                ]
-            )
+            new_type_operand2.set_valid_values([
+                elem for elem in orig_descriptor_operand2.type.values()
+                if elem > value
+            ])
 
             new_values = set(new_type_operand2.values())
 
-            LOG.debug(
-                "Operand '%s' values: %s", operand2_name, previous_values
-            )
+            LOG.debug("Operand '%s' values: %s", operand2_name,
+                      previous_values)
             LOG.debug("Operand '%s' new values: %s", operand2_name, new_values)
             LOG.debug("Operand differences: %s", previous_values - new_values)
 
         def function_set_operand2(value):
             """
 
             :param value:
@@ -1050,51 +954,44 @@
             new_type_operand1 = new_descriptor_operand1.type.copy()
 
             operand1.set_descriptor(new_descriptor_operand1)
             new_descriptor_operand1.set_type(new_type_operand1)
 
             previous_values = set(new_type_operand1.values())
 
-            new_type_operand1.set_valid_values(
-                [
-                    elem
-                    for elem in orig_descriptor_operand1.type.values(
-                    ) if elem < value
-                ]
-            )
+            new_type_operand1.set_valid_values([
+                elem for elem in orig_descriptor_operand1.type.values()
+                if elem < value
+            ])
 
             new_values = set(new_type_operand1.values())
 
-            LOG.debug(
-                "Operand '%s' values: %s", operand1_name, previous_values
-            )
+            LOG.debug("Operand '%s' values: %s", operand1_name,
+                      previous_values)
             LOG.debug("Operand '%s' new values: %s", operand1_name, new_values)
             LOG.debug("Operand differences: %s", previous_values - new_values)
 
         def function_unset_operand1():
             """ """
             operand2.set_descriptor(orig_descriptor_operand2)
 
         def function_unset_operand2():
             """ """
             operand1.set_descriptor(orig_descriptor_operand1)
 
-        operand1.register_operand_callbacks(
-            function_set_operand1, function_unset_operand1
-        )
-
-        operand2.register_operand_callbacks(
-            function_set_operand2, function_unset_operand2
-        )
+        operand1.register_operand_callbacks(function_set_operand1,
+                                            function_unset_operand1)
+
+        operand2.register_operand_callbacks(function_set_operand2,
+                                            function_unset_operand2)
 
     else:
 
-        raise NotImplementedError(
-            "Condition '%s' not implemented" % check_type
-        )
+        raise NotImplementedError("Condition '%s' not implemented" %
+                                  check_type)
 
 
 def _check_memops_overlap(instruction, overlap_type, condition):
     """
 
     :param instruction:
     :param overlap_type:
@@ -1105,21 +1002,19 @@
     assert len(instruction.memory_operands()) == 2, "Memory operands overlap" \
                                                     " check requires 2 memory"\
                                                     " operands"
     operand1 = instruction.memory_operands()[0]
     operand2 = instruction.memory_operands()[1]
 
     def function_unset_operand1():
-        """ """
         operand2.unset_possible_addresses()
         operand2.unset_possible_lengths()
         operand2.unset_forbidden_address_range()
 
     def function_unset_operand2():
-        """ """
         operand1.unset_possible_addresses()
         operand1.unset_possible_lengths()
         operand1.unset_forbidden_address_range()
 
     def function_set_operand1_address(address, context):
         """
 
@@ -1174,57 +1069,49 @@
             """
 
             possible_address1 = operand1.address + operand1.length - 1
             possible_address2 = operand1.address - operand1.length + 1
 
             if condition is True:
                 operand2.set_possible_addresses(
-                    [
-                        possible_address1, possible_address2
-                    ], context
-                )
+                    [possible_address1, possible_address2], context)
                 operand2.set_possible_lengths([operand1.length], context)
             else:
-                operand2.set_forbidden_address_range(
-                    possible_address1,
-                    possible_address2,
-                    context)
+                operand2.set_forbidden_address_range(possible_address1,
+                                                     possible_address2,
+                                                     context)
 
         def function_set_operand2(context):
             """
 
             :param context:
 
             """
 
             possible_address1 = operand2.address + operand2.length - 1
             possible_address2 = operand2.address - operand2.length + 1
 
             if condition is True:
                 operand1.set_possible_addresses(
-                    [
-                        possible_address1, possible_address2
-                    ], context
-                )
+                    [possible_address1, possible_address2], context)
                 operand1.set_possible_lengths([operand2.length], context)
             else:
-                operand1.set_forbidden_address_range(
-                    possible_address1,
-                    possible_address2,
-                    context)
-
-        operand1.register_mem_operand_callback(
-            function_set_operand1_address, function_set_operand1_length,
-            function_unset_operand1, function_unset_operand1
-        )
-
-        operand2.register_mem_operand_callback(
-            function_set_operand2_address, function_set_operand2_length,
-            function_unset_operand2, function_unset_operand2
-        )
+                operand1.set_forbidden_address_range(possible_address1,
+                                                     possible_address2,
+                                                     context)
+
+        operand1.register_mem_operand_callback(function_set_operand1_address,
+                                               function_set_operand1_length,
+                                               function_unset_operand1,
+                                               function_unset_operand1)
+
+        operand2.register_mem_operand_callback(function_set_operand2_address,
+                                               function_set_operand2_length,
+                                               function_unset_operand2,
+                                               function_unset_operand2)
 
     elif overlap_type == "8_bytes_destructive":
 
         def function_set_operand1(context):
             """
 
             :param context:
@@ -1232,18 +1119,15 @@
             """
 
             possible_address1 = operand1.address + operand1.length - 8
             possible_address2 = operand1.address - operand1.length + 8
 
             if condition is True:
                 operand2.set_possible_addresses(
-                    [
-                        possible_address1, possible_address2
-                    ], context
-                )
+                    [possible_address1, possible_address2], context)
                 operand2.set_possible_lengths([operand1.length], context)
             else:
                 raise NotImplementedError
 
         def function_set_operand2(context):
             """
 
@@ -1252,31 +1136,28 @@
             """
 
             possible_address1 = operand2.address + operand2.length - 8
             possible_address2 = operand2.address - operand2.length + 8
 
             if condition is True:
                 operand1.set_possible_addresses(
-                    [
-                        possible_address1, possible_address2
-                    ], context
-                )
+                    [possible_address1, possible_address2], context)
                 operand1.set_possible_lengths([operand2.length], context)
             else:
                 raise NotImplementedError
 
-        operand1.register_mem_operand_callback(
-            function_set_operand1_address, function_set_operand1_length,
-            function_unset_operand1, function_unset_operand1
-        )
-
-        operand2.register_mem_operand_callback(
-            function_set_operand2_address, function_set_operand2_length,
-            function_unset_operand2, function_unset_operand2
-        )
+        operand1.register_mem_operand_callback(function_set_operand1_address,
+                                               function_set_operand1_length,
+                                               function_unset_operand1,
+                                               function_unset_operand1)
+
+        operand2.register_mem_operand_callback(function_set_operand2_address,
+                                               function_set_operand2_length,
+                                               function_unset_operand2,
+                                               function_unset_operand2)
 
     elif overlap_type == "destructive_any" or \
             overlap_type == "destructive_any_or_exact" or \
             overlap_type == "destructive_any_not_exact":
 
         def function_set_operand1(context):
             """
@@ -1286,32 +1167,27 @@
             """
 
             min_address = operand1.address
             max_address = operand1.address + operand1.length - 1
             assert max_address >= min_address
 
             if condition is False:
-                operand2.set_forbidden_address_range(
-                    min_address, max_address, context
-                )
+                operand2.set_forbidden_address_range(min_address, max_address,
+                                                     context)
             else:
 
                 alignment = operand2.alignment()
                 if alignment is None:
                     alignment = 1
 
                 addresses = [
-                    operand1.address +
-                    index for index in range(
-                        max_address -
-                        min_address +
-                        1) if (
-                        operand1.address +
-                        index).displacement %
-                    alignment == 0]
+                    operand1.address + index
+                    for index in range(max_address - min_address + 1)
+                    if (operand1.address + index).displacement % alignment == 0
+                ]
 
                 if len(addresses) == 0:
                     raise NotImplementedError
 
                 operand2.set_possible_addresses(addresses, context)
 
         def function_set_operand2(context):
@@ -1322,47 +1198,42 @@
             """
 
             min_address = operand2.address
             max_address = operand2.address + operand2.length - 1
             assert max_address >= min_address
 
             if condition is False:
-                operand1.set_forbidden_address_range(
-                    min_address, max_address, context
-                )
+                operand1.set_forbidden_address_range(min_address, max_address,
+                                                     context)
             else:
 
                 alignment = operand2.alignment()
                 if alignment is None:
                     alignment = 1
 
                 addresses = [
-                    operand2.address +
-                    index for index in range(
-                        max_address -
-                        min_address +
-                        1) if (
-                        operand2.address +
-                        index).displacement %
-                    alignment == 0]
+                    operand2.address + index
+                    for index in range(max_address - min_address + 1)
+                    if (operand2.address + index).displacement % alignment == 0
+                ]
 
                 if len(addresses) == 0:
                     raise NotImplementedError
 
                 operand1.set_possible_addresses(addresses, context)
 
-        operand1.register_mem_operand_callback(
-            function_set_operand1_address, function_set_operand1_length,
-            function_unset_operand1, function_unset_operand1
-        )
-
-        operand2.register_mem_operand_callback(
-            function_set_operand2_address, function_set_operand2_length,
-            function_unset_operand2, function_unset_operand2
-        )
+        operand1.register_mem_operand_callback(function_set_operand1_address,
+                                               function_set_operand1_length,
+                                               function_unset_operand1,
+                                               function_unset_operand1)
+
+        operand2.register_mem_operand_callback(function_set_operand2_address,
+                                               function_set_operand2_length,
+                                               function_unset_operand2,
+                                               function_unset_operand2)
 
     elif overlap_type == "exact":
 
         def function_set_operand1(context):
             """
 
             :param context:
@@ -1388,23 +1259,23 @@
 
             if condition is True:
                 operand1.set_possible_addresses([possible_address], context)
                 operand1.set_possible_lengths([operand2.length], context)
             else:
                 raise NotImplementedError
 
-        operand1.register_mem_operand_callback(
-            function_set_operand1_address, function_set_operand1_length,
-            function_unset_operand1, function_unset_operand1
-        )
-
-        operand2.register_mem_operand_callback(
-            function_set_operand2_address, function_set_operand2_length,
-            function_unset_operand2, function_unset_operand2
-        )
+        operand1.register_mem_operand_callback(function_set_operand1_address,
+                                               function_set_operand1_length,
+                                               function_unset_operand1,
+                                               function_unset_operand1)
+
+        operand2.register_mem_operand_callback(function_set_operand2_address,
+                                               function_set_operand2_length,
+                                               function_unset_operand2,
+                                               function_unset_operand2)
 
     else:
         # print(overlap_type, condition)
         raise NotImplementedError
 
 
 def _check_alignment(instruction, operand_idx, alignment):
@@ -1421,85 +1292,81 @@
         % operand_idx
 
     operand = instruction.memory_operands()[operand_idx]
     operand.set_alignment(alignment)
 
 
 GENERIC_INSTRUCTION_CHECKS = {}
-for _key, _value in dict(
-    getmembers(
-        sys.modules[__name__], isfunction
-    )
-).items():
+for _key, _value in dict(getmembers(sys.modules[__name__],
+                                    isfunction)).items():
     if _key.startswith("_check_"):
         GENERIC_INSTRUCTION_CHECKS[_key[1:]] = _value
 
 
 # Classes
 class InstructionType(six.with_metaclass(abc.ABCMeta, PropertyHolder)):
     """Abstract class to represent a machine instruction type."""
 
     @abc.abstractmethod
     def __init__(self):
-        """ """
         pass
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def name(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def description(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def mnemonic(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def opcode(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def format(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def operands(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def memory_operand_descriptors(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def operand_descriptors(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def implicit_operands(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def target_checks(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def instruction_checks(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def sets(self, *args):
         """Returns a :class:`~.list` of :class:`~.Register` instances
         set by this :class:`~.InstructionType` when invoked with *args*
         :class:`~.list` of :class:`~.Operand`.
@@ -1562,18 +1429,16 @@
     :param idescr: Instruction description
     :type idescr: :class:`~.str`
     :param iformat: Instruction format
     :type iformat: :class:`~.InstructionFormat`
 
     """
 
-    def __init__(
-        self, name, mnemonic, opcode, descr, iformat, operands, ioperands,
-        moperands, instruction_checks, target_checks
-    ):
+    def __init__(self, name, mnemonic, opcode, descr, iformat, operands,
+                 ioperands, moperands, instruction_checks, target_checks):
         """
 
         :param name:
         :param mnemonic:
         :param opcode:
         :param descr:
         :param iformat:
@@ -1600,82 +1465,74 @@
         self._mask = None
 
         for key in [field.name for field in iformat.fields]:
             if key not in operands:
                 raise MicroprobeArchitectureDefinitionError(
                     "Inconsistent instruction definition. "
                     "Each instruction field should have an operand. "
-                    "Instruction: %s", self.name
-                )
+                    "Instruction: %s", self.name)
             else:
                 # Sort the operands
                 tmp_val = self.operands[key]
                 del self.operands[key]
                 self.operands[key] = tmp_val
 
         if list(self.operands.keys()) != [
-                field.name for field in iformat.fields]:
+                field.name for field in iformat.fields
+        ]:
             LOG.error("Operands: %s", list(self.operands.keys()))
             LOG.error("Fields: %s", [field.name for field in iformat.fields])
             LOG.error("Instruction format: %s", iformat.name)
             # print(self.operands.keys())
             # print([field.name for field in iformat.fields])
-            raise MicroprobeArchitectureDefinitionError(
-                "Operands and fields "
-                "are not aligned in "
-                "'%s'" % self.name
-            )
+            raise MicroprobeArchitectureDefinitionError("Operands and fields "
+                                                        "are not aligned in "
+                                                        "'%s'" % self.name)
 
         self._operand_descriptors = OrderedDict()
-        for op_descriptor, field in zip(
-            list(self.operands.items()), self.format.fields
-        ):
+        for op_descriptor, field in zip(list(self.operands.items()),
+                                        self.format.fields):
             fieldname, op_descriptor = op_descriptor
             operand, io_def = op_descriptor
 
             if field.name != fieldname:
                 raise MicroprobeArchitectureDefinitionError(
-                    "Operands and fields are not aligned in '%s" % self.name
-                )
+                    "Operands and fields are not aligned in '%s" % self.name)
 
             if not field.default_show:
                 continue
 
             # if operand.constant:  # and operand.immediate:
             #     continue
 
             self._operand_descriptors[field.name] = OperandDescriptor(
-                operand, "I" in io_def, "O" in io_def
-            )
+                operand, "I" in io_def, "O" in io_def)
 
         opcode_operands = [op for op in operands if op.startswith('opcode')]
 
         if len(opcode_operands) == 1:
             self.operands[opcode_operands[0]][0] = OperandConst(
-                "Opcode", "Instruction opcode", int(self.opcode, 16)
-            )
+                "Opcode", "Instruction opcode", int(self.opcode, 16))
         else:
             # Assume the back-end will take care of multiple operands
             pass
 
         self._hash = int(hashlib.sha512(str(self).encode()).hexdigest(), 16)
 
     def _compute_mask(self):
 
         mask_val_str = "0b"
         mask_str = "0b"
-        for op_descriptor, field in zip(
-            list(self.operands.items()), self.format.fields
-        ):
+        for op_descriptor, field in zip(list(self.operands.items()),
+                                        self.format.fields):
             dummy_fieldname, op_descriptor = op_descriptor
             format_str = "{0:0%db}" % field.size
 
             if op_descriptor[0].constant and op_descriptor[
-                0
-            ].immediate and not field.default_show:
+                    0].immediate and not field.default_show:
 
                 mask_val_str = mask_val_str + \
                     format_str.format(list(op_descriptor[0].values())[0])
                 mask_str = mask_str + "".join(['1'] * field.size)
             elif op_descriptor[0].constant and not op_descriptor[0].immediate:
 
                 mask_val_str = mask_val_str + \
@@ -1685,85 +1542,71 @@
                 mask_str = mask_str + "".join(['1'] * field.size)
             else:
 
                 mask_val_str = mask_val_str + format_str.format(0)
                 mask_str = mask_str + "".join(['0'] * field.size)
 
         assert len(mask_val_str) == self.format.length * 8 + 2, "%s != %s" % (
-            len(mask_val_str), self.format.length * 8 + 2
-        )
+            len(mask_val_str), self.format.length * 8 + 2)
         mask_val = int(mask_val_str, 2)
 
         assert len(mask_str) == self.format.length * 8 + 2, "%s != %s" % (
-            len(mask_str), self.format.length * 8 + 2
-        )
+            len(mask_str), self.format.length * 8 + 2)
         mask = int(mask_str, 2)
 
         assert mask != 0
 
         self._mask = (mask, mask_val)
 
     @property
     def name(self):
-        """ """
         return self._name
 
     @property
     def mnemonic(self):
-        """ """
         return self._mnemonic
 
     @property
     def description(self):
-        """ """
         return self._descr
 
     @property
     def opcode(self):
-        """ """
         return self._opcode
 
     @property
     def operands(self):
-        """ """
         return self._operands
 
     @property
     def memory_operand_descriptors(self):
-        """ """
         return self._memoperands
 
     @property
     def operand_descriptors(self):
-        """ """
         return self._operand_descriptors
 
     @property
     def implicit_operands(self):
-        """ """
         return self._ioperands
 
     @property
     def format(self):
-        """ """
         return self._format
 
     @property
     def instruction_checks(self):
-        """ """
         return self._instruction_checks
 
     @property
     def target_checks(self):
-        """ """
         return self._target_checks
 
     @property
     def bit_mask(self):
-        """ """
         if self._mask is None:
             self._compute_mask()
         return self._mask
 
     def sets(self, *args):
         """Returns a :class:`~.list` of :class:`~.Register` instances
         set by this :class:`~.InstructionType` when invoked with *args*
@@ -1804,26 +1647,24 @@
 
         next_operand_value = getnextf(iter(args))
         format_str = self.format.assembly_format
 
         LOG.debug("Assembly string: %s", format_str)
         assembly_str = format_str.replace("OPC", "@@@")
 
-        for op_descriptor, field in zip(
-            list(self.operands.items()), self.format.fields
-        ):
+        for op_descriptor, field in zip(list(self.operands.items()),
+                                        self.format.fields):
             fieldname, op_descriptor = op_descriptor
             operand, dummy = op_descriptor
 
             LOG.debug("Field: %s", fieldname)
 
             if field.name != fieldname:
                 raise MicroprobeArchitectureDefinitionError(
-                    "Operands and fields are not aligned in '%s" % self.name
-                )
+                    "Operands and fields are not aligned in '%s" % self.name)
 
             if not field.default_show:
                 LOG.debug("Skip not shown")
                 continue
 
             if field.name in dissabled_fields:
                 LOG.debug("Skip dissabled")
@@ -1832,126 +1673,111 @@
 
             if operand.constant:
 
                 LOG.debug("Constant")
 
                 if operand.name == "Zero":  # Operand Zero never shows
                     assembly_str = assembly_str.replace(
-                        " %s," % field.name, ""
-                    )
+                        " %s," % field.name, "")
                     assembly_str = assembly_str.replace(
-                        ", %s" % field.name, ""
-                    )
+                        ", %s" % field.name, "")
                     assembly_str = assembly_str.replace("%s" % field.name, "")
                     assembly_str = assembly_str.replace("()", "")
                 else:
                     assembly_str = assembly_str.replace(
-                        field.name, next_operand_value().representation
-                    )
+                        field.name,
+                        next_operand_value().representation)
                     # operand.representation(operand.values()[0])
             else:
 
                 LOG.debug("No constant value")
 
                 if assembly_str.find("@@@ " + field.name + ",") >= 0:
 
                     assembly_str = assembly_str.replace(
                         "@@@ " + field.name + ",",
-                        "@@@ " + next_operand_value().representation + ",", 1
-                    )
+                        "@@@ " + next_operand_value().representation + ",", 1)
 
                 elif assembly_str.find(", " + field.name + ",") >= 0:
 
                     assembly_str = assembly_str.replace(
                         ", " + field.name + ",",
-                        ", " + next_operand_value().representation + ",", 1
-                    )
+                        ", " + next_operand_value().representation + ",", 1)
 
                 elif assembly_str.endswith(", " + field.name):
 
                     assembly_str = assembly_str.replace(
                         ", " + field.name,
-                        ", " + next_operand_value().representation, 1
-                    )
+                        ", " + next_operand_value().representation, 1)
 
                 elif assembly_str.find("@@@ $" + field.name + ",") >= 0:
 
                     assembly_str = assembly_str.replace(
                         "@@@ $" + field.name + ",",
-                        "@@@ $" + next_operand_value().representation + ",", 1
-                    )
+                        "@@@ $" + next_operand_value().representation + ",", 1)
 
                 elif assembly_str.find(", $" + field.name + ",") >= 0:
 
                     assembly_str = assembly_str.replace(
                         ", $" + field.name + ",",
-                        ", $" + next_operand_value().representation + ",", 1
-                    )
+                        ", $" + next_operand_value().representation + ",", 1)
 
                 elif assembly_str.endswith(", $" + field.name):
 
                     assembly_str = assembly_str.replace(
                         ", $" + field.name,
-                        ", $" + next_operand_value().representation, 1
-                    )
+                        ", $" + next_operand_value().representation, 1)
 
                 elif assembly_str.find("@@@ " + field.name) >= 0:
 
                     assembly_str = assembly_str.replace(
                         "@@@ " + field.name,
-                        "@@@ " + next_operand_value().representation, 1
-                    )
+                        "@@@ " + next_operand_value().representation, 1)
 
                 elif assembly_str.find("(" + field.name + ")") >= 0:
 
                     assembly_str = assembly_str.replace(
                         "(" + field.name + ")",
-                        "(" + next_operand_value().representation + ")", 1
-                    )
+                        "(" + next_operand_value().representation + ")", 1)
 
                 elif assembly_str.find("(" + field.name + ",") >= 0:
 
                     assembly_str = assembly_str.replace(
                         "(" + field.name + ",",
-                        "(" + next_operand_value().representation + ",", 1
-                    )
+                        "(" + next_operand_value().representation + ",", 1)
 
                 elif assembly_str.find(" " + field.name + ")") >= 0:
 
                     assembly_str = assembly_str.replace(
                         " " + field.name + ")",
-                        " " + next_operand_value().representation + ")", 1
-                    )
+                        " " + next_operand_value().representation + ")", 1)
 
                 elif assembly_str.find(" " + field.name + "(") >= 0:
 
                     assembly_str = assembly_str.replace(
                         " " + field.name + "(",
-                        " " + next_operand_value().representation + "(", 1
-                    )
+                        " " + next_operand_value().representation + "(", 1)
 
                 elif assembly_str.find("," + field.name + ")") >= 0:
 
                     assembly_str = assembly_str.replace(
                         "," + field.name + ")",
-                        "," + next_operand_value().representation + ")", 1
-                    )
+                        "," + next_operand_value().representation + ")", 1)
 
                 else:
                     LOG.debug(
-                        "%s", list(zip(
-                            list(self.operands.items()), self.format.fields
-                        ))
-                    )
+                        "%s",
+                        list(
+                            zip(list(self.operands.items()),
+                                self.format.fields)))
                     LOG.debug("Current assembly: %s", assembly_str)
 
                     raise MicroprobeArchitectureDefinitionError(
                         "Unable to generate correct assembly for '%s' "
-                        "instruction" % self.mnemonic
-                    )
+                        "instruction" % self.mnemonic)
 
             LOG.debug("Current assembly: %s", assembly_str)
 
         assembly_str = assembly_str.replace("@@@", self.mnemonic)
 
         LOG.debug("End assembly: %s", assembly_str)
 
@@ -1972,29 +1798,27 @@
 
         if asm_args is None:
             asm_args = args
 
         LOG.debug("Start codification: %s", self.assembly(asm_args))
         LOG.debug("Args: %s", args)
 
-        for op_descriptor, field in zip(
-            list(self.operands.items()), self.format.fields
-        ):
+        for op_descriptor, field in zip(list(self.operands.items()),
+                                        self.format.fields):
 
             fieldname, op_descriptor = op_descriptor
             operand, dummy = op_descriptor
 
             LOG.debug("Field: %s", fieldname)
             LOG.debug("Descriptor: %s", op_descriptor)
             LOG.debug("Operand: %s", operand)
 
             if field.name != fieldname:
                 raise MicroprobeArchitectureDefinitionError(
-                    "Operands and fields are not aligned in '%s" % self.name
-                )
+                    "Operands and fields are not aligned in '%s" % self.name)
 
             format_field_str = "{0:0%db}" % field.size
             field_length += field.size
 
             if operand.constant and not field.default_show:
 
                 LOG.debug("Operand is constant")
@@ -2024,34 +1848,32 @@
                 LOG.debug("Field size: %d", field.size)
                 LOG.debug("Max value codificable: %d", 2**field.size)
                 LOG.debug("Operand value: %s", opvalue)
                 LOG.debug("Instruction name: %s", self.name)
 
                 raise MicroprobeArchitectureDefinitionError(
                     "Operand value can not be codified within the "
-                    "instruction field. Operand: %s Value: %d"
-                    % (operand, opvalue)
-                )
+                    "instruction field. Operand: %s Value: %d" %
+                    (operand, opvalue))
 
             if opvalue < 0:
 
                 if abs(opvalue) > (2**(field.size - 1)):
 
                     LOG.debug("Field name: %s", fieldname)
                     LOG.debug("Format field str: %s", format_field_str)
                     LOG.debug("Field size: %d", field.size)
                     LOG.debug("Max value codificable: %d", 2**field.size)
                     LOG.debug("Operand value: %s", opvalue)
                     LOG.debug("Instruction name: %s", self.name)
 
                     raise MicroprobeArchitectureDefinitionError(
                         "Operand value can not be codified within the "
-                        "instruction field. Operand: %s Value: %d"
-                        % (operand, opvalue)
-                    )
+                        "instruction field. Operand: %s Value: %d" %
+                        (operand, opvalue))
 
                 opvalue = opvalue + 2**field.size
 
             field_str = format_field_str.format(opvalue)
             binary_str = binary_str + field_str
 
             LOG.debug("Current binary: %s", binary_str)
@@ -2080,19 +1902,16 @@
         return "%s('%s')" % (self.__class__.__name__, self._name)
 
     def __hash__(self):
         return self._hash
 
     def _check_cmp(self, other):
         if not isinstance(other, self.__class__):
-            raise NotImplementedError(
-                "%s != %s" % (
-                    other.__class__, self.__class__
-                )
-            )
+            raise NotImplementedError("%s != %s" %
+                                      (other.__class__, self.__class__))
 
     def __eq__(self, other):
         """x.__eq__(y) <==> x==y"""
         self._check_cmp(other)
         return self.name == other.name
 
     def __ne__(self, other):
@@ -2117,15 +1936,14 @@
 
     def __ge__(self, other):
         """x.__ge__(y) <==> x>=y"""
         self._check_cmp(other)
         return self.name >= other.name
 
     def full_report(self, tabs=0):
-        """ """
 
         shift = ("\t" * (tabs + 1))
         fmt = "%-17s : %-30s\n"
         rstr = str(self)
         rstr += "\n\n"
         rstr += shift + "Definition" + "\n"
         rstr += shift + "----------" + "\n"
```

## microprobe/target/isa/instruction_field.py

```diff
@@ -12,51 +12,52 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.target.isa.instruction_field` module
 
 """
 
 # Futures
-from __future__ import absolute_import
+from __future__ import absolute_import, annotations
 
 # Built-in modules
 import abc
 import os
+from typing import TYPE_CHECKING, Dict, List, Tuple
 
 # Third party modules
-import six
 
 # Own modules
 from microprobe.exceptions import MicroprobeArchitectureDefinitionError
 from microprobe.utils.logger import get_logger
 from microprobe.utils.yaml import read_yaml
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.target.isa.operand import Operand
 
 # Constants
-SCHEMA = os.path.join(
-    os.path.dirname(os.path.abspath(__file__)), "schemas",
-    "instruction_field.yaml"
-)
+SCHEMA = os.path.join(os.path.dirname(os.path.abspath(__file__)), "schemas",
+                      "instruction_field.yaml")
 
 LOG = get_logger(__name__)
 __all__ = ["import_definition", "InstructionField", "GenericInstructionField"]
 
 
 # Functions
-def import_definition(cls, filenames, operands):
+def import_definition(cls, filenames: List[str], operands: Dict[str, Operand]):
     """
 
     :param filenames:
     :param operands:
 
     """
 
     LOG.debug("Start")
     ifields = {}
-    ifields_duplicated = {}
+    ifields_duplicated: Dict[Tuple[int, bool, str, str], str] = {}
 
     for filename in filenames:
         ifield_data = read_yaml(filename, SCHEMA)
 
         if ifield_data is None:
             continue
 
@@ -70,86 +71,81 @@
 
             key = tuple([size, show, fio, operand_def])
 
             if key in ifields_duplicated:
                 LOG.warning(
                     "Similar definition of instruction field: '%s' and"
                     " '%s'. Check if definition needed.", name,
-                    ifields_duplicated[key]
-                )
+                    ifields_duplicated[key])
             else:
                 ifields_duplicated[key] = name
 
             try:
                 operand = operands[operand_def]
             except KeyError:
                 raise MicroprobeArchitectureDefinitionError(
                     "Unknown operand "
                     "defined in instruction"
-                    " field '%s' in '%s'." % (name, filename)
-                )
+                    " field '%s' in '%s'." % (name, filename))
             ifield = cls(name, descr, size, show, fio, operand)
 
             if name in ifields:
                 raise MicroprobeArchitectureDefinitionError(
                     "Duplicated "
                     "definition "
                     "of instruction field"
-                    " '%s' found in '%s'" % (name, filename)
-                )
+                    " '%s' found in '%s'" % (name, filename))
 
             LOG.debug(ifield)
             ifields[name] = ifield
 
     LOG.debug("End")
     return ifields
 
 
 # Classes
-class InstructionField(six.with_metaclass(abc.ABCMeta, object)):
+class InstructionField(abc.ABC):
     """Abstract class to represent an instruction field"""
 
     @abc.abstractmethod
     def __init__(self):
-        """ """
         pass
 
-    @abc.abstractproperty
-    def name(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def name(self) -> str:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def description(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def description(self) -> str:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def size(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def size(self) -> int:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def default_show(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def default_show(self) -> bool:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def default_io(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def default_io(self) -> str:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def default_operand(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def default_operand(self) -> Operand:
         raise NotImplementedError
 
     @abc.abstractmethod
-    def __str__(self):
-        """ """
+    def __str__(self) -> str:
         raise NotImplementedError
 
 
 class GenericInstructionField(InstructionField):
     """Instruction field generic class.
 
     :param fname: Field name.
@@ -163,15 +159,16 @@
     :param foperand: Field operand.
     :type foperand: :class:`~.Operand` instance
 
     """
 
     _valid_fio_values = ['I', 'O', 'IO', '?']
 
-    def __init__(self, fname, descr, fsize, fshow, fio, foperand):
+    def __init__(self, fname: str, descr: str, fsize: int, fshow: bool,
+                 fio: str, foperand: Operand):
         """
 
         :param fname:
         :param descr:
         :param fsize:
         :param fshow:
         :param fio:
@@ -185,49 +182,38 @@
         self._fsize = fsize
         self._fshow = fshow
         self._fio = fio
         self._foperand = foperand
 
         if fio not in self._valid_fio_values:
             raise MicroprobeArchitectureDefinitionError(
-                "Invalid default IO "
-                "definition for field "
-                "%s" % fname
-            )
+                f"Invalid default IO definition for field {fname}")
 
     @property
     def name(self):
-        """ """
         return self._fname
 
     @property
     def description(self):
-        """ """
         return self._fdescr
 
     @property
     def size(self):
-        """ """
         return self._fsize
 
     @property
     def default_show(self):
-        """ """
         return self._fshow
 
     @property
     def default_operand(self):
-        """ """
         return self._foperand
 
     @property
     def default_io(self):
-        """ """
         return self._fio
 
     def __str__(self):
-        """ """
         return "%10s : %s" % (self.name, self.description)
 
     def __repr__(self):
-        """ """
         return "%s('%s')" % (self.__class__.__name__, self.name)
```

## microprobe/target/isa/instruction_format.py

```diff
@@ -12,43 +12,44 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.target.isa.instruction_format` module
 
 """
 
 # Futures
-from __future__ import absolute_import, division
+from __future__ import absolute_import, division, annotations
 
 # Built-in modules
 import abc
 import os
+from typing import TYPE_CHECKING, List, Tuple
 
 # Third party modules
-import six
 
 # Own modules
 from microprobe.exceptions import MicroprobeArchitectureDefinitionError, \
     MicroprobeLookupError
 from microprobe.utils.logger import get_logger
 from microprobe.utils.yaml import read_yaml
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.target.isa.instruction_field import InstructionField
 
 # Constants
-SCHEMA = os.path.join(
-    os.path.dirname(os.path.abspath(__file__)), "schemas",
-    "instruction_format.yaml"
-)
+SCHEMA = os.path.join(os.path.dirname(os.path.abspath(__file__)), "schemas",
+                      "instruction_format.yaml")
 LOG = get_logger(__name__)
 __all__ = [
     "import_definition", "InstructionFormat", "GenericInstructionFormat"
 ]
 
 
 # Functions
-def import_definition(cls, filenames, ifields):
+def import_definition(cls, filenames: List[str], ifields):
     """
 
     :param filenames:
     :param ifields:
 
     """
 
@@ -74,170 +75,154 @@
 
             key = tuple([tuple(elem["Fields"]), assembly])
 
             if key in iformats_duplicated:
                 LOG.warning(
                     "Similar definition of instruction format: '%s' "
                     "and '%s'. Check if definition needed.", name,
-                    iformats_duplicated[key]
-                )
+                    iformats_duplicated[key])
             else:
                 iformats_duplicated[key] = name
 
             if len(nonzero_fields) != len(set(nonzero_fields)):
 
                 raise MicroprobeArchitectureDefinitionError(
-                    "Definition of "
-                    "instruction format"
-                    " '%s' found in '%s'"
-                    " contains duplicated"
-                    " fields." % (name, filename)
-                )
+                    f"Definition of instruction format '{name}' found in "
+                    f"'{filename}' contains duplicated fields.")
 
             try:
                 fields = [ifields[ifieldname] for ifieldname in elem["Fields"]]
             except KeyError as key:
                 raise MicroprobeArchitectureDefinitionError(
-                    "Unknown field %s "
-                    "definition in "
-                    "instruction format"
-                    " '%s' found in '%s'." % (key, name, filename)
-                )
+                    f"Unknown field {key} definition in instruction format "
+                    f"'{name}' found in '{filename}'.")
 
             iformat = cls(name, descr, fields, assembly)
 
             if name in iformats:
                 raise MicroprobeArchitectureDefinitionError(
-                    "Duplicated "
-                    "definition "
-                    "of instruction "
-                    "format "
-                    "'%s' found "
-                    "in '%s'" % (name, filename)
-                )
+                    f"Duplicated definition of instruction format '{name}' "
+                    f"found in '{filename}'")
             LOG.debug(iformat)
             iformats[name] = iformat
 
     LOG.debug("End")
     return iformats
 
 
 # Classes
-class InstructionFormat(six.with_metaclass(abc.ABCMeta, object)):
+class InstructionFormat(abc.ABC):
     """Abstract class to represent an instruction format"""
 
     @abc.abstractmethod
-    def __init__(self, fname, descr):
+    def __init__(self, fname: str, descr: str):
         """
 
         :param fname:
         :param descr:
 
         """
         self._name = fname
         self._descr = descr
 
     @property
     def name(self):
-        """ """
         return self._name
 
     @property
     def description(self):
-        """ """
         return self._descr
 
-    @abc.abstractproperty
-    def fields(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def fields(self) -> List[InstructionField]:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def assembly_format(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def assembly_format(self) -> str:
         raise NotImplementedError
 
     @abc.abstractmethod
     def get_operands(self):
         """Returns a :class:`~.list` of :func:`tuple` of three elements.
         The first is a :class:`~.Operand` object, the second is a
         :class:`~.bool` indicating if the operand is an input operand and the
         third is a :class:`~.bool` indicating if the operand is an output
         operand.
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def get_fields(self):
+    def get_fields(self) -> List[InstructionField]:
         """Returns a :class:`~.list` of
         the :class:`~.InstructionField`
 
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def get_field(self, fname):
+    def get_field(self, fname: str) -> InstructionField:
         """Returns a the :class:`~.InstructionField` with name
         *fname*.
 
         :param fname:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def get_field_props(self, fname):
+    def get_field_props(self, fname: str):
         """Returns extra properties of field with name *fname*.
 
         :param fname: Field name.
         :type fname: :class:`~.str`
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def get_findex(self, fname):
+    def get_findex(self, fname: str):
         """Returns the index of the field *fname* within the instruction format
 
         :param fname: Field name.
         :type fname: :class:`~.str`
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def flip_fields(self, fname1, fname2):
+    def flip_fields(self, fname1: str, fname2: str):
         """Interchanges the position of the fields with name *fname1* and
         *fname2*.
 
         :param fname1: Field 1 name.
         :type fname1: :class:`~.str`
         :param fname2: Field 2 name.
         :type fname2: :class:`~.str`.
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def set_fields(self, fields, reset=True):
+    def set_fields(self, fields: List[InstructionField], reset: bool = True):
         """Sets the fields of the instruction format. If *reset* is *True* the
         properties and the flip records of the fields are removed.
 
         :param fields: List of fields.
         :type fields: :class:`~.list` of
                       :class:`~.InstructionField`
         :param reset: Flag indicating if a full reset is needed
                       (Default value = True)
         :type reset: :class:`~.bool`
         """
         raise NotImplementedError
 
     def __str__(self):
-        """ """
 
         values = "%-10s : %-30s ([" % (self.name, self.description)
 
         fields = []
         for field in self.fields:
             fmt = "{0:^%d}" % (field.size + (field.size - 4) // 4)
             fields.append(fmt.format(field.name))
@@ -257,114 +242,111 @@
 
         return rstr
 
 
 class GenericInstructionFormat(InstructionFormat):
     """Instruction format generic class."""
 
-    def __init__(self, fname, descr, fields, assembly):
+    def __init__(self, fname: str, descr: str, fields: List[InstructionField],
+                 assembly: str):
         """
 
         :param fname:
         :param descr:
         :param fields:
         :param assembly:
 
         """
         super(GenericInstructionFormat, self).__init__(fname, descr)
         self._fname = fname
-        self._fields = []
-        self._props = []
-        self._flips = []
+        self._fields: List[InstructionField] = []
+        self._props: List[None] = [
+        ]  # TODO: Check if this list of None is needed
+        self._flips: List[Tuple[int, int]] = []
         self._length = 0
         self._assembly_format = assembly
 
         for field in fields:
             self._add_field(field)
 
         self._compute_length()
 
     @property
     def fields(self):
-        """ """
         return self._fields
 
     @property
     def length(self):
-        """ """
         return self._length
 
     @property
     def assembly_format(self):
-        """ """
         return self._assembly_format
 
     def get_operands(self):
         """Returns a :class:`~.list` of :func:`tuple` of three elements.
         The first is a :class:`~.Operand` object, the second is a
         :class:`~.bool` indicating if the operand is an input operand and the
         third is a :class:`~.bool` indicating if the operand is an output
         operand.
         """
-        return [
-            (field.get_foperand(), field.is_input(), field.is_output())
-            for field in self.get_fields() if field.get_fshow()
-        ]
+        return [(field.get_foperand(), field.is_input(), field.is_output())
+                for field in self.get_fields() if field.get_fshow()]
 
     def get_fields(self):
         """Returns a :class:`~.list` of the
         :class:`~.InstructionField`
 
 
         """
         return self._fields
 
-    def get_field(self, fname):
+    def get_field(self, fname: str):
         """Returns a the :class:`~.InstructionField` with name
         *fname*.
 
         :param fname:
 
         """
         field = [
             field for field in self.get_fields() if field.get_fname() == fname
         ]
 
         if len(field) == 0:
             raise MicroprobeLookupError(
-                "Unable to find a field "
-                "with name '%s'" % fname
-            )
+                f"Unable to find a field with name '{fname}'")
 
-        assert len(field) == 1, "Field names should be key identifiers. " \
-                                "Field '%s' is duplicated" % fname
+        assert len(
+            field
+        ) == 1, "Field names should be key identifiers." + \
+            f" Field '{fname}' is duplicated"
 
         return field[0]
 
-    def get_field_props(self, fname):
+    def get_field_props(self, fname: str):
         """Returns extra properties of field with name *fname*.
 
         :param fname: Field name.
         :type fname: :class:`~.str`
 
         """
         idx = self.get_findex(fname)
         return self._props[idx]
 
-    def get_findex(self, fname):
+    def get_findex(self, fname: str):
         """Returns the index of the field *fname* within the instruction
         format.
 
         :param fname: Field name.
         :type fname: :class:`~.str`
 
         """
         return self.get_fields().index(self.get_field(fname))
 
-    def flip_fields(self, fname1, fname2):
+    def flip_fields(self, fname1: str, fname2: str):
         """Interchanges the position of the fields with name *fname1* and
         *fname2*.
 
         :param fname1: Field 1 name.
         :type fname1: :class:`~.str`
         :param fname2: Field 2 name.
         :type fname2: :class:`~.str`.
@@ -382,15 +364,15 @@
 
         tmp_prop = self._props[idx1]
         self._props[idx1] = self._props[idx2]
         self._props[idx2] = tmp_prop
 
         self._flips.append((idx1, idx2))
 
-    def set_fields(self, fields, reset=True):
+    def set_fields(self, fields: List[InstructionField], reset: bool = True):
         """Sets the fields of the instruction format. If *reset* is *True* the
         properties and the flip records of the fields are removed.
 
         :param fields: List of fields.
         :type fields: :class:`~.list` of
               :class:`~.InstructionField`
         :param reset: Flag indicating if a full reset is needed
@@ -401,35 +383,33 @@
         self._fields = fields
         if reset:
             self._props = [None] * len(self.get_fields())
             self._flips = []
 
         self._compute_length()
 
-    def _add_field(self, field):
+    def _add_field(self, field: InstructionField):
         """Adds an field to the instruction format.
 
         :param field: Instruction field
         :type field: :class:`~.InstructionField`
 
         """
         self._fields.append(field)
         self._props.append(None)
 
     def _compute_length(self):
-        """ """
 
         length = sum([field.size for field in self._fields])
         if length % 8 != 0:
 
             LOG.error("%s", self)
             LOG.error("\tTotal length: %d", length)
 
             for field in self._fields:
                 LOG.error("\t\t - %s: %d", field.name, field.size)
 
             raise MicroprobeArchitectureDefinitionError(
                 "Instruction format"
-                " '%s' length is not multiple of a byte" % self.name
-            )
+                " '%s' length is not multiple of a byte" % self.name)
 
         self._length = sum([field.size for field in self._fields]) // 8
```

## microprobe/target/isa/operand.py

```diff
@@ -34,19 +34,17 @@
 from microprobe.exceptions import MicroprobeArchitectureDefinitionError, \
     MicroprobeCodeGenerationError, MicroprobeValueError
 from microprobe.target.isa.register import Register
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import OrderedDict, natural_sort
 from microprobe.utils.yaml import read_yaml
 
-
 # Constants
-SCHEMA = os.path.join(
-    os.path.dirname(os.path.abspath(__file__)), "schemas", "operand.yaml"
-)
+SCHEMA = os.path.join(os.path.dirname(os.path.abspath(__file__)), "schemas",
+                      "operand.yaml")
 
 LOG = get_logger(__name__)
 __all__ = [
     "import_definition", "OperandDescriptor", "MemoryOperandDescriptor",
     "MemoryOperand", "Operand", "OperandReg", "OperandImmRange",
     "OperandValueSet", "OperandConst", "OperandConstReg",
     "InstructionAddressRelativeOperand"
@@ -87,16 +85,15 @@
                     regnames = elem["Registers"]
 
                     if isinstance(regnames, list):
 
                         if len(regnames) == 1 and \
                                 regnames[0] in register_types:
                             regs = [
-                                reg
-                                for reg in registers.values()
+                                reg for reg in registers.values()
                                 if reg.type.name == regnames[0]
                             ]
                         else:
                             regs = [
                                 registers[regname]
                                 for regname in natural_sort(regnames)
                             ]
@@ -105,26 +102,19 @@
 
                     else:
                         regs = OrderedDict()
                         for regname in natural_sort(regnames):
                             regs[registers[regname]] = []
                             for regname2 in regnames[regname]:
                                 regs[registers[regname]].append(
-                                    registers[regname2]
-                                )
+                                    registers[regname2])
 
                         key.append(
-                            tuple(
-                                [
-                                    (
-                                        k, tuple(v)
-                                    ) for k, v in regnames.items()
-                                ]
-                            )
-                        )
+                            tuple([(k, tuple(v))
+                                   for k, v in regnames.items()]))
 
                     address_base = elem.get("AddressBase", False)
                     address_index = elem.get("AddressIndex", False)
                     floating_point = elem.get("FloatingPoint", None)
                     vector = elem.get("Vector", None)
 
                     key.append(address_base)
@@ -136,27 +126,26 @@
                     # representation (N/A)
                     #
                     # These are pseudo registers used in
                     # simulation/emulation environment.
                     # They are not architected registers.
 
                     if isinstance(regs, list):
-                        regs = [reg for reg in regs
-                                if reg.representation != 'N/A']
+                        regs = [
+                            reg for reg in regs if reg.representation != 'N/A'
+                        ]
                     elif isinstance(regs, dict):
                         for elem in regs:
                             regs[elem] = [
                                 reg2 for reg2 in regs[elem]
                                 if reg2.representation != 'N/A'
                             ]
 
-                    operand = OperandReg(
-                        name, descr, regs, address_base, address_index,
-                        floating_point, vector
-                    )
+                    operand = OperandReg(name, descr, regs, address_base,
+                                         address_index, floating_point, vector)
 
                 elif "Min" in elem and "Max" in elem:
 
                     minval = elem["Min"]
                     maxval = elem["Max"]
                     step = elem.get("Step", 1)
                     novalues = elem.get("Except", [])
@@ -168,18 +157,17 @@
                     key.append(maxval)
                     key.append(step)
                     key.append(tuple(novalues))
                     key.append(address_index)
                     key.append(shift)
                     key.append(add)
 
-                    operand = OperandImmRange(
-                        name, descr, minval, maxval, step, address_index,
-                        shift, novalues, add
-                    )
+                    operand = OperandImmRange(name, descr, minval, maxval,
+                                              step, address_index, shift,
+                                              novalues, add)
 
                 elif "Values" in elem:
 
                     values = tuple(elem["Values"])
                     rep = elem.get("Representation", None)
                     key.append(tuple(values))
                     operand = OperandValueSet(name, descr, values, rep)
@@ -201,18 +189,17 @@
 
                     key.append(elem["Register"])
                     key.append(address_base)
                     key.append(address_index)
                     key.append(floating_point)
                     key.append(vector)
 
-                    operand = OperandConstReg(
-                        name, descr, reg, address_base, address_index,
-                        floating_point, vector
-                    )
+                    operand = OperandConstReg(name, descr, reg, address_base,
+                                              address_index, floating_point,
+                                              vector)
 
                 elif "Relative" in elem:
 
                     mindispl = elem["MinDisplacement"]
                     maxdispl = elem["MaxDisplacement"]
                     relative = elem["Relative"]
                     shift = elem.get("Shift", 0)
@@ -222,51 +209,45 @@
                     key.append(mindispl)
                     key.append(maxdispl)
                     key.append(shift)
                     key.append(step)
                     key.append(tuple([tuple(elem) for elem in except_ranges]))
 
                     operand = InstructionAddressRelativeOperand(
-                        name, descr, maxdispl, mindispl,
-                        shift, except_ranges, relative, step)
+                        name, descr, maxdispl, mindispl, shift, except_ranges,
+                        relative, step)
 
                 else:
                     raise MicroprobeArchitectureDefinitionError(
                         "Operand definition '%s' in '%s' not supported" %
-                        (name, filename)
-                    )
+                        (name, filename))
 
                 tkey = tuple(key)
                 if tkey in operands_duplicated:
                     LOG.warning(
                         "Similar definition of operands: '%s' and"
                         " '%s'. Check if definition needed.", name,
-                        operands_duplicated[tkey]
-                    )
+                        operands_duplicated[tkey])
                 else:
                     operands_duplicated[tkey] = name
 
             except KeyError as exception:
 
                 raise MicroprobeArchitectureDefinitionError(
                     "Definition"
                     " of operand '%s' "
                     "uses an unknown "
                     "register in '%s'"
                     "\nMissing defini"
-                    "tion of: %s" % (
-                        name, filename, exception
-                    )
-                )
+                    "tion of: %s" % (name, filename, exception))
 
             if name in operands and not override and filename not in inherits:
                 raise MicroprobeArchitectureDefinitionError(
                     "Duplicated definition of operand '%s' found in '%s'" %
-                    (name, filename)
-                )
+                    (name, filename))
 
             if name in operands:
                 LOG.debug("Redefined operand: %s", operand)
 
             LOG.debug(operand)
             operands[name] = operand
 
@@ -279,27 +260,27 @@
     if MICROPROBE_RC['hex_all']:
         if hex(value).endswith("L"):
             return hex(value)[:-1]
         return hex(value)
     elif MICROPROBE_RC['hex_none']:
         return str(value)
     elif MICROPROBE_RC['hex_address']:
-        if (operand.address_relative or
-                operand.address_immediate or operand.address_absolute):
+        if (operand.address_relative or operand.address_immediate
+                or operand.address_absolute):
             if hex(value).endswith("L"):
                 return hex(value)[:-1]
             return hex(value)
         else:
             return str(value)
     else:
         raise NotImplementedError
 
 
 # Classes
-class OperandDescriptor(object):
+class OperandDescriptor:
     """Class to represent an operand descriptor.
 
     """
 
     def __init__(self, mtype, is_input, is_output):
         """
 
@@ -339,22 +320,19 @@
         """Return a copy of the Operand descriptor.
 
         :rtype: :class:`~.OperandDescriptor`
         """
         return OperandDescriptor(self.type, self.is_input, self.is_output)
 
     def __repr__(self):
-        """ """
-        return "%s(%s, %s, %s)" % (
-            self.__class__.__name__, self._type, self._is_input,
-            self._is_output
-        )
+        return "%s(%s, %s, %s)" % (self.__class__.__name__, self._type,
+                                   self._is_input, self._is_output)
 
 
-class MemoryOperandDescriptor(object):
+class MemoryOperandDescriptor:
     """Class to represent a memory operand descriptor.
 
     """
 
     def __init__(self, otype, io, bit_rate):
         """
 
@@ -437,15 +415,15 @@
         rstr += shift + "Store  : %s\n" % self.is_store
         rstr += shift + "Prefetch  : %s\n" % self.is_prefetch
         rstr += shift + "Address generator  : %s\n" % self.is_agen
         rstr += shift + "Branch target  : %s" % self.is_branch_target
         return rstr
 
 
-class MemoryOperand(object):
+class MemoryOperand:
     """This represents a machine instruction memory operand. It contains
     the operands, the formula, the
 
 
     """
 
     _cmp_attributes = ["_address", "_length"]
@@ -463,24 +441,20 @@
     @property
     def address_operands(self):
         """  """
         return self._address
 
     @property
     def length_operands(self):
-        """ """
         return self._length
 
     def _check_cmp(self, other):
         if not isinstance(other, self.__class__):
-            raise NotImplementedError(
-                "%s != %s" % (
-                    other.__class__, self.__class__
-                )
-            )
+            raise NotImplementedError("%s != %s" %
+                                      (other.__class__, self.__class__))
 
     def __eq__(self, other):
         """x.__eq__(y) <==> x==y"""
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if not getattr(self, attr) == getattr(other, attr):
                 return False
@@ -531,42 +505,32 @@
             if getattr(self, attr) >= getattr(other, attr):
                 continue
             else:
                 return False
         return True
 
     def __str__(self):
-        """ """
-        return "%s(Address: %s, Length: %s)" % (
-            self.__class__.__name__, self._address, self._length
-        )
+        return "%s(Address: %s, Length: %s)" % (self.__class__.__name__,
+                                                self._address, self._length)
 
     def full_report(self, tabs=0):
         shift = ("\t" * (tabs + 1))
         rstr = shift + \
             "Address : %s\n" % list(self.address_operands.keys())
         rstr += shift + "Length : %s" % list(self.length_operands.keys())
         return rstr
 
 
-class Operand(six.with_metaclass(abc.ABCMeta, object)):
+class Operand(abc.ABC):
     """This represents a machine instruction operand"""
 
     _cmp_attributes = [
-        "_name",
-        "_descr",
-        "_ai",
-        "_ab",
-        "_aim",
-        "_imm",
-        "_const",
-        "_rel",
-        "_rela",
-        "_fp",
-        "_vector"]
+        "_name", "_descr", "_ai", "_ab", "_aim", "_imm", "_const", "_rel",
+        "_rela", "_fp", "_vector"
+    ]
 
     @abc.abstractmethod
     def __init__(self, name, descr):
         """
 
         :param name:
         :param descr:
@@ -710,38 +674,29 @@
         :param value: value of the operand.
         :type value: :class:`~.str`, :class:`~.Register` or
             :class:`int`
         :raise microprobe.exceptions.MicroprobeValueError: if
             the value is not allowed for the operand
         """
         if not self.__contains__(value):
-            raise MicroprobeValueError(
-                "Invalid operand value %s not in %s" % (value,
-                                                        list(self.values()))
-            )
+            raise MicroprobeValueError("Invalid operand value %s not in %s" %
+                                       (value, list(self.values())))
 
     def __str__(self):
-        """ """
-        return "%-8s : %s (%s)" % (
-            self.name, self.description, self.__class__.__name__
-        )
+        return "%-8s : %s (%s)" % (self.name, self.description,
+                                   self.__class__.__name__)
 
     def __repr__(self):
-        """ """
-        return "%s(\"%s\", \"%s\")" % (
-            self.__class__.__name__, self.name, self.description
-        )
+        return "%s(\"%s\", \"%s\")" % (self.__class__.__name__, self.name,
+                                       self.description)
 
     def _check_cmp(self, other):
         if not isinstance(other, self.__class__):
-            raise NotImplementedError(
-                "%s != %s" % (
-                    other.__class__, self.__class__
-                )
-            )
+            raise NotImplementedError("%s != %s" %
+                                      (other.__class__, self.__class__))
 
     def __eq__(self, other):
         """x.__eq__(y) <==> x==y"""
 
         if not isinstance(other, self.__class__):
             return False
 
@@ -800,18 +755,16 @@
 
 
 class OperandReg(Operand):
     """Class to represent a register operand.
 
     """
 
-    def __init__(
-        self, name, descr, regs, address_base, address_index, floating_point,
-        vector
-    ):
+    def __init__(self, name, descr, regs, address_base, address_index,
+                 floating_point, vector):
         """
 
         :param name:
         :param descr:
         :param regs:
         :param address_base:
         :param address_index:
@@ -830,20 +783,20 @@
 
         self._ab = address_base
         self._ai = address_index
         self._fp = floating_point
         self._vector = vector
 
         if self._fp is None:
-            self._fp = list(set([reg.type for reg in self._regs]))[
-                0].used_for_float_arithmetic
+            self._fp = list(set([reg.type for reg in self._regs
+                                 ]))[0].used_for_float_arithmetic
 
         if self._vector is None:
-            self._vector = list(set([reg.type for reg in self._regs]))[
-                0].used_for_vector_arithmetic
+            self._vector = list(set([reg.type for reg in self._regs
+                                     ]))[0].used_for_vector_arithmetic
 
     def values(self):
         """Return the possible value of the operand.
 
         :rtype: :class:`list` of :class:`~.Register`
         """
         return list(self._regs.keys())
@@ -888,20 +841,17 @@
 
         if not isinstance(value, Register):
             return False
 
         return value.name in [reg.name for reg in self.values()]
 
     def copy(self):
-        """ """
 
-        return OperandReg(
-            self.name, self.description, self._regs.copy(), self._ab, self._ai,
-            self._fp, self._vector
-        )
+        return OperandReg(self.name, self.description, self._regs.copy(),
+                          self._ab, self._ai, self._fp, self._vector)
 
     def set_valid_values(self, values):
         """
 
         :param values:
 
         """
@@ -921,17 +871,16 @@
 
 
 class OperandImmRange(Operand):
     """Class to represent a immediate range operand.
 
     """
 
-    def __init__(
-        self, name, descr, minvalue, maxvalue, step, aim, shift, novalues, add
-    ):
+    def __init__(self, name, descr, minvalue, maxvalue, step, aim, shift,
+                 novalues, add):
         """
 
         :param name:
         :param descr:
         :param minvalue:
         :param maxvalue:
         :param step:
@@ -949,70 +898,58 @@
         self._shift = shift
         self._imm = True
         self._novalues = novalues
         self._add = add
         self._computed_values = None
 
     def copy(self):
-        """ """
-        return OperandImmRange(
-            self.name, self.description, self._min, self._max, self._step,
-            self._aim, self._shift, self._novalues, self._add
-        )
+        return OperandImmRange(self.name, self.description, self._min,
+                               self._max, self._step, self._aim, self._shift,
+                               self._novalues, self._add)
 
     def values(self):
         """Return the possible value of the operand.
 
         :rtype: list of ::class:`~.int`
         """
         if self._computed_values is None:
             self._computed_values = [
-                elem
-                for elem in range(
-                    self._min, self._max + 1, self._step
-                ) if elem not in self._novalues
+                elem for elem in range(self._min, self._max + 1, self._step)
+                if elem not in self._novalues
             ]
         return self._computed_values
 
     def set_valid_values(self, values):
         """
 
         :param values:
 
         """
         if len(values) == 0:
             raise MicroprobeCodeGenerationError(
                 "Setting an operand without any valid value. Please check "
                 "the definition files. Previous value: '%s'. New values: '%s'"
-                "." % (list(self.values()), values)
-            )
+                "." % (list(self.values()), values))
 
         for value in values:
             assert value in list(self.values())
 
         self._computed_values = values
         self._const = len(values) == 1
 
     def random_value(self):
         """Return a random possible value for the operand.
 
         :rtype: ::class:`~.int`
         """
         if self._computed_values is not None:
-            return self._computed_values[
-                random.randrange(
-                    0, len(
-                        self._computed_values
-                    )
-                )
-            ]
+            return self._computed_values[random.randrange(
+                0, len(self._computed_values))]
 
-        value = random.randrange(
-            self._min, self._max + 1, self._step
-        )
+        value = random.randrange(self._min, self._max + 1, self._step)
 
         if value not in self._novalues:
             return value
         else:
             return self.random_value()
 
     def representation(self, value):
@@ -1036,65 +973,56 @@
         :param value:
 
         """
         return str(value >> self._shift)
 
     @property
     def max(self):
-        """ """
         return self._max
 
     @property
     def min(self):
-        """ """
         return self._min
 
     @property
     def step(self):
-        """ """
         return self._step
 
     @property
     def shift(self):
-        """ """
         return self._shift
 
     @property
     def add(self):
-        """ """
         return self._add
 
     def check(self, value):
         """
 
         :param value:
 
         """
 
         if not isinstance(value, six.integer_types):
-            raise MicroprobeValueError(
-                "Invalid operand value: '%s'. Integer"
-                " required and '%s' provided" % (value, type(value))
-            )
+            raise MicroprobeValueError("Invalid operand value: '%s'. Integer"
+                                       " required and '%s' provided" %
+                                       (value, type(value)))
 
         # value = value >> self._shift
         if value <= self._max and value >= self._min \
                 and (value - self._min) % self._step == 0 \
                 and value not in self._novalues:
 
             return True
 
         else:
 
-            raise MicroprobeValueError(
-                "Invalid operand value: %d (max: %d,"
-                " min: %d)" % (
-                    value, self._max, self._min
-                )
-            )
+            raise MicroprobeValueError("Invalid operand value: %d (max: %d,"
+                                       " min: %d)" %
+                                       (value, self._max, self._min))
 
     def access(self, dummy):
         """
 
         :param dummy:
 
         """
@@ -1126,27 +1054,21 @@
         # TODO: add input value checking
         self._values = values
         self._imm = True
         self._rep = None
         if rep is not None and len(rep) != len(values):
             raise MicroprobeArchitectureDefinitionError(
                 "Values and representation of operand definition "
-                "'%s' do not have the same length." % name
-            )
+                "'%s' do not have the same length." % name)
         if rep is not None:
             self._rep = dict(zip(values, rep))
 
     def copy(self):
-        """ """
-        return OperandValueSet(
-            self.name,
-            self.description,
-            self._values,
-            self._rep
-        )
+        return OperandValueSet(self.name, self.description, self._values,
+                               self._rep)
 
     def values(self):
         """Return the possible value of the operand.
 
         :rtype: list of ::class:`~.int`
         """
         return self._values
@@ -1182,20 +1104,18 @@
         :param dummy:
 
         """
         return []
 
     @property
     def shift(self):
-        """ """
         return 0
 
     @property
     def min(self):
-        """ """
         return min(self._values)
 
     def __contains__(self, value):
         """
 
         :param value:
 
@@ -1233,15 +1153,14 @@
         self._value = value
         self._imm = True
         self._aim = aim
         self._rel = arel
         self._const = True
 
     def copy(self):
-        """ """
         return OperandConst(self.name, self.description, self._value)
 
     def values(self):
         """Return the possible value of the operand.
 
         :rtype: list of ::class:`~.int`
         """
@@ -1268,20 +1187,18 @@
 
         :rtype: ::class:`~.int`
         """
         return self._value
 
     @property
     def shift(self):
-        """ """
         return 0
 
     @property
     def min(self):
-        """ """
         return self._value
 
     def access(self, dummy):
         """
 
         :param dummy:
 
@@ -1310,18 +1227,16 @@
 
 
 class OperandConstReg(Operand):
     """Class to represent a constant register operand.
 
     """
 
-    def __init__(
-        self, name, descr, reg, address_base, address_index, floating_point,
-        vector
-    ):
+    def __init__(self, name, descr, reg, address_base, address_index,
+                 floating_point, vector):
         """
 
         :param name:
         :param descr:
         :param reg:
         :param address_base:
         :param address_index:
@@ -1336,27 +1251,24 @@
 
         self._ab = address_base
         self._ai = address_index
         self._fp = floating_point
         self._vector = vector
 
         if self._fp is None:
-            self._fp = list(set([reg.type for reg in self._regs]))[
-                0].used_for_float_arithmetic
+            self._fp = list(set([reg.type for reg in self._regs
+                                 ]))[0].used_for_float_arithmetic
 
         if self._vector is None:
-            self._vector = list(set([reg.type for reg in self._regs]))[
-                0].used_for_float_arithmetic
+            self._vector = list(set([reg.type for reg in self._regs
+                                     ]))[0].used_for_float_arithmetic
 
     def copy(self):
-        """ """
-        return OperandConstReg(
-            self.name, self.description, self._reg, self._ab, self._ai,
-            self._fp, self._vector
-        )
+        return OperandConstReg(self.name, self.description, self._reg,
+                               self._ab, self._ai, self._fp, self._vector)
 
     def values(self):
         """Return the possible value of the operand.
 
         :rtype: list of :class:`~.Register`
         """
         return [self._reg]
@@ -1420,24 +1332,16 @@
     """Class to represent a relative instruction address operand.
 
     Relative instruction address operands are used for immediates operands
     used to compute relative distance between the current instruction
     and the target. Examples are : branch relative, or load address relative.
     """
 
-    def __init__(
-            self,
-            name,
-            descr,
-            maxdispl,
-            mindispl,
-            shift,
-            except_range,
-            relative,
-            step):
+    def __init__(self, name, descr, maxdispl, mindispl, shift, except_range,
+                 relative, step):
         """Create a InstructionAddressRelativeOperand object.
 
         :param name: Operand name
         :type name: :class:`~.str`
         :param descr: Operand description
         :type descr: :class:`~.str`
         :param maxdispl: Maximum displacement allowed
@@ -1459,19 +1363,19 @@
         self._rel = relative
         self._rela = not relative
         self._shift = shift
         self._except = except_range
         self._step = step
 
     def copy(self):
-        """ """
-        return InstructionAddressRelativeOperand(
-            self.name, self.description, self._maxdispl, self._mindispl,
-            self._shift, self._except, self._rel, self._step
-        )
+        return InstructionAddressRelativeOperand(self.name, self.description,
+                                                 self._maxdispl,
+                                                 self._mindispl, self._shift,
+                                                 self._except, self._rel,
+                                                 self._step)
 
     def values(self):
         """Return the possible value of the operand.
 
         :rtype: list of ::class:`~.int`
         """
         return [self._mindispl << self._shift]
@@ -1511,16 +1415,15 @@
             if isinstance(base_address, Variable):
                 str_value = base_address.name
             elif isinstance(base_address, str):
                 str_value = base_address
             else:
                 raise MicroprobeCodeGenerationError(
                     "Unable to generate the string representation of '%s'"
-                    " with value: '%s'" % (self, value)
-                )
+                    " with value: '%s'" % (self, value))
 
             if displacement > 0:
                 str_value = "%s+0x%x" % (str_value, displacement)
             elif displacement < 0:
                 str_value = "%s-0x%x" % (str_value, abs(displacement))
 
             return str_value
@@ -1548,56 +1451,49 @@
             cvalue = value
         elif isinstance(value, Address):
             # Warning!
             return
         else:
             if not isinstance(value[0], Address) or \
                     not isinstance(value[1], Address):
-                raise MicroprobeValueError(
-                    "Invalid operand value '%s'."
-                    " Any Address?" % (value)
-                )
+                raise MicroprobeValueError("Invalid operand value '%s'."
+                                           " Any Address?" % (value))
             cvalue = value[0] - value[1]
 
         if cvalue > (self._maxdispl << self._shift) or \
            cvalue < (self._mindispl << self._shift) or \
            self._in_except_ranges(cvalue) or \
            cvalue % self._step != 0:
             raise MicroprobeValueError(
                 "Invalid operand value '%d' "
                 "not within the"
                 " allowed range (%d, %d) and exceptions"
-                " '%s' " % (
-                    cvalue, self._mindispl, self._maxdispl, self._except
-                )
-            )
+                " '%s' " %
+                (cvalue, self._mindispl, self._maxdispl, self._except))
 
     def codification(self, value):
         """
 
         :param value:
 
         """
 
         if isinstance(value, six.integer_types):
             return str(value >> self._shift)
         elif isinstance(value, Address):
-            raise MicroprobeCodeGenerationError(
-                "Unable to codify the"
-                " symbolic address: %s ."
-                " Consider to add a pass to"
-                " translate them to actual "
-                "values " % value
-            )
+            raise MicroprobeCodeGenerationError("Unable to codify the"
+                                                " symbolic address: %s ."
+                                                " Consider to add a pass to"
+                                                " translate them to actual "
+                                                "values " % value)
         else:
             raise NotImplementedError
 
     @property
     def shift(self):
-        """ """
         return self._shift
 
     def access(self, dummy):
         """
 
         :param dummy:
```

## microprobe/target/isa/register.py

```diff
@@ -12,43 +12,45 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.target.isa.register` module
 
 """
 
 # Futures
-from __future__ import absolute_import
+from __future__ import absolute_import, annotations
 
 # Built-in modules
 import abc
 import hashlib
 import os
+from typing import List, TYPE_CHECKING
 
 # Third party modules
-import six
 from six.moves import range
 
 # Own modules
 from microprobe.exceptions import MicroprobeArchitectureDefinitionError
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import Pickable
 from microprobe.utils.yaml import read_yaml
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.target.isa.register_type import RegisterType
 
 # Constants
-SCHEMA = os.path.join(
-    os.path.dirname(os.path.abspath(__file__)), "schemas", "register.yaml"
-)
+SCHEMA = os.path.join(os.path.dirname(os.path.abspath(__file__)), "schemas",
+                      "register.yaml")
 
 LOG = get_logger(__name__)
 __all__ = ["import_definition", "Register", "GenericRegister"]
 
 
 # Functions
-def import_definition(cls, filenames, regtypes):
+def import_definition(cls, filenames: List[str], regtypes):
     """
 
     :param filenames:
     :param regtypes:
 
     """
 
@@ -71,16 +73,15 @@
             rfrom = 0
             rto = 0
             replace = "0"
 
             if rtype not in regtypes:
                 raise MicroprobeArchitectureDefinitionError(
                     "Unknown register type in definition of "
-                    "register '%s' in file '%s'" % (name, filename)
-                )
+                    "register '%s' in file '%s'" % (name, filename))
 
             if repeat:
                 rfrom = repeat["From"]
                 replace = "%s" % rfrom
                 rto = repeat["To"]
 
             for index in range(rfrom, rto + 1):
@@ -92,136 +93,127 @@
                 ctype = regtypes[rtype]
 
                 regt = cls(cname, cdescr, ctype, crepr, ccodi)
 
                 if cname in regs:
                     raise MicroprobeArchitectureDefinitionError(
                         "Duplicated register definition of '%s' found"
-                        " in '%s'" % (cname, filename)
-                    )
+                        " in '%s'" % (cname, filename))
 
                 LOG.debug(regt)
                 regs[cname] = regt
 
     LOG.debug("End")
     return regs
 
 
 # Classes
-class Register(six.with_metaclass(abc.ABCMeta, object)):
+class Register(abc.ABC):
     """Abstract class to represent an architecture register."""
 
     @abc.abstractmethod
     def __init__(self):
-        """ """
         pass
 
-    @abc.abstractproperty
-    def type(self):
+    @property
+    @abc.abstractmethod
+    def type(self) -> RegisterType:
         """Register type (:class:`~.RegisterType` instance)."""
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def name(self):
+    @property
+    @abc.abstractmethod
+    def name(self) -> str:
         """Register name (:class:`~.str` instance)."""
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def description(self):
+    @property
+    @abc.abstractmethod
+    def description(self) -> str:
         """Register description (:class:`~.str` instance)."""
         raise NotImplementedError
 
     @abc.abstractmethod
-    def representation(self):
+    def representation(self) -> str:
         """Return the assembly representation of this register."""
         raise NotImplementedError
 
     @abc.abstractmethod
-    def codification(self):
+    def codification(self) -> str:
         """Return the assembly representation of this register."""
         raise NotImplementedError
 
     @abc.abstractmethod
-    def __str__(self):
+    def __str__(self) -> str:
         """Return the string representation of this register."""
         raise NotImplementedError
 
     @abc.abstractmethod
-    def __repr__(self):
+    def __repr__(self) -> str:
         """Return the string representation of this register."""
         raise NotImplementedError
 
     @abc.abstractmethod
-    def __hash__(self):
-        """ """
+    def __hash__(self) -> int:
         raise NotImplementedError
 
 
 class GenericRegister(Register, Pickable):
     """A Generic architected register"""
 
     _cmp_attributes = ["type", "representation", "name"]
 
-    def __init__(self, name, descr, rtype, rrepr, rcodi):
+    def __init__(self, name: str, descr: str, rtype: RegisterType, rrepr,
+                 rcodi):
         """
 
         :param name:
         :param descr:
         :param rtype:
         :param rrepr:
 
         """
         super(GenericRegister, self).__init__()
         self._rtype = rtype
         self._name = name
         self._descr = descr
         self._rrepr = rrepr
         self._rcodi = rcodi
-        self._hash = int(hashlib.sha512(
-            (
-                self.name + self.description +
-                self.representation + str(hash(self.type))
-            ).encode()).hexdigest(), 16)
+        self._hash = int(
+            hashlib.sha512(
+                (self.name + self.description + self.representation +
+                 str(hash(self.type))).encode()).hexdigest(), 16)
 
     @property
     def type(self):
-        """ """
         return self._rtype
 
     @property
     def name(self):
-        """ """
         return self._name
 
     @property
     def description(self):
-        """ """
         return self._descr
 
     @property
     def representation(self):
-        """ """
         return str(self._rrepr)
 
     @property
     def codification(self):
-        """ """
         return str(self._rcodi)
 
     def __hash__(self):
-        """ """
         return self._hash
 
     def _check_cmp(self, other):
         if not isinstance(other, self.__class__):
-            raise NotImplementedError(
-                "%s != %s" % (
-                    other.__class__, self.__class__
-                )
-            )
+            raise NotImplementedError("%s != %s" %
+                                      (other.__class__, self.__class__))
 
     def __eq__(self, other):
         """x.__eq__(y) <==> x==y"""
 
         if not isinstance(other, self.__class__):
             return False
 
@@ -326,29 +318,24 @@
 
             if not self_val < other_val:
                 return False
 
         return True
 
     def __str__(self):
-        """ """
-        return "%8s : %s (Type: %s)" % (
-            self._name, self._descr, self._rtype.name
-        )
+        return "%8s : %s (Type: %s)" % (self._name, self._descr,
+                                        self._rtype.name)
 
     def __repr__(self):
-        """ """
         return "%s('%s')" % (self.__class__.__name__, self.name)
 
     def __getattr__(self, name):
         """If attribute not found, check if register type implements it
 
         :param name:
 
         """
         try:
             return self._rtype.__getattribute__(name)
         except AttributeError:
-            raise AttributeError(
-                "'%s' object has no attribute '%s'" %
-                (self.__class__.__name__, name)
-            )
+            raise AttributeError("'%s' object has no attribute '%s'" %
+                                 (self.__class__.__name__, name))
```

## microprobe/target/isa/register_type.py

```diff
@@ -18,45 +18,43 @@
 # Futures
 from __future__ import absolute_import
 
 # Built-in modules
 import abc
 import hashlib
 import os
+from typing import Dict, List, Tuple
 
 # Third party modules
-import six
 
 # Own modules
 from microprobe.exceptions import MicroprobeArchitectureDefinitionError
 from microprobe.utils.logger import get_logger
 from microprobe.utils.yaml import read_yaml
 
-
 # Constants
-SCHEMA = os.path.join(
-    os.path.dirname(os.path.abspath(__file__)), "schemas", "register_type.yaml"
-)
+SCHEMA = os.path.join(os.path.dirname(os.path.abspath(__file__)), "schemas",
+                      "register_type.yaml")
 LOG = get_logger(__name__)
 __all__ = ["import_definition", "RegisterType", "GenericRegisterType"]
 
 # Functions
 
 
-def import_definition(cls, filenames, dummy):
+def import_definition(cls, filenames: List[str], dummy):
     """
 
     :param filenames:
     :param dummy:
 
     """
 
     LOG.debug("Start")
     regts = {}
-    regts_duplicated = {}
+    regts_duplicated: Dict[Tuple[int, bool, bool, bool], str] = {}
 
     for filename in filenames:
         regt_data = read_yaml(filename, SCHEMA)
 
         for elem in regt_data:
             name = elem["Name"]
             size = elem["Size"]
@@ -68,88 +66,85 @@
 
             key = tuple([size, u4aa, u4fa, u4va])
 
             if key in regts_duplicated:
                 LOG.warning(
                     "Similar definition of register types: '%s' and"
                     " '%s'. Check if definition needed.", name,
-                    regts_duplicated[key]
-                )
+                    regts_duplicated[key])
             else:
                 regts_duplicated[key] = name
 
             LOG.debug(regt)
 
             if name in regts:
                 raise MicroprobeArchitectureDefinitionError(
                     "Duplicated "
                     "definition of register type '%s' "
-                    "found in '%s'" % (name, filename)
-                )
+                    "found in '%s'" % (name, filename))
 
             regts[name] = regt
 
     LOG.debug("End")
     return regts
 
 
 # Classes
-class RegisterType(six.with_metaclass(abc.ABCMeta, object)):
+class RegisterType(abc.ABC):
     """Abstract base class to represent a Register Type"""
 
     @abc.abstractmethod
     def __init__(self):
-        """ """
         pass
 
-    @abc.abstractproperty
-    def name(self):
+    @property
+    @abc.abstractmethod
+    def name(self) -> str:
         """Register type name (:class:`~.str`)"""
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def description(self):
+    @property
+    @abc.abstractmethod
+    def description(self) -> str:
         """Register type name (:class:`~.str`)"""
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def size(self):
+    @property
+    @abc.abstractmethod
+    def size(self) -> int:
         """Register size in bits (::class:`~.int`)"""
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def used_for_address_arithmetic(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def used_for_address_arithmetic(self) -> bool:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def used_for_float_arithmetic(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def used_for_float_arithmetic(self) -> bool:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def used_for_vector_arithmetic(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def used_for_vector_arithmetic(self) -> bool:
         raise NotImplementedError
 
     def __str__(self):
         """x.__str__() <==> str(x)"""
-        return "%8s: %s (bit size: %d)" % (
-            self.name, self.description, self.size
-        )
+        return "%8s: %s (bit size: %d)" % (self.name, self.description,
+                                           self.size)
 
     def __repr__(self):
         """x.__repr__() <==> str(x)"""
-        return "%8s: %s (bit size: %d)" % (
-            self.name, self.description, self.size
-        )
+        return "%8s: %s (bit size: %d)" % (self.name, self.description,
+                                           self.size)
 
     @abc.abstractmethod
-    def __hash__(self):
-        """ """
+    def __hash__(self) -> int:
         raise NotImplementedError
 
 
 class GenericRegisterType(RegisterType):
     """A class to represent a register type. Each register type is identified
     by its *type*, its *size* in bits and also its *semantic* properites (e.g.
     if they are used for address arithmetic, or for floating point cumpations,
@@ -161,22 +156,20 @@
     :type rdescr: :class:`~.str`
     :param rsize: Register size in bits
     :type rsize: :class:`~.int`
 
     """
 
     _cmp_attributes = [
-        "name",
-        "description",
-        "size",
-        "used_for_address_arithmetic",
-        "used_for_float_arithmetic",
-        "used_for_vector_arithmetic"]
+        "name", "description", "size", "used_for_address_arithmetic",
+        "used_for_float_arithmetic", "used_for_vector_arithmetic"
+    ]
 
-    def __init__(self, rtype, rdescr, rsize, u4aa, u4fa, u4va):
+    def __init__(self, rtype: str, rdescr: str, rsize: int, u4aa: bool,
+                 u4fa: bool, u4va: bool):
         """
 
         :param rtype:
         :param rdescr:
         :param rsize:
         :param u4aa:
         :param u4fa:
@@ -186,20 +179,21 @@
         super(GenericRegisterType, self).__init__()
         self._rtype = rtype
         self._rdescr = rdescr
         self._rsize = rsize
         self._used_for_address_arithmetic = u4aa
         self._used_for_float_arithmetic = u4fa
         self._used_for_vector_arithmetic = u4va
-        self._hash = int(hashlib.sha512((
-                str(self.name) + str(self.description) + str(self.size) +
-                str(self.used_for_address_arithmetic) +
-                str(self.used_for_float_arithmetic) +
-                str(self.used_for_vector_arithmetic)).encode()).hexdigest(),
-                16)
+        self._hash = int(
+            hashlib.sha512(
+                (str(self.name) + str(self.description) + str(self.size) +
+                 str(self.used_for_address_arithmetic) +
+                 str(self.used_for_float_arithmetic) +
+                 str(self.used_for_vector_arithmetic)).encode()).hexdigest(),
+            16)
 
     @property
     def name(self):
         """Register type name (:class:`~.str`)"""
         return self._rtype
 
     @property
@@ -210,38 +204,31 @@
     @property
     def size(self):
         """Register type size in bits (::class:`~.int`)"""
         return self._rsize
 
     @property
     def used_for_address_arithmetic(self):
-        """ """
         return self._used_for_address_arithmetic
 
     @property
     def used_for_float_arithmetic(self):
-        """ """
         return self._used_for_float_arithmetic
 
     @property
     def used_for_vector_arithmetic(self):
-        """ """
         return self._used_for_vector_arithmetic
 
     def __hash__(self):
-        """ """
         return self._hash
 
     def _check_cmp(self, other):
         if not isinstance(other, self.__class__):
-            raise NotImplementedError(
-                "%s != %s" % (
-                    other.__class__, self.__class__
-                )
-            )
+            raise NotImplementedError("%s != %s" %
+                                      (other.__class__, self.__class__))
 
     def __eq__(self, other):
         """x.__eq__(y) <==> x==y"""
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if not getattr(self, attr) == getattr(other, attr):
                 return False
```

## microprobe/target/isa/schemas/__init__.py

```diff
@@ -12,14 +12,13 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """<your one-liner module description>.
 
 <your module documentation here>.
 """
 
-
 # Constants
 __all__ = []
 
 # Functions
 
 # Classes
```

## microprobe/target/uarch/__init__.py

```diff
@@ -12,79 +12,75 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.target.uarch` package
 
 """
 
 # Futures
-from __future__ import absolute_import
+from __future__ import absolute_import, annotations
 
 # Built-in modules
 import abc
 import os
+from typing import TYPE_CHECKING, List
 
 # Third party modules
 
 # Own modules
 import microprobe.target.uarch.element
 import microprobe.target.uarch.element_type
 from microprobe import MICROPROBE_RC
 from microprobe.exceptions import MicroprobeYamlFormatError
 from microprobe.property import PropertyHolder, import_properties
 from microprobe.target.uarch.cache import cache_hierarchy_from_elements
-from microprobe.utils.imp import get_object_from_module, \
-    import_cls_definition, import_definition, import_operand_definition
+from microprobe.utils.imp import get_object_from_module, import_definition
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import findfiles
 from microprobe.utils.yaml import read_yaml
 import six
 
 # Local modules
 
+# Type hinting
+if TYPE_CHECKING:
+    from microprobe.target import Target, Definition
 
 # Constants
-SCHEMA = os.path.join(
-    os.path.dirname(os.path.abspath(__file__)), "schemas",
-    "microarchitecture.yaml"
-)
-DEFAULT_UARCH = os.path.join(
-    os.path.dirname(os.path.abspath(__file__)), "default",
-    "microarchitecture.yaml"
-)
+SCHEMA = os.path.join(os.path.dirname(os.path.abspath(__file__)), "schemas",
+                      "microarchitecture.yaml")
+DEFAULT_UARCH = os.path.join(os.path.dirname(os.path.abspath(__file__)),
+                             "default", "microarchitecture.yaml")
 LOG = get_logger(__name__)
 __all__ = [
     "import_microarchitecture_definition",
     "find_microarchitecture_definitions", "Microarchitecture",
     "GenericMicroarchitecture", "GenericCPUMicroarchitecture"
 ]
 
 
 # Functions
-def _read_uarch_extensions(uarchdefs, path):
+def _read_uarch_extensions(uarchdefs, path: str):
     """ """
 
     if "Extends" in uarchdefs[-1]:
         uarchdefval = uarchdefs[-1]["Extends"]
         del uarchdefs[-1]["Extends"]
 
         if not os.path.isabs(uarchdefval):
             uarchdefval = os.path.join(path, uarchdefval)
 
         uarchdef = read_yaml(
-            os.path.join(
-                uarchdefval, "microarchitecture.yaml"
-            ), SCHEMA
-        )
+            os.path.join(uarchdefval, "microarchitecture.yaml"), SCHEMA)
         uarchdef["Path"] = uarchdefval
         uarchdefs.append(uarchdef)
 
         _read_uarch_extensions(uarchdefs, uarchdefval)
 
 
-def _read_yaml_definition(uarchdefs, path):
+def _read_yaml_definition(uarchdefs, path: str):
     """
 
     :param uarchdefs:
     :param path:
 
     """
 
@@ -123,44 +119,37 @@
                             if override:
                                 complete_uarchdef[key][key2] = [val[key2]]
                             else:
                                 complete_uarchdef[key][key2].append(val[key2])
                         else:
                             if override:
                                 complete_uarchdef[key][key2] = [
-                                    os.path.join(
-                                        uarchdef["Path"], val[key2]
-                                    )
+                                    os.path.join(uarchdef["Path"], val[key2])
                                 ]
                             else:
                                 complete_uarchdef[key][key2].append(
-                                    os.path.join(
-                                        uarchdef["Path"], val[key2]
-                                    )
-                                )
+                                    os.path.join(uarchdef["Path"], val[key2]))
                     elif key2 == "Module":
                         if val[key2].startswith("microprobe"):
-                            val[key2] = os.path.join(
-                                os.path.dirname(__file__), "..", "..", "..",
-                                val[key2]
-                            )
+                            val[key2] = os.path.join(os.path.dirname(__file__),
+                                                     "..", "..", "..",
+                                                     val[key2])
 
                         if os.path.isabs(val[key2]):
                             complete_uarchdef[key][key2] = val[key2]
                         else:
                             complete_uarchdef[key][key2] = os.path.join(
-                                uarchdef["Path"], val[key2]
-                            )
+                                uarchdef["Path"], val[key2])
                     else:
                         complete_uarchdef[key][key2] = val[key2]
 
     return complete_uarchdef
 
 
-def import_microarchitecture_definition(path):
+def import_microarchitecture_definition(path: str):
     """Imports a Microarchitecture definition given a path
 
     :param path:
 
     """
 
     LOG.info("Start microarchitecture import")
@@ -168,60 +157,48 @@
 
     if not os.path.isabs(path):
         path = os.path.abspath(path)
 
     uarchdef = _read_yaml_definition([], path)
 
     element_types, force = import_definition(
-        uarchdef, os.path.join(
-            path, "microarchitecture.yaml"
-        ), "Element_type", getattr(microprobe.target.uarch, 'element_type'),
-        None
-    )
-
-    element, force = import_definition(
-        uarchdef,
-        os.path.join(
-            path, "microarchitecture.yaml"
-        ),
-        "Element",
-        getattr(
-            microprobe.target.uarch, 'element'
-        ),
-        element_types,
-        force=force
-    )
-
-    uarch_cls = get_object_from_module(
-        uarchdef["Microarchitecture"]["Class"],
-        uarchdef["Microarchitecture"]["Module"]
-    )
-
-    uarch = uarch_cls(
-        uarchdef["Name"], uarchdef["Description"], element,
-        uarchdef["Instruction_properties"]["Path"]
-    )
-
-    import_properties(
-        os.path.join(path, "microarchitecture.yaml"), {uarchdef["Name"]: uarch}
-    )
+        uarchdef, os.path.join(path, "microarchitecture.yaml"), "Element_type",
+        getattr(microprobe.target.uarch, 'element_type'), None)
+
+    element, force = import_definition(uarchdef,
+                                       os.path.join(path,
+                                                    "microarchitecture.yaml"),
+                                       "Element",
+                                       getattr(microprobe.target.uarch,
+                                               'element'),
+                                       element_types,
+                                       force=force)
+
+    uarch_cls = get_object_from_module(uarchdef["Microarchitecture"]["Class"],
+                                       uarchdef["Microarchitecture"]["Module"])
+
+    uarch = uarch_cls(uarchdef["Name"], uarchdef["Description"], element,
+                      uarchdef["Instruction_properties"]["Path"])
+
+    import_properties(os.path.join(path, "microarchitecture.yaml"),
+                      {uarchdef["Name"]: uarch})
 
     LOG.info("Microarchitecture '%s' imported", uarch)
     return uarch
 
 
-def find_microarchitecture_definitions(paths=None):
+def find_microarchitecture_definitions(paths: List[str] | None = None):
 
     if paths is None:
         paths = []
 
     paths = paths + MICROPROBE_RC["microarchitecture_paths"] \
         + MICROPROBE_RC["default_paths"]
 
-    results = []
+    results: List[Definition] = []
     uarchfiles = findfiles(paths, "^microarchitecture.yaml$")
 
     if len(uarchfiles) > 0:
         from microprobe.target import Definition
 
     for uarchfile in uarchfiles:
 
@@ -229,21 +206,18 @@
             isadef = read_yaml(uarchfile, SCHEMA)
         except MicroprobeYamlFormatError as exc:
             LOG.info("Exception: %s", exc)
             LOG.info("Skipping '%s'", uarchfile)
             continue
 
         try:
-            definition = Definition(
-                uarchfile, isadef["Name"], isadef["Description"]
-            )
-            if (
-                definition not in results and
-                not definition.name.endswith("common")
-            ):
+            definition = Definition(uarchfile, isadef["Name"],
+                                    isadef["Description"])
+            if (definition not in results
+                    and not definition.name.endswith("common")):
                 results.append(definition)
 
         except TypeError as exc:
             # Skip bad definitions
             LOG.info("Exception: %s", exc)
             LOG.info("Skipping '%s'", uarchfile)
             continue
@@ -252,70 +226,68 @@
 
 # Classes
 class Microarchitecture(six.with_metaclass(abc.ABCMeta, PropertyHolder)):
     """ """
 
     @abc.abstractmethod
     def __init__(self):
-        """ """
         pass
 
-    @abc.abstractproperty
-    def name(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def name(self) -> str:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def description(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def description(self) -> str:
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def elements(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def add_properties_to_isa(self, instructions):
         """
 
         :param instructions:
 
         """
         raise NotImplementedError
 
     @abc.abstractmethod
     def full_report(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
-    def __str__(self):
-        """ """
+    def __str__(self) -> str:
         raise NotImplementedError
 
     @abc.abstractmethod
-    def set_target(self, target):
+    def set_target(self, target: Target):
         """
 
         :param target:
 
         """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def target(self):
-        """ """
         raise NotImplementedError
 
 
 class GenericMicroarchitecture(Microarchitecture):
     """ """
 
-    def __init__(self, name, descr, elements, instruction_properties_defs):
+    def __init__(self, name: str, descr: str, elements,
+                 instruction_properties_defs):
         """
 
         :param name:
         :param descr:
         :param elements:
         :param instruction_properties_defs:
 
@@ -325,33 +297,29 @@
         self._descr = descr
         self._elements = elements
         self._target = None
         self._instruction_property_defs = instruction_properties_defs
 
     @property
     def name(self):
-        """ """
         return self._name
 
     @property
     def description(self):
-        """ """
         return self._descr
 
     @property
     def elements(self):
-        """ """
         return self._elements
 
     @property
     def target(self):
-        """ """
         return self._target
 
-    def set_target(self, target):
+    def set_target(self, target: Target):
         """
 
         :param target:
 
         """
         self._target = target
 
@@ -361,64 +329,54 @@
         :param instructions:
 
         """
         for cfile in self._instruction_property_defs:
             import_properties(cfile, instructions)
 
     def full_report(self):
-        """ """
         rstr = "-" * 80 + "\n"
         rstr += "Microarchitecture Name: %s\n" % self.name
         rstr += "Microarchitecture Description: %s\n" % self.name
         rstr += "-" * 80 + "\n"
         rstr += "Element Types:\n"
-        for elem in sorted(
-            set(
-                [
-                    elem.type for elem in self.elements.values()
-                ]
-            )
-        ):
+        for elem in sorted(set([elem.type
+                                for elem in self.elements.values()])):
             rstr += str(elem) + "\n"
         rstr += "-" * 80 + "\n"
         rstr += "Elements:\n"
         for elem in sorted(self.elements.values()):
             rstr += str(elem) + "\n"
         rstr += "-" * 80 + "\n"
         return rstr
 
     def __str__(self):
-        """ """
-        return "%s('%s', '%s')" % (
-            self.__class__.__name__, self.name, self.description
-        )
+        return "%s('%s', '%s')" % (self.__class__.__name__, self.name,
+                                   self.description)
 
 
 class GenericCPUMicroarchitecture(GenericMicroarchitecture):
     """Generic CPU Microarchitecture
 
     Generic CPU microarchitecture. Assumes a cache hierarchy
 
 
     """
 
-    def __init__(self, name, descr, elements, instruction_properties_defs):
+    def __init__(self, name: str, descr: str, elements,
+                 instruction_properties_defs):
         """
 
         :param name:
         :param descr:
         :param elements:
         :param instruction_properties_defs:
 
         """
-        super(
-            GenericCPUMicroarchitecture, self
-        ).__init__(
-            name, descr, elements, instruction_properties_defs
-        )
+        super(GenericCPUMicroarchitecture,
+              self).__init__(name, descr, elements,
+                             instruction_properties_defs)
 
         self._cache_hierarchy = cache_hierarchy_from_elements(elements)
 
     @property
     def cache_hierarchy(self):
-        """ """
         return self._cache_hierarchy
```

## microprobe/target/uarch/cache.py

```diff
@@ -12,26 +12,30 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """:mod:`microprobe.target.uarch.cache` module
 
 """
 
 # Futures
-from __future__ import absolute_import, division, print_function
+from __future__ import absolute_import, division, print_function, annotations
 
 # Built-in modules
 import math
+from typing import TYPE_CHECKING, Dict, List
 
 # Third party modules
 from six.moves import range
 
 # Own modules
 from microprobe.exceptions import MicroprobeArchitectureDefinitionError
 from microprobe.utils.logger import get_logger
 
+# Type checking
+if TYPE_CHECKING:
+    from microprobe.target.uarch.element import MicroarchitectureElement
 
 # Constants
 LOG = get_logger(__name__)
 __all__ = [
     "cache_hierarchy_from_elements", "Cache", "SetAssociativeCache",
     "CacheHierarchy"
 ]
@@ -47,16 +51,15 @@
 
     caches = _caches_from_elements(elements)
 
     if len(caches) == 0:
         raise MicroprobeArchitectureDefinitionError(
             "Expecting cache hierarchy"
             " elements in the microarchitecture"
-            " description, but none found."
-        )
+            " description, but none found.")
 
     cache_hierarchy = CacheHierarchy(caches)
 
     return cache_hierarchy
 
 
 def _caches_from_elements(elements):
@@ -64,75 +67,73 @@
 
     :param elements:
 
     """
 
     LOG.debug("Start")
 
-    caches = []
+    caches: List[Cache] = []
     for element in elements.values():
 
         LOG.debug("Checking: '%s'", element)
         try:
             if not element.type.data_cache and \
                     not element.type.instruction_cache:
                 continue
         except Exception:
             raise MicroprobeArchitectureDefinitionError(
                 "Microarchitecture "
                 "definition requires the definition of the "
                 "'data_cache' and 'instruction_cache' properties "
-                "for the element types."
-            )
+                "for the element types.")
 
         LOG.debug("Cache element found:'%s'", element)
 
         try:
             size = element.type.cache_size * 1024
             line_size = element.type.cache_linesize
             level = element.type.cache_level
             address_size = element.type.cache_address_size
         except AttributeError as exc:
             # pylint: disable-msg=E1101
             raise MicroprobeArchitectureDefinitionError(
                 "Element '%s' defined as a cache, but required "
                 "property '%s' not specified in its type "
-                "'%s'" % (element, exc.message.split("'")[3], element.type)
-            )
+                "'%s'" % (element, exc.message.split("'")[3], element.type))
 
         # Figuring out the cache type based on element attributes
         # Right now, we only implement N-way set associative
 
         ways = getattr(element.type, "cache_ways", None)
 
         if ways is not None:
-            new_cache = SetAssociativeCache(
-                element, size, level, line_size, address_size,
-                element.type.data_cache, element.type.instruction_cache, ways
-            )
+            new_cache = SetAssociativeCache(element, size, level, line_size,
+                                            address_size,
+                                            element.type.data_cache,
+                                            element.type.instruction_cache,
+                                            ways)
             caches.append(new_cache)
         else:
             raise MicroprobeArchitectureDefinitionError(
                 "Element '%s' defined "
                 "as a cache, but cache type can not be "
                 "determined. Please specify on of the "
-                "following properties: ['cache_ways']"
-            )
+                "following properties: ['cache_ways']")
 
     LOG.debug("End")
     return caches
 
 
 # Classes
-class Cache(object):
+class Cache:
     """Class to represent a cache."""
 
-    def __init__(
-        self, element, size, level, line_size, address_size, data, ins
-    ):
+    def __init__(self, element: MicroarchitectureElement, size: int,
+                 level: int, line_size: int, address_size: int, data: bool,
+                 ins: bool):
         """Create a Cache object.
 
         :param element: Micrarchitecture element
         :type element: :class:`~.MicroarchitectureElement`
         :param size: Cache size in kilobytes
         :type size: :class:`~.int`
         :param level: Cache level
@@ -188,15 +189,15 @@
     def level(self):
         """Cache level (class:`~.int`)."""
         return self._level
 
     @property
     def name(self):
         """Cache name (class:`~.str`)."""
-        return "%s Cache" % self.element.full_name
+        return f"{self.element.full_name} Cache"
 
     @property
     def description(self):
         """Cache description (class:`~.str`)."""
 
         if self.contains_data ^ self.contains_instructions:
             if self.contains_data:
@@ -212,17 +213,17 @@
         """"x.__str__() <==> str(x)"""
         return "%s('%s')" % (self.__class__.__name__, self.description)
 
 
 class SetAssociativeCache(Cache):
     """Class to represent a set-associative cache."""
 
-    def __init__(
-        self, element, size, level, line_size, address_size, data, ins, ways
-    ):
+    def __init__(self, element: MicroarchitectureElement, size: int,
+                 level: int, line_size: int, address_size: int, data: bool,
+                 ins: bool, ways: int):
         """Create a SetAssociativeCache object.
 
         :param element: Micrarchitecture element
         :type element: :class:`~.MicroarchitectureElement`
         :param size: Cache size in kilobytes
         :type size: :class:`~.int`
         :param level: Cache level
@@ -236,17 +237,17 @@
         :param ins: Instruction cache flag
         :type ins: :class:`~.bool`
         :param ins: Cache ways
         :type ins: :class:`~.int`
         :return: Cache instance
         :rtype: :class:`~.Cache`
         """
-        super(SetAssociativeCache, self).__init__(
-            element, size, level, line_size, address_size, data, ins
-        )
+        super(SetAssociativeCache,
+              self).__init__(element, size, level, line_size, address_size,
+                             data, ins)
 
         self._ways = ways
         self._address_size = address_size
 
         self._sets = size // (ways * line_size)
         self._set_bits = int(math.log(self._sets, 2))
 
@@ -302,36 +303,35 @@
         """Return the list of sets and ways.
 
         :return: List of available sets * ways
         :rtype: :class:`~.list` of :class:`~.int`
         """
         return list(range(0, self._setsways))
 
-    def congruence_class(self, value):
+    def congruence_class(self, value: int):
         """Return the congruence class for a given *value*.
 
         :param value: Address
         :type value: :class:`~.int`
         :return: Congruence class
         :rtype: :class:`~.int`
         """
         cgc = (value >> self.offset_bits) & ((1 << (self._set_bits)) - 1)
         return cgc
 
-    def offset(self, value):
+    def offset(self, value: int):
         """
 
         :param value:
 
         """
         cgc = (value) & ((1 << (self.offset_bits) - 1))
         return cgc
 
     def print_info(self):
-        """ """
 
         from microprobe.utils.cmdline import print_info
         print_info(self._offset_bits)
         print_info(self._set_bits)
         print_info(self._tag_bits)
         bit_range = [0, self._address_size - 1]
         offset_range = [
@@ -342,83 +342,76 @@
             self._address_size - 1 - self.offset_bits - self._set_bits,
             self._address_size - 1 - self.offset_bits - 1
         ]
 
         print_info((bit_range, offset_range, ccrange))
 
 
-class CacheHierarchy(object):
+class CacheHierarchy:
     """Class to represent a cache hierarchy."""
 
-    def __init__(self, caches):
+    def __init__(self, caches: List[Cache]):
         """
 
         :param caches:
 
         """
 
         first_data_levels = [
             cache for cache in caches
             if cache.level == 1 and cache.contains_data
         ]
 
         first_ins_levels = [
-            cache
-            for cache in caches
+            cache for cache in caches
             if cache.level == 1 and cache.contains_instructions
         ]
 
         if len(first_ins_levels) == 0:
             raise MicroprobeArchitectureDefinitionError(
                 "At least one cache"
                 "should be defined as first level instruction"
-                "cache."
-            )
+                "cache.")
 
         if len(first_data_levels) == 0:
             raise MicroprobeArchitectureDefinitionError(
                 "At least one cache"
-                "should be defined as first level data cache"
-            )
+                "should be defined as first level data cache")
 
-        data_levels = {}
+        data_levels: Dict[MicroarchitectureElement, List[Cache]] = {}
         for cache in first_data_levels:
             data_levels[cache.element] = [cache]
 
-        ins_levels = {}
+        ins_levels: Dict[MicroarchitectureElement, List[Cache]] = {}
         for cache in first_ins_levels:
             ins_levels[cache.element] = [cache]
 
         current_level = 2
         next_data_levels = [
-            cache
-            for cache in caches
+            cache for cache in caches
             if cache.level == current_level and cache.contains_data
         ]
         next_ins_levels = [
-            cache
-            for cache in caches
+            cache for cache in caches
             if cache.level == current_level and cache.contains_instructions
         ]
 
         while len(next_data_levels + next_ins_levels) > 0:
 
             if len(next_data_levels) > 0:
 
                 for element in data_levels:
 
                     data_level = data_levels[element][-1]
 
                     assert data_level.level == (current_level - 1)
 
-                    new_level = sorted(
-                        next_data_levels,
-                        key=lambda x, elem=element:
-                        x.element.closest_common_element(elem).depth
-                    )[-1]
+                    new_level = sorted(next_data_levels,
+                                       key=lambda x, elem=element: x.element.
+                                       closest_common_element(elem).depth)[-1]
 
                     data_levels[element].append(new_level)
 
             if len(next_ins_levels) > 0:
 
                 for element in ins_levels:
 
@@ -429,71 +422,67 @@
                     def my_key(elem):
                         """
 
                         :param elem:
                         :type elem:
                         """
                         return elem.element.closest_common_element(
-                            element
-                        ).depth
+                            element).depth
 
                     new_level = sorted(next_ins_levels, key=my_key)[-1]
 
                     ins_levels[element].append(new_level)
 
             current_level += 1
             next_data_levels = [
-                cache
-                for cache in caches
+                cache for cache in caches
                 if cache.level == current_level and cache.contains_data
             ]
             next_ins_levels = [
-                cache
-                for cache in caches
+                cache for cache in caches
                 if cache.level == current_level and cache.contains_instructions
             ]
 
         self._data_levels = data_levels
         self._ins_levels = ins_levels
 
-    def get_data_hierarchy_from_element(self, element):
+    def get_data_hierarchy_from_element(self,
+                                        element: MicroarchitectureElement):
         """
 
         :param element:
 
         """
 
         LOG.debug("Generating hierarchy from '%s'", element)
         rhierarchy = [
-            entry_level
-            for entry_level in self._data_levels.values()
+            entry_level for entry_level in self._data_levels.values()
             if element in [cache.element for cache in entry_level]
         ]
 
         assert len(rhierarchy) == 1
         LOG.debug("Hierarchy: '%s'", [str(elem) for elem in rhierarchy[0]])
 
         return rhierarchy[0]
 
-    def get_instruction_hierarchy_from_element(self, element):
+    def get_instruction_hierarchy_from_element(
+            self, element: MicroarchitectureElement):
         """
 
         :param element:
 
         """
 
         LOG.debug("Generating hierarchy from '%s'", element)
         rhierarchy = [
-            entry_level
-            for entry_level in self._ins_levels.values()
+            entry_level for entry_level in self._ins_levels.values()
             if element in [cache.element for cache in entry_level]
         ]
 
         assert len(rhierarchy) == 1
         LOG.debug("Hierarchy: '%s'", [str(elem) for elem in rhierarchy[0]])
 
         return rhierarchy[0]
 
     def data_linesize(self):
-        """ """
-        return self._data_levels[
-            list(self._data_levels.keys())[0]][0].line_size
+        return self._data_levels[list(
+            self._data_levels.keys())[0]][0].line_size
```

## microprobe/target/uarch/element.py

```diff
@@ -30,19 +30,17 @@
 # Own modules
 from microprobe.exceptions import MicroprobeArchitectureDefinitionError
 from microprobe.property import PropertyHolder, import_properties
 from microprobe.utils.logger import get_logger
 from microprobe.utils.misc import RejectingDict
 from microprobe.utils.yaml import read_yaml
 
-
 # Constants
-SCHEMA = os.path.join(
-    os.path.dirname(os.path.abspath(__file__)), "schemas", "element.yaml"
-)
+SCHEMA = os.path.join(os.path.dirname(os.path.abspath(__file__)), "schemas",
+                      "element.yaml")
 
 LOG = get_logger(__name__)
 __all__ = [
     "import_definition", "MicroarchitectureElement",
     "GenericMicroarchitectureElement"
 ]
 
@@ -73,16 +71,15 @@
             try:
                 elem_type = element_types[elem["Type"]]
             except KeyError:
                 raise MicroprobeArchitectureDefinitionError(
                     "Unknown "
                     "microarchitecture element type in "
                     "microarchitecture element definition "
-                    " '%s' found in '%s'" % (name, filename)
-                )
+                    " '%s' found in '%s'" % (name, filename))
             descr = elem.get("Description", elem_type.description)
 
             if repeat:
                 rfrom = repeat["From"]
                 replace = "%s" % rfrom
                 rto = repeat["To"]
 
@@ -93,31 +90,29 @@
 
                 try:
                     elements[cname] = element
                     elements_subelements[cname] = subelements
                 except ValueError:
                     raise MicroprobeArchitectureDefinitionError(
                         "Duplicated microarchitecture element "
-                        "definition '%s' found in '%s'" % (name, filename)
-                    )
+                        "definition '%s' found in '%s'" % (name, filename))
 
             LOG.debug(element)
 
     for filename in filenames:
         import_properties(filename, elements)
 
     for elem, subelements in elements_subelements.items():
         try:
             subelements_instances = [elements[item] for item in subelements]
         except KeyError as exc:
             raise MicroprobeArchitectureDefinitionError(
                 "Undefined sub-element '%s' in element "
                 "definition '%s'. Check following "
-                "files: %s" % (exc, elem, filenames)
-            )
+                "files: %s" % (exc, elem, filenames))
 
         elements[elem].set_subelements(subelements_instances)
 
     element_list = list(elements.values())
     fixing_hierarchy = True
 
     LOG.info("Start building element hierarchy...")
@@ -135,17 +130,16 @@
                 # needs duplication
 
                 LOG.debug("Element %s has %d parents", element, len(parents))
 
                 for parent in sorted(parents):
                     LOG.debug("Duplicating for parent: %s", parent)
                     # Create a new copy
-                    new_element = cls(
-                        element.name, element.description, element.type
-                    )
+                    new_element = cls(element.name, element.description,
+                                      element.type)
                     new_element.set_subelements(element.subelements)
                     element_list.append(new_element)
 
                     # Update parent to point to the new copy
                     new_subelements = parent.subelements
                     new_subelements.remove(element)
                     new_subelements.append(new_element)
@@ -164,113 +158,103 @@
             item for item in element_list if element in item.subelements
         ]
 
         if len(parents) > 1:
             raise MicroprobeArchitectureDefinitionError(
                 "Wrong hierarchy of microarchitecture "
                 "elements. The definition of element"
-                " '%s' has multiple parents: '%s'." % (
-                    element, [str(elem) for elem in parents]
-                )
-            )
+                " '%s' has multiple parents: '%s'." %
+                (element, [str(elem) for elem in parents]))
         elif len(parents) == 0:
             if top_element is not None:
                 raise MicroprobeArchitectureDefinitionError(
                     "Wrong hierarchy of microarchitecture "
                     "elements. There are at least two top "
                     "elements: '%s' and '%s'. Define a single "
                     "parent element for all the hierarchy." %
-                    (element, top_element)
-                )
+                    (element, top_element))
             top_element = element
         else:
             element.set_parent_element(parents[0])
 
     if top_element is None:
         raise MicroprobeArchitectureDefinitionError(
             "Wrong hierarchy of microarchitecture "
             "elements. There is not a top element."
             " Define a single parent element for all "
-            "the hierarchy."
-        )
+            "the hierarchy.")
 
     LOG.info("Element hierarchy correct")
 
-    elem_dict = dict(
-        [
-            (element.full_name, element) for element in element_list
-        ]
-    )
+    elem_dict = dict([(element.full_name, element)
+                      for element in element_list])
 
     for filename in filenames:
         import_properties(filename, elem_dict)
 
     LOG.info("End importing elements")
     return elem_dict
 
 
 # Classes
-class MicroarchitectureElement(
-    six.with_metaclass(
-        abc.ABCMeta,
-        PropertyHolder)):
+class MicroarchitectureElement(six.with_metaclass(abc.ABCMeta,
+                                                  PropertyHolder)):
     """ """
 
     @abc.abstractmethod
     def __init__(self):
-        """ """
         pass
 
-    @abc.abstractproperty
-    def name(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def name(self) -> str:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def full_name(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def full_name(self) -> str:
         raise NotImplementedError
 
-    @abc.abstractproperty
-    def description(self):
-        """ """
+    @property
+    @abc.abstractmethod
+    def description(self) -> str:
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def type(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def depth(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def subelements(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def set_subelements(self, subelements):
         """
 
         :param subelements:
 
         """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def parent(self):
-        """ """
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def parents(self):
-        """ """
         raise NotImplementedError
 
     @abc.abstractmethod
     def set_parent_element(self, parent):
         """
 
         :param parent:
@@ -309,62 +293,53 @@
         super(GenericMicroarchitectureElement, self).__init__()
         self._name = name
         self._descr = descr
         self._type = mtype
 
         self._parent = None
         self._subelements = {}
-        self._hash = int(hashlib.sha512(
-            (
-                self.name + self.description +
-                self.full_name + str(self.type) + str(self.depth)
-            ).encode()).hexdigest(), 16)
+        self._hash = int(
+            hashlib.sha512(
+                (self.name + self.description + self.full_name +
+                 str(self.type) + str(self.depth)).encode()).hexdigest(), 16)
 
     @property
     def name(self):
-        """ """
         return self._name
 
     @property
     def full_name(self):
-        """ """
         if self._parent is None:
             return self._name
         return "%s_%s" % (self._name, self.parent.full_name)
 
     @property
     def parents(self):
-        """ """
         if self._parent is None:
             return []
         return [self.parent] + self.parent.parents
 
     @property
     def description(self):
-        """ """
         return self._descr
 
     @property
     def type(self):
-        """ """
         return self._type
 
     @property
     def subelements(self):
-        """ """
         return list(self._subelements.values())
 
     @property
     def parent(self):
-        """ """
         return self._parent
 
     @property
     def depth(self):
-        """ """
         if self._parent is None:
             return 0
         return 1 + self.parent.depth
 
     def set_parent_element(self, parent):
         """
 
@@ -376,17 +351,16 @@
 
     def set_subelements(self, subelements):
         """
 
         :param subelements:
 
         """
-        self._subelements = dict(
-            [(element.name, element) for element in subelements]
-        )
+        self._subelements = dict([(element.name, element)
+                                  for element in subelements])
 
         for subelement in subelements:
             subelement.set_parent_element(self)
 
     def closest_common_element(self, element):
         """
 
@@ -400,31 +374,25 @@
         for elem in own_parents:
             if elem in other_parents:
                 return elem
 
         return None
 
     def __hash__(self):
-        """ """
         return self._hash
 
     def __str__(self):
         """Return the string representation of this element"""
-        return "%s('%s','%s','%s')" % (
-            self.__class__.__name__, self.name, self.full_name,
-            self.description
-        )
+        return "%s('%s','%s','%s')" % (self.__class__.__name__, self.name,
+                                       self.full_name, self.description)
 
     def _check_cmp(self, other):
         if not isinstance(other, self.__class__):
-            raise NotImplementedError(
-                "%s != %s" % (
-                    other.__class__, self.__class__
-                )
-            )
+            raise NotImplementedError("%s != %s" %
+                                      (other.__class__, self.__class__))
 
     def __eq__(self, other):
         """x.__eq__(y) <==> x==y"""
         self._check_cmp(other)
         for attr in self._cmp_attributes:
             if not getattr(self, attr) == getattr(other, attr):
                 return False
```

## microprobe/target/uarch/element_type.py

```diff
@@ -17,38 +17,37 @@
 
 # Futures
 from __future__ import absolute_import
 
 # Built-in modules
 import abc
 import os
+from typing import List
 
 # Third party modules
 import six
 
 # Own modules
 from microprobe.property import PropertyHolder, import_properties
 from microprobe.utils.logger import get_logger
 from microprobe.utils.yaml import read_yaml
 
-
 # Constants
-SCHEMA = os.path.join(
-    os.path.dirname(os.path.abspath(__file__)), "schemas", "element_type.yaml"
-)
+SCHEMA = os.path.join(os.path.dirname(os.path.abspath(__file__)), "schemas",
+                      "element_type.yaml")
 
 LOG = get_logger(__name__)
 __all__ = [
     "import_definition", "MicroarchitectureElementType",
     "GenericMicroarchitectureElementType"
 ]
 
 
 # Functions
-def import_definition(cls, filenames, dummy):
+def import_definition(cls, filenames: List[str], dummy):
     """
 
     :param cls:
     :type cls:
     :param filenames:
     :type filenames:
     :param dummy:
@@ -79,49 +78,47 @@
 
     LOG.info("End importing element type definitions")
     return element_types
 
 
 # Classes
 class MicroarchitectureElementType(
-    six.with_metaclass(
-        abc.ABCMeta,
-        PropertyHolder)):
+        six.with_metaclass(abc.ABCMeta, PropertyHolder)):
     """Abstract class to represent a microarchitecture element type."""
 
     @abc.abstractmethod
     def __init__(self):
         """Create a microarchitecture element type.
 
         :return: MicroarchitectureElementType instance
         :rtype: :class:`~.MicroarchitectureElementType`
         """
         pass
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def name(self):
         """Microarchitecture element type name (:class:`~.str`)."""
         raise NotImplementedError
 
-    @abc.abstractproperty
+    @property
+    @abc.abstractmethod
     def description(self):
         """Microarchitecture element type description (:class:`~.str`)."""
         raise NotImplementedError
 
     @abc.abstractmethod
     def __str__(self):
         """Return the string representation of this element type
         (:class:`~.str`)."""
         raise NotImplementedError
 
 
 class GenericMicroarchitectureElementType(
-    six.with_metaclass(
-        abc.ABCMeta,
-        MicroarchitectureElementType)):
+        six.with_metaclass(abc.ABCMeta, MicroarchitectureElementType)):
     """Class to represent a generic microarchitecture element type."""
 
     def __init__(self, name, description):
         """Create a generic microarchitecture element type.
 
         :param name: Microarchitecture element type name
         :type name: :class:`~.str`
@@ -143,17 +140,16 @@
     def description(self):
         """Microarchitecture element type description (:class:`~.str`)."""
         return self._description
 
     def __str__(self):
         """Return the string representation of this element type
         (:class:`~.str`)."""
-        return "%s('%s','%s')" % (
-            self.__class__.__name__, self.name, self.description
-        )
+        return "%s('%s','%s')" % (self.__class__.__name__, self.name,
+                                  self.description)
 
     def __lt__(self, other):
 
         assert isinstance(other, MicroarchitectureElementType)
 
         name_cmp = self.name != other.name
         if name_cmp:
```

## microprobe/target/uarch/schemas/__init__.py

```diff
@@ -12,14 +12,13 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 """<your one-liner module description>.
 
 <your module documentation here>.
 """
 
-
 # Constants
 __all__ = []
 
 # Functions
 
 # Classes
```

## Comparing `microprobe_all-0.5.20230629114852.dist-info/LICENSE` & `microprobe_all-0.5.20230713062001.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `microprobe_all-0.5.20230629114852.dist-info/METADATA` & `microprobe_all-0.5.20230713062001.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: microprobe-all
-Version: 0.5.20230629114852
+Version: 0.5.20230713062001
 Summary: Microprobe: Microbenchmark generation framework: A modular and extensible framework to generate microbenchmarks
 Home-page: https://github.com/IBM/microprobe
 Author: Ramon Bertran
 Author-email: rbertra@us.ibm.com
 Maintainer: Ramon Bertran
 Maintainer-email: rbertra@us.ibm.com
 License: Apache Version 2.0
```

## Comparing `microprobe_all-0.5.20230629114852.dist-info/RECORD` & `microprobe_all-0.5.20230713062001.dist-info/RECORD`

 * *Files 7% similar despite different names*

```diff
@@ -1,58 +1,58 @@
 microprobe/__init__.py,sha256=gSvzR35UxVDNKb8HJdFvOSbRcZd99tceH_aKZBgC7uI,9236
 microprobe/exceptions.py,sha256=nBz7iho1-56vWCt3RcmdB3N-VH64GtrmpffjBDtG9A0,6504
 microprobe/property.py,sha256=9QmP2rA40FOifkQ5gnFjek2xzv2Buyr5XzP884W0ELg,10213
-microprobe/code/__init__.py,sha256=w8k-i1mSqc_s2X4fIg3JnvWYBzJvgbRo4OIoRJokFn0,25912
-microprobe/code/address.py,sha256=WWjtOLHHMTIMsQzlphuZTofyg5O7zMYWGqhFB6D52BQ,14640
-microprobe/code/bbl.py,sha256=xfQ2jHY0F83ZjVw6UM2E8sOuB4k5eYImhkdYKbEFNJY,11088
-microprobe/code/benchmark.py,sha256=2U2Kj4_9M6BBPDNIf__HudTk-HgF-EK8t6LXbuFpk3Q,14023
-microprobe/code/cfg.py,sha256=1BQ3tdeVIdfZYlTbH36bC0htXAFPOuNk1phnLvpDXMI,3379
-microprobe/code/context.py,sha256=VKRRKnPh4z4ZTenooDlWtw9GsiS-X0446n3aDwr2-28,18207
-microprobe/code/ins.py,sha256=TaGe7uCH_y3elWX79wtjlf_jXzFE5ewQzF204MnO_Ws,74582
-microprobe/code/var.py,sha256=FcwHFccukhU_y2-AAmiUNs6Fkrd5bPANIXa7WbrVZIk,11674
-microprobe/code/wrapper.py,sha256=PQWFxnGJYeEzPpAw7_vVv3ASQ6bLcs2VTUoGHNzPHfw,5909
+microprobe/code/__init__.py,sha256=-5fAi59dTY4HBuwmk4dwUPdJSPmF_VpWG8MqplqApDU,26105
+microprobe/code/address.py,sha256=HdvSJtk7Pagf45A_y8QBTPKXfUwsXTJLai90np-uzds,15338
+microprobe/code/bbl.py,sha256=1zAH5I7cpz2YFxI49rwXJHglpYE3iss_8lHdKNOrFVA,11440
+microprobe/code/benchmark.py,sha256=hx0I_goEGQms-vOWUpa6QxCv3Y3n2lEXUIK3ModoRRA,14465
+microprobe/code/cfg.py,sha256=2qHL7vomWNxaUGtKw94cE2YLfhWLegcqsWiPbJrgo4A,3570
+microprobe/code/context.py,sha256=jfLqz6YRgB-L_M9fOAsy6M2Ye6qhuAvBTGD6kwOLPKg,18014
+microprobe/code/ins.py,sha256=_FvgnpvvH67AZ_GFmEqSItyComOXOIx_scENwwS4ZEM,75466
+microprobe/code/var.py,sha256=3c149Mk4tNYIuktUBiM9xgf9gtidG3rGiyiYh41owGU,12069
+microprobe/code/wrapper.py,sha256=fC4DSXoiqY24_D5_qBb1X9ynWJt7303eiPxO9dVgzio,6514
 microprobe/driver/__init__.py,sha256=TaAuxqdWA5dvHoznIgZJ9cLEIbvAROJZjf24MkGTv5k,671
 microprobe/driver/genetic.py,sha256=pYWkGu-dJFSMaCfnk1LWgwiRskBrWRyusk_gQ1jZC90,10949
 microprobe/driver/guided.py,sha256=z7fPulazNjeccg5AMznsogkh42xjVeyn6UcLXuSilCU,677
 microprobe/model/__init__.py,sha256=Evr_zzwoEkWCnmdgj68IRxLC8JegvB0cAYpkYxmMa6A,1642
 microprobe/model/memory.py,sha256=e2Z7kLn3nfHMt4onMIQUIWJh70my7GZKG9kTB3pkX1Y,13892
 microprobe/passes/__init__.py,sha256=6ceMHZUDbOhR4_mSSHY43yDH6hl-pK9mTrNcnhSHX2k,2180
 microprobe/passes/address/__init__.py,sha256=AJApvRvHOchD2Fy9E5-XGHfcshFxx1ok0go8c0CBSvU,7684
 microprobe/passes/branch/__init__.py,sha256=PxQIteOsacSLIRVzIHn1W79Nb02ZLq6YlSxqRv7xY8o,58027
 microprobe/passes/dat/__init__.py,sha256=l9mEItBt58OI7tQh0CorAilF2t6J1JRvGdzS4QUpJJU,2527
 microprobe/passes/decimal/__init__.py,sha256=tXBqRpa-HSfxZi61hjWD3YaMZ4_a-AzP6BvhJtfOgRs,3028
 microprobe/passes/float/__init__.py,sha256=B3DMgvmgJOBTQX511End8QEWLvpQHO4hgDrbnWoKAQU,6533
-microprobe/passes/ilp/__init__.py,sha256=MTxI3YMsiP6QSG82iiYdP1kIGiDJ5l9nYqInFxfs_P0,3129
+microprobe/passes/ilp/__init__.py,sha256=za9qNhm1KYwsqVV9_KkzcWubYihP7b2xg5XqBnShzYc,3209
 microprobe/passes/initialization/__init__.py,sha256=YQd9G0afMVBd2bvr7tzlD947Wsk0ioTTnn97bSzRPvo,17532
-microprobe/passes/instruction/__init__.py,sha256=Ddio2x6J4yxKodFwf7oTpaudB6PkO6IaR43F1z3P9kg,45784
+microprobe/passes/instruction/__init__.py,sha256=reffcr4-lvtGxtFB2Qfx8whBmBeQ8qIVBHPT06r41PU,45879
 microprobe/passes/memory/__init__.py,sha256=GU6rav5eNi37OEsKr2NLcOj3-qxBBputCKcqWo1SECg,106225
 microprobe/passes/register/__init__.py,sha256=1rzpVnbEc5eDtzYQxeUHeOMCnNDeAIgBOx2xDKk9kZU,39864
 microprobe/passes/structure/__init__.py,sha256=s1gHg2_GumC-EsQ5BfWwXxAfgaP-ufAlMRYmpLtBbMs,7658
 microprobe/passes/switch/__init__.py,sha256=jiGdt2SYylyx2zVzkOhytLrXCfzkKtEDyvlIopHpVFA,28125
 microprobe/passes/symbol/__init__.py,sha256=PDi4DS3Vda6FoVxHnd8Nuw_HpYTJQgiud6Y3eftChzA,11544
 microprobe/passes/variable/__init__.py,sha256=e5uB6_t71B6axZ3KVcfWdg8mTOXkw7AofeTIWeXZTh4,7484
 microprobe/schemas/__init__.py,sha256=Ux-r6dlnsCasIE7luA9Fh-YCwDFwPdxVw-XC_loO1cY,710
-microprobe/target/__init__.py,sha256=dDYNhEHpA4lCvqfsxcOcL__tzXKvB0beHbEp7PsUHgY,19638
-microprobe/target/env/__init__.py,sha256=-AkeaQgcpF-9UDCJi7yRScKlRUZ_miLmfZzgvKgWLfQ,13404
-microprobe/target/isa/__init__.py,sha256=3XkrUI-O_7XattffRnGbZ6RQycLUGNydk_wk77W5zmE,26085
-microprobe/target/isa/comparator.py,sha256=v4jDBZp6oTT1cPq5r1cnbwLEtfFh5SuNa2nqDksr4OM,4486
-microprobe/target/isa/dat.py,sha256=fbkB-hSaY1TmtMmVfY7-mX8aKMhd-mbM_QaI0AwcA4o,6482
-microprobe/target/isa/generator.py,sha256=RBAfOadKX-B_W6ZxwxAxk_5puX5fu_uV6a6oOka21m8,3506
-microprobe/target/isa/instruction.py,sha256=EMBZHCzsLLDBDgVK9D8I0F9AD39TUq18N_FMH29MbIY,66656
-microprobe/target/isa/instruction_field.py,sha256=ZJXvZicyp1AoIeAjLMsMyHSq1EhCuAQ8OHnlKW7BYAU,5783
-microprobe/target/isa/instruction_format.py,sha256=gN1ib2trFjid20DAil48Wqd9cckWBQTY--olAh1U_F4,12051
-microprobe/target/isa/operand.py,sha256=4mXaImXTXgcBxxziXwvvA70flRhBbjSR3qQMgHSTsaQ,42994
-microprobe/target/isa/register.py,sha256=kPQjCooLDCrGfaMwb80NqefIEVpJ6fXgknTmsgX7JQY,9736
-microprobe/target/isa/register_type.py,sha256=0zNTf--ZSEhSQr0NBVbBMPJ0wRxIxxFWiwvxzbHqR7k,8284
-microprobe/target/isa/schemas/__init__.py,sha256=Ux-r6dlnsCasIE7luA9Fh-YCwDFwPdxVw-XC_loO1cY,710
-microprobe/target/uarch/__init__.py,sha256=nmeazAwNup44PQe6N-jrAE0XC4-qJ4ffERA9ivbOOu0,11307
-microprobe/target/uarch/cache.py,sha256=QUA_jtkX6yAt9l5faQwzQpQge3GbJfo_zTS5_GDRA_g,14318
-microprobe/target/uarch/element.py,sha256=Cr1XV_i4qwZl5GlT1zgTMCNluCRuKarjmmQVuQXKDj4,13221
-microprobe/target/uarch/element_type.py,sha256=Bmre9usKjO1Pb7ggHUTU4-X__9aZobUm2MMlYgHE10A,4498
-microprobe/target/uarch/schemas/__init__.py,sha256=Ux-r6dlnsCasIE7luA9Fh-YCwDFwPdxVw-XC_loO1cY,710
+microprobe/target/__init__.py,sha256=J-UlN2Ih1XJGgQ4jJGxOAWiAP0ljXZb5ST_UkaU1q8Y,19806
+microprobe/target/env/__init__.py,sha256=ubXA2h9XjeIt0F8mNp1n3dKb3xOuQUS0rSv_xoNqhmM,13449
+microprobe/target/isa/__init__.py,sha256=DnzleL_aoEPjglpWrbC6vFE-RM_VTo-irImDUNo6heQ,27147
+microprobe/target/isa/comparator.py,sha256=rGr1m4fHdwDtTkTqTtyOYid0l0M-EcBSjm9EP4LNnYw,4459
+microprobe/target/isa/dat.py,sha256=d-S5UHe-Wo5cKiXxnc2hx7oJIffu_vM9eaQnI8QUjSQ,6049
+microprobe/target/isa/generator.py,sha256=hnd3PY_YORtsq3N735-lx7_-If7fUoxiCKbKODAx16E,3680
+microprobe/target/isa/instruction.py,sha256=aFMFxuCRUdnJr5OA-H4Cetcp-fI3uB72EAKDv5_r_H8,66061
+microprobe/target/isa/instruction_field.py,sha256=1R3HOo-IEROzjxMTsmlJaZ5TgrGfwLzxbUrdyf5EBRM,5792
+microprobe/target/isa/instruction_format.py,sha256=aSRs32Kcfe_5ioDP-7VNU1poks1DU6FErquTY8FWpZY,12112
+microprobe/target/isa/operand.py,sha256=Spr5jT4xgnVsgJ8wbllF8j0e20iKb70LiGXx33dwkqw,42153
+microprobe/target/isa/register.py,sha256=mrr6sSWrF57tYnn0T1S_zmmR7xb8S_A-6_W2yh9d1nQ,9777
+microprobe/target/isa/register_type.py,sha256=_mpv60e8K-sGRdl5IUbrUrwKg_M-8eDS5hntJjVqtZ8,8338
+microprobe/target/isa/schemas/__init__.py,sha256=KNzJVdMGxFqvF-VWN_O63dNwzJkLvQEqVnz-j9K6hm8,709
+microprobe/target/uarch/__init__.py,sha256=kMZfOH5VzScWp-Y1fwKLlq-gl6CDBUbZam1lSq0DXHE,11271
+microprobe/target/uarch/cache.py,sha256=s9Z7CSl1AdLJfDviS-3GHB3UQYCt2xEz78cxOlF8ZQA,14770
+microprobe/target/uarch/element.py,sha256=iICAL_l15I5B3vRLSR2RpPiQAzAORqaN78jyJT_tDGM,12934
+microprobe/target/uarch/element_type.py,sha256=B-qHuiOUGpRXfPF12ztWxWbB36AHzMkzoitAqjQzo1Q,4558
+microprobe/target/uarch/schemas/__init__.py,sha256=KNzJVdMGxFqvF-VWN_O63dNwzJkLvQEqVnz-j9K6hm8,709
 microprobe/utils/__init__.py,sha256=WNtWMQuAHDyg8erQ5hD_UFR6o7sdkA4oLgvNvsQdkHg,670
 microprobe/utils/asm.py,sha256=Fp4CtQmsVjSXrUNpO6rlag7Cet6rakuIOTohReqRGRQ,46408
 microprobe/utils/bin.py,sha256=8t14AzTtwAonOeEY1QC8Eqh9LzpitfKW0VcZH10SJuM,33575
 microprobe/utils/cache.py,sha256=lX-n-3Gf4YHy7CGKnwohy2PeEJEbZ3XPn0GcAA-O3Eo,6526
 microprobe/utils/cmdline.py,sha256=mJBm_LMUXv_fzn_TrgfT9w_RiG1CKqjRrQfUTmk71K0,56510
 microprobe/utils/config.py,sha256=GQPIGTpQC5QzVvPSKmqJaP79T9Fiquz2oeUxJkqdBYo,18127
 microprobe/utils/distrib.py,sha256=unvAFCtvekrCEaSlWGkSKnCz66ZNvgbUtju2aQR8yYQ,10924
@@ -63,12 +63,12 @@
 microprobe/utils/misc.py,sha256=7JOQ_OGpOvt6gGuukgNuu7q0IfxUm5WmeTirjKllohg,14194
 microprobe/utils/mpt.py,sha256=6CjAQlz8aAuemZSS7TFY0DDImwgLIscLTdSk8zQloYU,72494
 microprobe/utils/objdump.py,sha256=xkr0ZZJsRZ7kjFNUCTsq5DjjeCE5fnAN4qadYC3-Crw,11342
 microprobe/utils/policy.py,sha256=YwuOJjN6_v4dTLET691QjgHoI-GxBwpX5KxMBRmCiQU,2718
 microprobe/utils/profile.py,sha256=L3O0cEbcYUHOM9DKEulhCTmLKadhWp7CMWHMuhk2seU,1169
 microprobe/utils/run.py,sha256=ymTUlbRtXeqy8taojUaZtqXny5xcoTXx_Fn5DltTN14,2869
 microprobe/utils/yaml.py,sha256=qy4XXg0ySNZ1YanaX3a-eA41-A7IrLLP0bR4ajh0U1M,5319
-microprobe_all-0.5.20230629114852.dist-info/LICENSE,sha256=QwcOLU5TJoTeUhuIXzhdCEEDDvorGiC6-3YTOl4TecE,11356
-microprobe_all-0.5.20230629114852.dist-info/METADATA,sha256=2m6aVksQsQPWJCZ6HyM7jXgq4-pnDcxeb29NvZUs5vI,1875
-microprobe_all-0.5.20230629114852.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
-microprobe_all-0.5.20230629114852.dist-info/top_level.txt,sha256=sqL1S5Li8qj775XsE8O3G5TdfrxkmzJK6lip8ZbPyaM,11
-microprobe_all-0.5.20230629114852.dist-info/RECORD,,
+microprobe_all-0.5.20230713062001.dist-info/LICENSE,sha256=QwcOLU5TJoTeUhuIXzhdCEEDDvorGiC6-3YTOl4TecE,11356
+microprobe_all-0.5.20230713062001.dist-info/METADATA,sha256=nMKH5bsaEQl8bhPX6yNEi5exoPL1yc75r2EV4MlMOhI,1875
+microprobe_all-0.5.20230713062001.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+microprobe_all-0.5.20230713062001.dist-info/top_level.txt,sha256=sqL1S5Li8qj775XsE8O3G5TdfrxkmzJK6lip8ZbPyaM,11
+microprobe_all-0.5.20230713062001.dist-info/RECORD,,
```

